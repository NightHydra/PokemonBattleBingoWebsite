#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/StringScanner.js
var require_StringScanner = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/StringScanner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringScanner = void 0;
    var emptyString = "";
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var StringScanner = class {
      constructor(string) {
        this.charCount = this.charLength(string, true);
        this.charIndex = 0;
        this.length = string.length;
        this.multiByteMode = this.charCount !== this.length;
        this.string = string;
        if (this.multiByteMode) {
          let charsToBytes = [];
          for (let byteIndex = 0, charIndex = 0; charIndex < this.charCount; ++charIndex) {
            charsToBytes[charIndex] = byteIndex;
            byteIndex += string.codePointAt(byteIndex) > 65535 ? 2 : 1;
          }
          this.charsToBytes = charsToBytes;
        }
      }
      /**
       * Whether the current character index is at the end of the input string.
       */
      get isEnd() {
        return this.charIndex >= this.charCount;
      }
      // -- Protected Methods ------------------------------------------------------
      /**
       * Returns the number of characters in the given string, which may differ from
       * the byte length if the string contains multibyte characters.
       */
      charLength(string, multiByteSafe = this.multiByteMode) {
        return multiByteSafe ? string.replace(surrogatePair, "_").length : string.length;
      }
      // -- Public Methods ---------------------------------------------------------
      /**
       * Advances the scanner by the given number of characters, stopping if the end
       * of the string is reached.
       */
      advance(count = 1) {
        this.charIndex = Math.min(this.charCount, this.charIndex + count);
      }
      /**
       * Returns the byte index of the given character index in the string. The two
       * may differ in strings that contain multibyte characters.
       */
      charIndexToByteIndex(charIndex = this.charIndex) {
        return this.multiByteMode ? this.charsToBytes[charIndex] ?? Infinity : charIndex;
      }
      /**
       * Consumes and returns the given number of characters if possible, advancing
       * the scanner and stopping if the end of the string is reached.
       *
       * If no characters could be consumed, an empty string will be returned.
       */
      consume(charCount = 1) {
        let chars = this.peek(charCount);
        this.advance(charCount);
        return chars;
      }
      /**
       * Consumes and returns the given number of bytes if possible, advancing the
       * scanner and stopping if the end of the string is reached.
       *
       * It's up to the caller to ensure that the given byte count doesn't split a
       * multibyte character.
       *
       * If no bytes could be consumed, an empty string will be returned.
       */
      consumeBytes(byteCount) {
        let byteIndex = this.charIndexToByteIndex();
        let result = this.string.slice(byteIndex, byteIndex + byteCount);
        this.advance(this.charLength(result));
        return result;
      }
      /**
       * Consumes and returns all characters for which the given function returns
       * `true`, stopping when `false` is returned or the end of the input is
       * reached.
       */
      consumeMatchFn(fn) {
        let { length, multiByteMode, string } = this;
        let startByteIndex = this.charIndexToByteIndex();
        let endByteIndex = startByteIndex;
        if (multiByteMode) {
          while (endByteIndex < length) {
            let char = string[endByteIndex];
            let isSurrogatePair = char >= "\uD800" && char <= "\uDBFF";
            if (isSurrogatePair) {
              char += string[endByteIndex + 1];
            }
            if (!fn(char)) {
              break;
            }
            endByteIndex += isSurrogatePair ? 2 : 1;
          }
        } else {
          while (endByteIndex < length && fn(string[endByteIndex])) {
            ++endByteIndex;
          }
        }
        return this.consumeBytes(endByteIndex - startByteIndex);
      }
      /**
       * Consumes the given string if it exists at the current character index, and
       * advances the scanner.
       *
       * If the given string doesn't exist at the current character index, an empty
       * string will be returned and the scanner will not be advanced.
       */
      consumeString(stringToConsume) {
        let { length } = stringToConsume;
        let byteIndex = this.charIndexToByteIndex();
        if (stringToConsume === this.string.slice(byteIndex, byteIndex + length)) {
          this.advance(length === 1 ? 1 : this.charLength(stringToConsume));
          return stringToConsume;
        }
        return emptyString;
      }
      /**
       * Consumes characters until the given global regex is matched, advancing the
       * scanner up to (but not beyond) the beginning of the match. If the regex
       * doesn't match, nothing will be consumed.
       *
       * Returns the consumed string, or an empty string if nothing was consumed.
       */
      consumeUntilMatch(regex) {
        let matchByteIndex = this.string.slice(this.charIndexToByteIndex()).search(regex);
        return matchByteIndex > 0 ? this.consumeBytes(matchByteIndex) : emptyString;
      }
      /**
       * Consumes characters until the given string is found, advancing the scanner
       * up to (but not beyond) that point. If the string is never found, nothing
       * will be consumed.
       *
       * Returns the consumed string, or an empty string if nothing was consumed.
       */
      consumeUntilString(searchString) {
        let byteIndex = this.charIndexToByteIndex();
        let matchByteIndex = this.string.indexOf(searchString, byteIndex);
        return matchByteIndex > 0 ? this.consumeBytes(matchByteIndex - byteIndex) : emptyString;
      }
      /**
       * Returns the given number of characters starting at the current character
       * index, without advancing the scanner and without exceeding the end of the
       * input string.
       */
      peek(count = 1) {
        let { charIndex, string } = this;
        return this.multiByteMode ? string.slice(this.charIndexToByteIndex(charIndex), this.charIndexToByteIndex(charIndex + count)) : string.slice(charIndex, charIndex + count);
      }
      /**
       * Resets the scanner position to the given character _index_, or to the start
       * of the input string if no index is given.
       *
       * If _index_ is negative, the scanner position will be moved backward by that
       * many characters, stopping if the beginning of the string is reached.
       */
      reset(index = 0) {
        this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);
      }
    };
    exports.StringScanner = StringScanner;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.predefinedEntities = exports.endCharData = exports.attValueNormalizedWhitespace = exports.attValueCharSingleQuote = exports.attValueCharDoubleQuote = void 0;
    exports.isNameChar = isNameChar;
    exports.isNameStartChar = isNameStartChar;
    exports.isReferenceChar = isReferenceChar;
    exports.isWhitespace = isWhitespace;
    exports.isXmlCodePoint = isXmlCodePoint;
    exports.attValueCharDoubleQuote = /["&<]/;
    exports.attValueCharSingleQuote = /['&<]/;
    exports.attValueNormalizedWhitespace = /\r\n|[\n\r\t]/g;
    exports.endCharData = /<|&|]]>/;
    exports.predefinedEntities = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }));
    function isNameChar(char) {
      let cp = char.codePointAt(0);
      return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp >= 48 && cp <= 57 || cp === 45 || cp === 46 || cp === 183 || cp >= 768 && cp <= 879 || cp === 8255 || cp === 8256 || isNameStartChar(char, cp);
    }
    function isNameStartChar(char, cp = char.codePointAt(0)) {
      return cp >= 97 && cp <= 122 || cp >= 65 && cp <= 90 || cp === 58 || cp === 95 || cp >= 192 && cp <= 214 || cp >= 216 && cp <= 246 || cp >= 248 && cp <= 767 || cp >= 880 && cp <= 893 || cp >= 895 && cp <= 8191 || cp === 8204 || cp === 8205 || cp >= 8304 && cp <= 8591 || cp >= 11264 && cp <= 12271 || cp >= 12289 && cp <= 55295 || cp >= 63744 && cp <= 64975 || cp >= 65008 && cp <= 65533 || cp >= 65536 && cp <= 983039;
    }
    function isReferenceChar(char) {
      return char === "#" || isNameChar(char);
    }
    function isWhitespace(char) {
      let cp = char.codePointAt(0);
      return cp === 32 || cp === 9 || cp === 10 || cp === 13;
    }
    function isXmlCodePoint(cp) {
      return cp >= 32 && cp <= 55295 || cp === 10 || cp === 9 || cp === 13 || cp >= 57344 && cp <= 65533 || cp >= 65536 && cp <= 1114111;
    }
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlNode.js
var require_XmlNode = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlNode = void 0;
    var XmlNode = class _XmlNode {
      constructor() {
        this.parent = null;
        this.start = -1;
        this.end = -1;
      }
      /**
       * Document that contains this node, or `null` if this node is not associated
       * with a document.
       */
      get document() {
        return this.parent?.document ?? null;
      }
      /**
       * Whether this node is the root node of the document (also known as the
       * document element).
       */
      get isRootNode() {
        return this.parent !== null && this.parent === this.document && this.type === _XmlNode.TYPE_ELEMENT;
      }
      /**
       * Whether whitespace should be preserved in the content of this element and
       * its children.
       *
       * This is influenced by the value of the special `xml:space` attribute, and
       * will be `true` for any node whose `xml:space` attribute is set to
       * "preserve". If a node has no such attribute, it will inherit the value of
       * the nearest ancestor that does (if any).
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-white-space
       */
      get preserveWhitespace() {
        return !!this.parent?.preserveWhitespace;
      }
      /**
       * Type of this node.
       *
       * The value of this property is a string that matches one of the static
       * `TYPE_*` properties on the `XmlNode` class (e.g. `TYPE_ELEMENT`,
       * `TYPE_TEXT`, etc.).
       *
       * The `XmlNode` class itself is a base class and doesn't have its own type
       * name.
       */
      get type() {
        return "";
      }
      /**
       * Returns a JSON-serializable object representing this node, minus properties
       * that could result in circular references.
       */
      toJSON() {
        let json = {
          type: this.type
        };
        if (this.isRootNode) {
          json.isRootNode = true;
        }
        if (this.preserveWhitespace) {
          json.preserveWhitespace = true;
        }
        if (this.start !== -1) {
          json.start = this.start;
          json.end = this.end;
        }
        return json;
      }
    };
    exports.XmlNode = XmlNode;
    XmlNode.TYPE_CDATA = "cdata";
    XmlNode.TYPE_COMMENT = "comment";
    XmlNode.TYPE_DOCUMENT = "document";
    XmlNode.TYPE_DOCUMENT_TYPE = "doctype";
    XmlNode.TYPE_ELEMENT = "element";
    XmlNode.TYPE_PROCESSING_INSTRUCTION = "pi";
    XmlNode.TYPE_TEXT = "text";
    XmlNode.TYPE_XML_DECLARATION = "xmldecl";
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlText.js
var require_XmlText = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlText = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlText2 = class extends XmlNode_js_1.XmlNode {
      constructor(text = "") {
        super();
        this.text = text;
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_TEXT;
      }
      toJSON() {
        return Object.assign(XmlNode_js_1.XmlNode.prototype.toJSON.call(this), {
          text: this.text
        });
      }
    };
    exports.XmlText = XmlText2;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlCdata.js
var require_XmlCdata = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlCdata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlCdata = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlText_js_1 = require_XmlText();
    var XmlCdata = class extends XmlText_js_1.XmlText {
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_CDATA;
      }
    };
    exports.XmlCdata = XmlCdata;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlComment.js
var require_XmlComment = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlComment = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlComment = class extends XmlNode_js_1.XmlNode {
      constructor(content = "") {
        super();
        this.content = content;
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_COMMENT;
      }
      toJSON() {
        return Object.assign(XmlNode_js_1.XmlNode.prototype.toJSON.call(this), {
          content: this.content
        });
      }
    };
    exports.XmlComment = XmlComment;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDeclaration.js
var require_XmlDeclaration = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDeclaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlDeclaration = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlDeclaration = class extends XmlNode_js_1.XmlNode {
      constructor(version, encoding, standalone) {
        super();
        this.version = version;
        this.encoding = encoding ?? null;
        this.standalone = standalone ?? null;
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_XML_DECLARATION;
      }
      toJSON() {
        let json = XmlNode_js_1.XmlNode.prototype.toJSON.call(this);
        json.version = this.version;
        for (let key of ["encoding", "standalone"]) {
          if (this[key] !== null) {
            json[key] = this[key];
          }
        }
        return json;
      }
    };
    exports.XmlDeclaration = XmlDeclaration;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlElement.js
var require_XmlElement = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlElement = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlElement2 = class _XmlElement extends XmlNode_js_1.XmlNode {
      constructor(name2, attributes = /* @__PURE__ */ Object.create(null), children = []) {
        super();
        this.name = name2;
        this.attributes = attributes;
        this.children = children;
      }
      /**
       * Whether this element is empty (meaning it has no children).
       */
      get isEmpty() {
        return this.children.length === 0;
      }
      get preserveWhitespace() {
        let node = this;
        while (node instanceof _XmlElement) {
          if ("xml:space" in node.attributes) {
            return node.attributes["xml:space"] === "preserve";
          }
          node = node.parent;
        }
        return false;
      }
      /**
       * Text content of this element and all its descendants.
       */
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_ELEMENT;
      }
      toJSON() {
        return Object.assign(XmlNode_js_1.XmlNode.prototype.toJSON.call(this), {
          name: this.name,
          attributes: this.attributes,
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    exports.XmlElement = XmlElement2;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDocument.js
var require_XmlDocument = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlDocument = void 0;
    var XmlElement_js_1 = require_XmlElement();
    var XmlNode_js_1 = require_XmlNode();
    var XmlDocument = class extends XmlNode_js_1.XmlNode {
      constructor(children = []) {
        super();
        this.children = children;
      }
      get document() {
        return this;
      }
      /**
       * Root element of this document, or `null` if this document is empty.
       */
      get root() {
        for (let child of this.children) {
          if (child instanceof XmlElement_js_1.XmlElement) {
            return child;
          }
        }
        return null;
      }
      /**
       * Text content of this document and all its descendants.
       */
      get text() {
        return this.children.map((child) => "text" in child ? child.text : "").join("");
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_DOCUMENT;
      }
      toJSON() {
        return Object.assign(XmlNode_js_1.XmlNode.prototype.toJSON.call(this), {
          children: this.children.map((child) => child.toJSON())
        });
      }
    };
    exports.XmlDocument = XmlDocument;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDocumentType.js
var require_XmlDocumentType = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlDocumentType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlDocumentType = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlDocumentType = class extends XmlNode_js_1.XmlNode {
      constructor(name2, publicId, systemId, internalSubset) {
        super();
        this.name = name2;
        this.publicId = publicId ?? null;
        this.systemId = systemId ?? null;
        this.internalSubset = internalSubset ?? null;
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_DOCUMENT_TYPE;
      }
      toJSON() {
        let json = XmlNode_js_1.XmlNode.prototype.toJSON.call(this);
        json.name = this.name;
        for (let key of ["publicId", "systemId", "internalSubset"]) {
          if (this[key] !== null) {
            json[key] = this[key];
          }
        }
        return json;
      }
    };
    exports.XmlDocumentType = XmlDocumentType;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlError.js
var require_XmlError = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlError = void 0;
    var XmlError = class extends Error {
      constructor(message, charIndex, xml) {
        let column = 1;
        let excerpt = "";
        let line = 1;
        for (let i3 = 0; i3 < charIndex; ++i3) {
          let char = xml[i3];
          if (char === "\n") {
            column = 1;
            excerpt = "";
            line += 1;
          } else {
            column += 1;
            excerpt += char;
          }
        }
        let eol = xml.indexOf("\n", charIndex);
        excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);
        let excerptStart = 0;
        if (excerpt.length > 50) {
          if (column < 40) {
            excerpt = excerpt.slice(0, 50);
          } else {
            excerptStart = column - 20;
            excerpt = excerpt.slice(excerptStart, column + 30);
          }
        }
        super(`${message} (line ${line}, column ${column})
  ${excerpt}
` + " ".repeat(column - excerptStart + 1) + "^\n");
        this.column = column;
        this.excerpt = excerpt;
        this.line = line;
        this.name = "XmlError";
        this.pos = charIndex;
      }
    };
    exports.XmlError = XmlError;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlProcessingInstruction.js
var require_XmlProcessingInstruction = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/XmlProcessingInstruction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlProcessingInstruction = void 0;
    var XmlNode_js_1 = require_XmlNode();
    var XmlProcessingInstruction = class extends XmlNode_js_1.XmlNode {
      constructor(name2, content = "") {
        super();
        this.name = name2;
        this.content = content;
      }
      get type() {
        return XmlNode_js_1.XmlNode.TYPE_PROCESSING_INSTRUCTION;
      }
      toJSON() {
        return Object.assign(XmlNode_js_1.XmlNode.prototype.toJSON.call(this), {
          name: this.name,
          content: this.content
        });
      }
    };
    exports.XmlProcessingInstruction = XmlProcessingInstruction;
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/Parser.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var StringScanner_js_1 = require_StringScanner();
    var syntax = __importStar(require_syntax());
    var XmlCdata_js_1 = require_XmlCdata();
    var XmlComment_js_1 = require_XmlComment();
    var XmlDeclaration_js_1 = require_XmlDeclaration();
    var XmlDocument_js_1 = require_XmlDocument();
    var XmlDocumentType_js_1 = require_XmlDocumentType();
    var XmlElement_js_1 = require_XmlElement();
    var XmlError_js_1 = require_XmlError();
    var XmlNode_js_1 = require_XmlNode();
    var XmlProcessingInstruction_js_1 = require_XmlProcessingInstruction();
    var XmlText_js_1 = require_XmlText();
    var emptyString = "";
    var Parser3 = class {
      /**
       * @param xml XML string to parse.
       * @param options Parser options.
       */
      constructor(xml, options = {}) {
        let doc = this.document = new XmlDocument_js_1.XmlDocument();
        this.currentNode = doc;
        this.options = options;
        this.scanner = new StringScanner_js_1.StringScanner(xml);
        if (this.options.includeOffsets) {
          doc.start = 0;
          doc.end = xml.length;
        }
        this.parse();
      }
      /**
       * Adds the given `XmlNode` as a child of `this.currentNode`.
       */
      addNode(node, charIndex) {
        node.parent = this.currentNode;
        if (this.options.includeOffsets) {
          node.start = this.scanner.charIndexToByteIndex(charIndex);
          node.end = this.scanner.charIndexToByteIndex();
        }
        this.currentNode.children.push(node);
        return true;
      }
      /**
       * Adds the given _text_ to the document, either by appending it to a
       * preceding `XmlText` node (if possible) or by creating a new `XmlText` node.
       */
      addText(text, charIndex) {
        let { children } = this.currentNode;
        let { length } = children;
        text = normalizeLineBreaks(text);
        if (length > 0) {
          let prevNode = children[length - 1];
          if (prevNode?.type === XmlNode_js_1.XmlNode.TYPE_TEXT) {
            let textNode = prevNode;
            textNode.text += text;
            if (this.options.includeOffsets) {
              textNode.end = this.scanner.charIndexToByteIndex();
            }
            return true;
          }
        }
        return this.addNode(new XmlText_js_1.XmlText(text), charIndex);
      }
      /**
       * Consumes element attributes.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-starttags
       */
      consumeAttributes() {
        let attributes = /* @__PURE__ */ Object.create(null);
        while (this.consumeWhitespace()) {
          let attrName = this.consumeName();
          if (!attrName) {
            break;
          }
          let attrValue = this.consumeEqual() && this.consumeAttributeValue();
          if (attrValue === false) {
            throw this.error("Attribute value expected");
          }
          if (attrName in attributes) {
            throw this.error(`Duplicate attribute: ${attrName}`);
          }
          if (attrName === "xml:space" && attrValue !== "default" && attrValue !== "preserve") {
            throw this.error('Value of the `xml:space` attribute must be "default" or "preserve"');
          }
          attributes[attrName] = attrValue;
        }
        if (this.options.sortAttributes) {
          let attrNames = Object.keys(attributes).sort();
          let sortedAttributes = /* @__PURE__ */ Object.create(null);
          for (let i3 = 0; i3 < attrNames.length; ++i3) {
            let attrName = attrNames[i3];
            sortedAttributes[attrName] = attributes[attrName];
          }
          attributes = sortedAttributes;
        }
        return attributes;
      }
      /**
       * Consumes an `AttValue` (attribute value) if possible.
       *
       * @returns
       *   Contents of the `AttValue` minus quotes, or `false` if nothing was
       *   consumed. An empty string indicates that an `AttValue` was consumed but
       *   was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue
       */
      consumeAttributeValue() {
        let { scanner } = this;
        let quote = scanner.peek();
        if (quote !== '"' && quote !== "'") {
          return false;
        }
        scanner.advance();
        let chars;
        let isClosed = false;
        let value = emptyString;
        let regex = quote === '"' ? syntax.attValueCharDoubleQuote : syntax.attValueCharSingleQuote;
        matchLoop: while (!scanner.isEnd) {
          chars = scanner.consumeUntilMatch(regex);
          if (chars) {
            this.validateChars(chars);
            value += chars.replace(syntax.attValueNormalizedWhitespace, " ");
          }
          switch (scanner.peek()) {
            case quote:
              isClosed = true;
              break matchLoop;
            case "&":
              value += this.consumeReference();
              continue;
            case "<":
              throw this.error("Unescaped `<` is not allowed in an attribute value");
            default:
              break matchLoop;
          }
        }
        if (!isClosed) {
          throw this.error("Unclosed attribute");
        }
        scanner.advance();
        return value;
      }
      /**
       * Consumes a CDATA section if possible.
       *
       * @returns Whether a CDATA section was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect
       */
      consumeCdataSection() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<![CDATA[")) {
          return false;
        }
        let text = scanner.consumeUntilString("]]>");
        this.validateChars(text);
        if (!scanner.consumeString("]]>")) {
          throw this.error("Unclosed CDATA section");
        }
        return this.options.preserveCdata ? this.addNode(new XmlCdata_js_1.XmlCdata(normalizeLineBreaks(text)), startIndex) : this.addText(text, startIndex);
      }
      /**
       * Consumes character data if possible.
       *
       * @returns Whether character data was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata
       */
      consumeCharData() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        let charData = scanner.consumeUntilMatch(syntax.endCharData);
        if (!charData) {
          return false;
        }
        this.validateChars(charData);
        if (scanner.peek(3) === "]]>") {
          throw this.error("Element content may not contain the CDATA section close delimiter `]]>`");
        }
        return this.addText(charData, startIndex);
      }
      /**
       * Consumes a comment if possible.
       *
       * @returns Whether a comment was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment
       */
      consumeComment() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<!--")) {
          return false;
        }
        let content = scanner.consumeUntilString("--");
        this.validateChars(content);
        if (!scanner.consumeString("-->")) {
          if (scanner.peek(2) === "--") {
            throw this.error("The string `--` isn't allowed inside a comment");
          }
          throw this.error("Unclosed comment");
        }
        return this.options.preserveComments ? this.addNode(new XmlComment_js_1.XmlComment(normalizeLineBreaks(content)), startIndex) : true;
      }
      /**
       * Consumes a reference in a content context if possible.
       *
       * This differs from `consumeReference()` in that a consumed reference will be
       * added to the document as a text node instead of returned.
       *
       * @returns Whether a reference was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc
       */
      consumeContentReference() {
        let startIndex = this.scanner.charIndex;
        let ref = this.consumeReference();
        return ref ? this.addText(ref, startIndex) : false;
      }
      /**
       * Consumes a doctype declaration if possible.
       *
       * This is a loose implementation since doctype declarations are currently
       * discarded without further parsing.
       *
       * @returns Whether a doctype declaration was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd
       */
      consumeDoctypeDeclaration() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<!DOCTYPE")) {
          return false;
        }
        let name2 = this.consumeWhitespace() && this.consumeName();
        if (!name2) {
          throw this.error("Expected a name");
        }
        let publicId;
        let systemId;
        if (this.consumeWhitespace()) {
          if (scanner.consumeString("PUBLIC")) {
            publicId = this.consumeWhitespace() && this.consumePubidLiteral();
            if (publicId === false) {
              throw this.error("Expected a public identifier");
            }
            this.consumeWhitespace();
          }
          if (publicId !== void 0 || scanner.consumeString("SYSTEM")) {
            this.consumeWhitespace();
            systemId = this.consumeSystemLiteral();
            if (systemId === false) {
              throw this.error("Expected a system identifier");
            }
            this.consumeWhitespace();
          }
        }
        let internalSubset;
        if (scanner.consumeString("[")) {
          internalSubset = scanner.consumeUntilMatch(/\][\x20\t\r\n]*>/);
          if (!scanner.consumeString("]")) {
            throw this.error("Unclosed internal subset");
          }
          this.consumeWhitespace();
        }
        if (!scanner.consumeString(">")) {
          throw this.error("Unclosed doctype declaration");
        }
        return this.options.preserveDocumentType ? this.addNode(new XmlDocumentType_js_1.XmlDocumentType(name2, publicId, systemId, internalSubset), startIndex) : true;
      }
      /**
       * Consumes an element if possible.
       *
       * @returns Whether an element was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element
       */
      consumeElement() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<")) {
          return false;
        }
        let name2 = this.consumeName();
        if (!name2) {
          scanner.reset(startIndex);
          return false;
        }
        let attributes = this.consumeAttributes();
        let isEmpty = !!scanner.consumeString("/>");
        let element = new XmlElement_js_1.XmlElement(name2, attributes);
        element.parent = this.currentNode;
        if (!isEmpty) {
          if (!scanner.consumeString(">")) {
            throw this.error(`Unclosed start tag for element \`${name2}\``);
          }
          this.currentNode = element;
          do {
            this.consumeCharData();
          } while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment());
          let endTagMark = scanner.charIndex;
          let endTagName;
          if (!scanner.consumeString("</") || !(endTagName = this.consumeName()) || endTagName !== name2) {
            scanner.reset(endTagMark);
            throw this.error(`Missing end tag for element ${name2}`);
          }
          this.consumeWhitespace();
          if (!scanner.consumeString(">")) {
            throw this.error(`Unclosed end tag for element ${name2}`);
          }
          this.currentNode = element.parent;
        }
        return this.addNode(element, startIndex);
      }
      /**
       * Consumes an `Eq` production if possible.
       *
       * @returns Whether an `Eq` production was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq
       */
      consumeEqual() {
        this.consumeWhitespace();
        if (this.scanner.consumeString("=")) {
          this.consumeWhitespace();
          return true;
        }
        return false;
      }
      /**
       * Consumes `Misc` content if possible.
       *
       * @returns Whether anything was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc
       */
      consumeMisc() {
        return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();
      }
      /**
       * Consumes one or more `Name` characters if possible.
       *
       * @returns `Name` characters, or an empty string if none were consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
       */
      consumeName() {
        return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;
      }
      /**
       * Consumes a processing instruction if possible.
       *
       * @returns Whether a processing instruction was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi
       */
      consumeProcessingInstruction() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<?")) {
          return false;
        }
        let name2 = this.consumeName();
        if (name2) {
          if (name2.toLowerCase() === "xml") {
            scanner.reset(startIndex);
            throw this.error("XML declaration isn't allowed here");
          }
        } else {
          throw this.error("Invalid processing instruction");
        }
        if (!this.consumeWhitespace()) {
          if (scanner.consumeString("?>")) {
            return this.addNode(new XmlProcessingInstruction_js_1.XmlProcessingInstruction(name2), startIndex);
          }
          throw this.error("Whitespace is required after a processing instruction name");
        }
        let content = scanner.consumeUntilString("?>");
        this.validateChars(content);
        if (!scanner.consumeString("?>")) {
          throw this.error("Unterminated processing instruction");
        }
        return this.addNode(new XmlProcessingInstruction_js_1.XmlProcessingInstruction(name2, normalizeLineBreaks(content)), startIndex);
      }
      /**
       * Consumes a prolog if possible.
       *
       * @returns Whether a prolog was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd
       */
      consumeProlog() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        this.consumeXmlDeclaration();
        while (this.consumeMisc()) {
        }
        if (this.consumeDoctypeDeclaration()) {
          while (this.consumeMisc()) {
          }
        }
        return startIndex < scanner.charIndex;
      }
      /**
       * Consumes a public identifier literal if possible.
       *
       * @returns
       *   Value of the public identifier literal minus quotes, or `false` if
       *   nothing was consumed. An empty string indicates that a public id literal
       *   was consumed but was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-PubidLiteral
       */
      consumePubidLiteral() {
        let startIndex = this.scanner.charIndex;
        let value = this.consumeSystemLiteral();
        if (value !== false && !/^[-\x20\r\na-zA-Z0-9'()+,./:=?;!*#@$_%]*$/.test(value)) {
          this.scanner.reset(startIndex);
          throw this.error("Invalid character in public identifier");
        }
        return value;
      }
      /**
       * Consumes a reference if possible.
       *
       * This differs from `consumeContentReference()` in that a consumed reference
       * will be returned rather than added to the document.
       *
       * @returns
       *   Parsed reference value, or `false` if nothing was consumed (to
       *   distinguish from a reference that resolves to an empty string).
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference
       */
      consumeReference() {
        let { scanner } = this;
        if (!scanner.consumeString("&")) {
          return false;
        }
        let ref = scanner.consumeMatchFn(syntax.isReferenceChar);
        if (scanner.consume() !== ";") {
          throw this.error("Unterminated reference (a reference must end with `;`)");
        }
        let parsedValue;
        if (ref[0] === "#") {
          let codePoint = ref[1] === "x" ? parseInt(ref.slice(2), 16) : parseInt(ref.slice(1), 10);
          if (isNaN(codePoint)) {
            throw this.error("Invalid character reference");
          }
          if (!syntax.isXmlCodePoint(codePoint)) {
            throw this.error("Character reference resolves to an invalid character");
          }
          parsedValue = String.fromCodePoint(codePoint);
        } else {
          parsedValue = syntax.predefinedEntities[ref];
          if (parsedValue === void 0) {
            let { ignoreUndefinedEntities, resolveUndefinedEntity } = this.options;
            let wrappedRef = `&${ref};`;
            if (resolveUndefinedEntity) {
              let resolvedValue = resolveUndefinedEntity(wrappedRef);
              if (resolvedValue !== null && resolvedValue !== void 0) {
                let type = typeof resolvedValue;
                if (type !== "string") {
                  throw new TypeError(`\`resolveUndefinedEntity()\` must return a string, \`null\`, or \`undefined\`, but returned a value of type ${type}`);
                }
                return resolvedValue;
              }
            }
            if (ignoreUndefinedEntities) {
              return wrappedRef;
            }
            scanner.reset(-wrappedRef.length);
            throw this.error(`Named entity isn't defined: ${wrappedRef}`);
          }
        }
        return parsedValue;
      }
      /**
       * Consumes a `SystemLiteral` if possible.
       *
       * A `SystemLiteral` is similar to an attribute value, but allows the
       * characters `<` and `&` and doesn't replace references.
       *
       * @returns
       *   Value of the `SystemLiteral` minus quotes, or `false` if nothing was
       *   consumed. An empty string indicates that a `SystemLiteral` was consumed
       *   but was empty.
       *
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral
       */
      consumeSystemLiteral() {
        let { scanner } = this;
        let quote = scanner.consumeString('"') || scanner.consumeString("'");
        if (!quote) {
          return false;
        }
        let value = scanner.consumeUntilString(quote);
        this.validateChars(value);
        if (!scanner.consumeString(quote)) {
          throw this.error("Missing end quote");
        }
        return value;
      }
      /**
       * Consumes one or more whitespace characters if possible.
       *
       * @returns Whether any whitespace characters were consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#white
       */
      consumeWhitespace() {
        return !!this.scanner.consumeMatchFn(syntax.isWhitespace);
      }
      /**
       * Consumes an XML declaration if possible.
       *
       * @returns Whether an XML declaration was consumed.
       * @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl
       */
      consumeXmlDeclaration() {
        let { scanner } = this;
        let startIndex = scanner.charIndex;
        if (!scanner.consumeString("<?xml")) {
          return false;
        }
        if (!this.consumeWhitespace()) {
          throw this.error("Invalid XML declaration");
        }
        let version = !!scanner.consumeString("version") && this.consumeEqual() && this.consumeSystemLiteral();
        if (version === false) {
          throw this.error("XML version is missing or invalid");
        } else if (!/^1\.[0-9]+$/.test(version)) {
          throw this.error("Invalid character in version number");
        }
        let encoding;
        let standalone;
        if (this.consumeWhitespace()) {
          encoding = !!scanner.consumeString("encoding") && this.consumeEqual() && this.consumeSystemLiteral();
          if (encoding) {
            if (!/^[A-Za-z][\w.-]*$/.test(encoding)) {
              throw this.error("Invalid character in encoding name");
            }
            this.consumeWhitespace();
          }
          standalone = !!scanner.consumeString("standalone") && this.consumeEqual() && this.consumeSystemLiteral();
          if (standalone) {
            if (standalone !== "yes" && standalone !== "no") {
              throw this.error('Only "yes" and "no" are permitted as values of `standalone`');
            }
            this.consumeWhitespace();
          }
        }
        if (!scanner.consumeString("?>")) {
          throw this.error("Invalid or unclosed XML declaration");
        }
        return this.options.preserveXmlDeclaration ? this.addNode(new XmlDeclaration_js_1.XmlDeclaration(version, encoding || void 0, standalone || void 0), startIndex) : true;
      }
      /**
       * Returns an `XmlError` for the current scanner position.
       */
      error(message) {
        let { scanner } = this;
        return new XmlError_js_1.XmlError(message, scanner.charIndex, scanner.string);
      }
      /**
       * Parses the XML input.
       */
      parse() {
        this.scanner.consumeString("\uFEFF");
        this.consumeProlog();
        if (!this.consumeElement()) {
          throw this.error("Root element is missing or invalid");
        }
        while (this.consumeMisc()) {
        }
        if (!this.scanner.isEnd) {
          throw this.error("Extra content at the end of the document");
        }
      }
      /**
       * Throws an invalid character error if any character in the given _string_
       * isn't a valid XML character.
       */
      validateChars(string) {
        let { length } = string;
        for (let i3 = 0; i3 < length; ++i3) {
          let cp = string.codePointAt(i3);
          if (!syntax.isXmlCodePoint(cp)) {
            this.scanner.reset(-([...string].length - i3));
            throw this.error("Invalid character");
          }
          if (cp > 65535) {
            i3 += 1;
          }
        }
      }
    };
    exports.Parser = Parser3;
    function normalizeLineBreaks(text) {
      let i3 = 0;
      while ((i3 = text.indexOf("\r", i3)) !== -1) {
        text = text[i3 + 1] === "\n" ? text.slice(0, i3) + text.slice(i3 + 1) : text.slice(0, i3) + "\n" + text.slice(i3 + 1);
      }
      return text;
    }
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@rgrove+parse-xml@4.2.0/node_modules/@rgrove/parse-xml/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XmlText = exports.XmlProcessingInstruction = exports.XmlNode = exports.XmlError = exports.XmlElement = exports.XmlDocumentType = exports.XmlDocument = exports.XmlDeclaration = exports.XmlComment = exports.XmlCdata = void 0;
    exports.parseXml = parseXml2;
    var Parser_js_1 = require_Parser();
    __exportStar(require_types(), exports);
    var XmlCdata_js_1 = require_XmlCdata();
    Object.defineProperty(exports, "XmlCdata", { enumerable: true, get: function() {
      return XmlCdata_js_1.XmlCdata;
    } });
    var XmlComment_js_1 = require_XmlComment();
    Object.defineProperty(exports, "XmlComment", { enumerable: true, get: function() {
      return XmlComment_js_1.XmlComment;
    } });
    var XmlDeclaration_js_1 = require_XmlDeclaration();
    Object.defineProperty(exports, "XmlDeclaration", { enumerable: true, get: function() {
      return XmlDeclaration_js_1.XmlDeclaration;
    } });
    var XmlDocument_js_1 = require_XmlDocument();
    Object.defineProperty(exports, "XmlDocument", { enumerable: true, get: function() {
      return XmlDocument_js_1.XmlDocument;
    } });
    var XmlDocumentType_js_1 = require_XmlDocumentType();
    Object.defineProperty(exports, "XmlDocumentType", { enumerable: true, get: function() {
      return XmlDocumentType_js_1.XmlDocumentType;
    } });
    var XmlElement_js_1 = require_XmlElement();
    Object.defineProperty(exports, "XmlElement", { enumerable: true, get: function() {
      return XmlElement_js_1.XmlElement;
    } });
    var XmlError_js_1 = require_XmlError();
    Object.defineProperty(exports, "XmlError", { enumerable: true, get: function() {
      return XmlError_js_1.XmlError;
    } });
    var XmlNode_js_1 = require_XmlNode();
    Object.defineProperty(exports, "XmlNode", { enumerable: true, get: function() {
      return XmlNode_js_1.XmlNode;
    } });
    var XmlProcessingInstruction_js_1 = require_XmlProcessingInstruction();
    Object.defineProperty(exports, "XmlProcessingInstruction", { enumerable: true, get: function() {
      return XmlProcessingInstruction_js_1.XmlProcessingInstruction;
    } });
    var XmlText_js_1 = require_XmlText();
    Object.defineProperty(exports, "XmlText", { enumerable: true, get: function() {
      return XmlText_js_1.XmlText;
    } });
    function parseXml2(xml, options) {
      return new Parser_js_1.Parser(xml, options).document;
    }
  }
});

// dist/utils/meow-with-subcommands.js
async function meowWithSubcommands(subcommands, argv, name2) {
  const [commandName, ...commandArgv] = argv;
  if (commandName && subcommands[commandName]) {
    const command = subcommands[commandName];
    await command.run(commandArgv, import.meta, { parentName: name2 });
    return;
  }
  const visibleCommands = Object.entries(subcommands).filter(([, cmd]) => !cmd.hidden).map(([name3, cmd]) => `      ${name3.padEnd(30)} ${cmd.description}`).join("\n");
  console.log(`
    Usage
      $ ${name2} <command>

    Commands
${visibleCommands}

    Examples
      $ ${name2} --help
      $ ${name2} runJvmDirectDependencyAnalysis --help
  `);
  process.exit(commandName ? 2 : 0);
}

// dist/commands/jvm-reachability-analysis.js
import { readFile as readFile7, writeFile as writeFile2 } from "node:fs/promises";

// node_modules/.pnpm/web-tree-sitter@0.25.8/node_modules/web-tree-sitter/tree-sitter.js
var __defProp2 = Object.defineProperty;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var SIZE_OF_SHORT = 2;
var SIZE_OF_INT = 4;
var SIZE_OF_CURSOR = 4 * SIZE_OF_INT;
var SIZE_OF_NODE = 5 * SIZE_OF_INT;
var SIZE_OF_POINT = 2 * SIZE_OF_INT;
var SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT;
var ZERO_POINT = { row: 0, column: 0 };
var INTERNAL = Symbol("INTERNAL");
function assertInternal(x) {
  if (x !== INTERNAL) throw new Error("Illegal constructor");
}
__name(assertInternal, "assertInternal");
function isPoint(point) {
  return !!point && typeof point.row === "number" && typeof point.column === "number";
}
__name(isPoint, "isPoint");
function setModule(module22) {
  C = module22;
}
__name(setModule, "setModule");
var C;
var LookaheadIterator = class {
  static {
    __name(this, "LookaheadIterator");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  language;
  /** @internal */
  constructor(internal, address, language) {
    assertInternal(internal);
    this[0] = address;
    this.language = language;
  }
  /** Get the current symbol of the lookahead iterator. */
  get currentTypeId() {
    return C._ts_lookahead_iterator_current_symbol(this[0]);
  }
  /** Get the current symbol name of the lookahead iterator. */
  get currentType() {
    return this.language.types[this.currentTypeId] || "ERROR";
  }
  /** Delete the lookahead iterator, freeing its resources. */
  delete() {
    C._ts_lookahead_iterator_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Reset the lookahead iterator.
   *
   * This returns `true` if the language was set successfully and `false`
   * otherwise.
   */
  reset(language, stateId) {
    if (C._ts_lookahead_iterator_reset(this[0], language[0], stateId)) {
      this.language = language;
      return true;
    }
    return false;
  }
  /**
   * Reset the lookahead iterator to another state.
   *
   * This returns `true` if the iterator was reset to the given state and
   * `false` otherwise.
   */
  resetState(stateId) {
    return Boolean(C._ts_lookahead_iterator_reset_state(this[0], stateId));
  }
  /**
   * Returns an iterator that iterates over the symbols of the lookahead iterator.
   *
   * The iterator will yield the current symbol name as a string for each step
   * until there are no more symbols to iterate over.
   */
  [Symbol.iterator]() {
    return {
      next: /* @__PURE__ */ __name(() => {
        if (C._ts_lookahead_iterator_next(this[0])) {
          return { done: false, value: this.currentType };
        }
        return { done: true, value: "" };
      }, "next")
    };
  }
};
function getText(tree, startIndex, endIndex, startPosition) {
  const length = endIndex - startIndex;
  let result = tree.textCallback(startIndex, startPosition);
  if (result) {
    startIndex += result.length;
    while (startIndex < endIndex) {
      const string = tree.textCallback(startIndex, startPosition);
      if (string && string.length > 0) {
        startIndex += string.length;
        result += string;
      } else {
        break;
      }
    }
    if (startIndex > endIndex) {
      result = result.slice(0, length);
    }
  }
  return result ?? "";
}
__name(getText, "getText");
var Tree = class _Tree {
  static {
    __name(this, "Tree");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  textCallback;
  /** The language that was used to parse the syntax tree. */
  language;
  /** @internal */
  constructor(internal, address, language, textCallback) {
    assertInternal(internal);
    this[0] = address;
    this.language = language;
    this.textCallback = textCallback;
  }
  /** Create a shallow copy of the syntax tree. This is very fast. */
  copy() {
    const address = C._ts_tree_copy(this[0]);
    return new _Tree(INTERNAL, address, this.language, this.textCallback);
  }
  /** Delete the syntax tree, freeing its resources. */
  delete() {
    C._ts_tree_delete(this[0]);
    this[0] = 0;
  }
  /** Get the root node of the syntax tree. */
  get rootNode() {
    C._ts_tree_root_node_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Get the root node of the syntax tree, but with its position shifted
   * forward by the given offset.
   */
  rootNodeWithOffset(offsetBytes, offsetExtent) {
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, offsetBytes, "i32");
    marshalPoint(address + SIZE_OF_INT, offsetExtent);
    C._ts_tree_root_node_with_offset_wasm(this[0]);
    return unmarshalNode(this);
  }
  /**
   * Edit the syntax tree to keep it in sync with source code that has been
   * edited.
   *
   * You must describe the edit both in terms of byte offsets and in terms of
   * row/column coordinates.
   */
  edit(edit) {
    marshalEdit(edit);
    C._ts_tree_edit_wasm(this[0]);
  }
  /** Create a new {@link TreeCursor} starting from the root of the tree. */
  walk() {
    return this.rootNode.walk();
  }
  /**
   * Compare this old edited syntax tree to a new syntax tree representing
   * the same document, returning a sequence of ranges whose syntactic
   * structure has changed.
   *
   * For this to work correctly, this syntax tree must have been edited such
   * that its ranges match up to the new tree. Generally, you'll want to
   * call this method right after calling one of the [`Parser::parse`]
   * functions. Call it on the old tree that was passed to parse, and
   * pass the new tree that was returned from `parse`.
   */
  getChangedRanges(other) {
    if (!(other instanceof _Tree)) {
      throw new TypeError("Argument must be a Tree");
    }
    C._ts_tree_get_changed_ranges_wasm(this[0], other[0]);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer2);
    }
    return result;
  }
  /** Get the included ranges that were used to parse the syntax tree. */
  getIncludedRanges() {
    C._ts_tree_included_ranges_wasm(this[0]);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer2);
    }
    return result;
  }
};
var TreeCursor = class _TreeCursor {
  static {
    __name(this, "TreeCursor");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  [1] = 0;
  // Internal handle for WASM
  /** @internal */
  [2] = 0;
  // Internal handle for WASM
  /** @internal */
  [3] = 0;
  // Internal handle for WASM
  /** @internal */
  tree;
  /** @internal */
  constructor(internal, tree) {
    assertInternal(internal);
    this.tree = tree;
    unmarshalTreeCursor(this);
  }
  /** Creates a deep copy of the tree cursor. This allocates new memory. */
  copy() {
    const copy = new _TreeCursor(INTERNAL, this.tree);
    C._ts_tree_cursor_copy_wasm(this.tree[0]);
    unmarshalTreeCursor(copy);
    return copy;
  }
  /** Delete the tree cursor, freeing its resources. */
  delete() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_delete_wasm(this.tree[0]);
    this[0] = this[1] = this[2] = 0;
  }
  /** Get the tree cursor's current {@link Node}. */
  get currentNode() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_current_node_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the numerical field id of this tree cursor's current node.
   *
   * See also {@link TreeCursor#currentFieldName}.
   */
  get currentFieldId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
  }
  /** Get the field name of this tree cursor's current node. */
  get currentFieldName() {
    return this.tree.language.fields[this.currentFieldId];
  }
  /**
   * Get the depth of the cursor's current node relative to the original
   * node that the cursor was constructed with.
   */
  get currentDepth() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_depth_wasm(this.tree[0]);
  }
  /**
   * Get the index of the cursor's current node out of all of the
   * descendants of the original node that the cursor was constructed with.
   */
  get currentDescendantIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0]);
  }
  /** Get the type of the cursor's current node. */
  get nodeType() {
    return this.tree.language.types[this.nodeTypeId] || "ERROR";
  }
  /** Get the type id of the cursor's current node. */
  get nodeTypeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
  }
  /** Get the state id of the cursor's current node. */
  get nodeStateId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0]);
  }
  /** Get the id of the cursor's current node. */
  get nodeId() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
  }
  /**
   * Check if the cursor's current node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get nodeIsNamed() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if the cursor's current node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get nodeIsMissing() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Get the string content of the cursor's current node. */
  get nodeText() {
    marshalTreeCursor(this);
    const startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]);
    const endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    const startPosition = unmarshalPoint(TRANSFER_BUFFER);
    return getText(this.tree, startIndex, endIndex, startPosition);
  }
  /** Get the start position of the cursor's current node. */
  get startPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_start_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the end position of the cursor's current node. */
  get endPosition() {
    marshalTreeCursor(this);
    C._ts_tree_cursor_end_position_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the start index of the cursor's current node. */
  get startIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_start_index_wasm(this.tree[0]);
  }
  /** Get the end index of the cursor's current node. */
  get endIndex() {
    marshalTreeCursor(this);
    return C._ts_tree_cursor_end_index_wasm(this.tree[0]);
  }
  /**
   * Move this cursor to the first child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   */
  gotoFirstChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the last child of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there were no children.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoFirstChild} because it needs to
   * iterate through all the children to compute the child's position.
   */
  gotoLastChild() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the parent of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no parent node (the cursor was already on the
   * root node).
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoParent() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the next sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no next sibling node.
   *
   * Note that the node the cursor was constructed with is considered the root
   * of the cursor, and the cursor cannot walk outside this node.
   */
  gotoNextSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the previous sibling of its current node.
   *
   * This returns `true` if the cursor successfully moved, and returns
   * `false` if there was no previous sibling node.
   *
   * Note that this function may be slower than
   * {@link TreeCursor#gotoNextSibling} due to how node
   * positions are stored. In the worst case, this will need to iterate
   * through all the children up to the previous sibling node to recalculate
   * its position. Also note that the node the cursor was constructed with is
   * considered the root of the cursor, and the cursor cannot walk outside this node.
   */
  gotoPreviousSibling() {
    marshalTreeCursor(this);
    const result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move the cursor to the node that is the nth descendant of
   * the original node that the cursor was constructed with, where
   * zero represents the original node itself.
   */
  gotoDescendant(goalDescendantIndex) {
    marshalTreeCursor(this);
    C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex);
    unmarshalTreeCursor(this);
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns `true` if the cursor successfully moved to a child node, and returns
   * `false` if no such child was found.
   */
  gotoFirstChildForIndex(goalIndex) {
    marshalTreeCursor(this);
    C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, "i32");
    const result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Move this cursor to the first child of its current node that contains or
   * starts after the given byte offset.
   *
   * This returns the index of the child node if one was found, and returns
   * `null` if no such child was found.
   */
  gotoFirstChildForPosition(goalPosition) {
    marshalTreeCursor(this);
    marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition);
    const result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
    return result === 1;
  }
  /**
   * Re-initialize this tree cursor to start at the original node that the
   * cursor was constructed with.
   */
  reset(node) {
    marshalNode(node);
    marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE);
    C._ts_tree_cursor_reset_wasm(this.tree[0]);
    unmarshalTreeCursor(this);
  }
  /**
   * Re-initialize a tree cursor to the same position as another cursor.
   *
   * Unlike {@link TreeCursor#reset}, this will not lose parent
   * information and allows reusing already created cursors.
   */
  resetTo(cursor) {
    marshalTreeCursor(this, TRANSFER_BUFFER);
    marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR);
    C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]);
    unmarshalTreeCursor(this);
  }
};
var Node = class {
  static {
    __name(this, "Node");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  _children;
  /** @internal */
  _namedChildren;
  /** @internal */
  constructor(internal, {
    id,
    tree,
    startIndex,
    startPosition,
    other
  }) {
    assertInternal(internal);
    this[0] = other;
    this.id = id;
    this.tree = tree;
    this.startIndex = startIndex;
    this.startPosition = startPosition;
  }
  /**
   * The numeric id for this node that is unique.
   *
   * Within a given syntax tree, no two nodes have the same id. However:
   *
   * * If a new tree is created based on an older tree, and a node from the old tree is reused in
   *   the process, then that node will have the same id in both trees.
   *
   * * A node not marked as having changes does not guarantee it was reused.
   *
   * * If a node is marked as having changed in the old tree, it will not be reused.
   */
  id;
  /** The byte index where this node starts. */
  startIndex;
  /** The position where this node starts. */
  startPosition;
  /** The tree that this node belongs to. */
  tree;
  /** Get this node's type as a numerical id. */
  get typeId() {
    marshalNode(this);
    return C._ts_node_symbol_wasm(this.tree[0]);
  }
  /**
   * Get the node's type as a numerical id as it appears in the grammar,
   * ignoring aliases.
   */
  get grammarId() {
    marshalNode(this);
    return C._ts_node_grammar_symbol_wasm(this.tree[0]);
  }
  /** Get this node's type as a string. */
  get type() {
    return this.tree.language.types[this.typeId] || "ERROR";
  }
  /**
   * Get this node's symbol name as it appears in the grammar, ignoring
   * aliases as a string.
   */
  get grammarType() {
    return this.tree.language.types[this.grammarId] || "ERROR";
  }
  /**
   * Check if this node is *named*.
   *
   * Named nodes correspond to named rules in the grammar, whereas
   * *anonymous* nodes correspond to string literals in the grammar.
   */
  get isNamed() {
    marshalNode(this);
    return C._ts_node_is_named_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *extra*.
   *
   * Extra nodes represent things like comments, which are not required
   * by the grammar, but can appear anywhere.
   */
  get isExtra() {
    marshalNode(this);
    return C._ts_node_is_extra_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error.
   *
   * Syntax errors represent parts of the code that could not be incorporated
   * into a valid syntax tree.
   */
  get isError() {
    marshalNode(this);
    return C._ts_node_is_error_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node is *missing*.
   *
   * Missing nodes are inserted by the parser in order to recover from
   * certain kinds of syntax errors.
   */
  get isMissing() {
    marshalNode(this);
    return C._ts_node_is_missing_wasm(this.tree[0]) === 1;
  }
  /** Check if this node has been edited. */
  get hasChanges() {
    marshalNode(this);
    return C._ts_node_has_changes_wasm(this.tree[0]) === 1;
  }
  /**
   * Check if this node represents a syntax error or contains any syntax
   * errors anywhere within it.
   */
  get hasError() {
    marshalNode(this);
    return C._ts_node_has_error_wasm(this.tree[0]) === 1;
  }
  /** Get the byte index where this node ends. */
  get endIndex() {
    marshalNode(this);
    return C._ts_node_end_index_wasm(this.tree[0]);
  }
  /** Get the position where this node ends. */
  get endPosition() {
    marshalNode(this);
    C._ts_node_end_point_wasm(this.tree[0]);
    return unmarshalPoint(TRANSFER_BUFFER);
  }
  /** Get the string content of this node. */
  get text() {
    return getText(this.tree, this.startIndex, this.endIndex, this.startPosition);
  }
  /** Get this node's parse state. */
  get parseState() {
    marshalNode(this);
    return C._ts_node_parse_state_wasm(this.tree[0]);
  }
  /** Get the parse state after this node. */
  get nextParseState() {
    marshalNode(this);
    return C._ts_node_next_parse_state_wasm(this.tree[0]);
  }
  /** Check if this node is equal to another node. */
  equals(other) {
    return this.tree === other.tree && this.id === other.id;
  }
  /**
   * Get the node's child at the given index, where zero represents the first child.
   *
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#children} instead.
   */
  child(index) {
    marshalNode(this);
    C._ts_node_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's *named* child at the given index.
   *
   * See also {@link Node#isNamed}.
   * This method is fairly fast, but its cost is technically log(n), so if
   * you might be iterating over a long list of children, you should use
   * {@link Node#namedChildren} instead.
   */
  namedChild(index) {
    marshalNode(this);
    C._ts_node_named_child_wasm(this.tree[0], index);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's child with the given numerical field id.
   *
   * See also {@link Node#childForFieldName}. You can
   * convert a field name to an id using {@link Language#fieldIdForName}.
   */
  childForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the first child with the given field name.
   *
   * If multiple children may have the same field name, access them using
   * {@link Node#childrenForFieldName}.
   */
  childForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1) return this.childForFieldId(fieldId);
    return null;
  }
  /** Get the field name of this node's child at the given index. */
  fieldNameForChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /** Get the field name of this node's named child at the given index. */
  fieldNameForNamedChild(index) {
    marshalNode(this);
    const address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index);
    if (!address) return null;
    return C.AsciiToString(address);
  }
  /**
   * Get an array of this node's children with a given field name.
   *
   * See also {@link Node#children}.
   */
  childrenForFieldName(fieldName) {
    const fieldId = this.tree.language.fields.indexOf(fieldName);
    if (fieldId !== -1 && fieldId !== 0) return this.childrenForFieldId(fieldId);
    return [];
  }
  /**
    * Get an array of this node's children with a given field id.
    *
    * See also {@link Node#childrenForFieldName}.
    */
  childrenForFieldId(fieldId) {
    marshalNode(this);
    C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
      C._free(buffer2);
    }
    return result;
  }
  /** Get the node's first child that contains or starts after the given byte offset. */
  firstChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's first named child that contains or starts after the given byte offset. */
  firstNamedChildForIndex(index) {
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, index, "i32");
    C._ts_node_first_named_child_for_byte_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's number of children. */
  get childCount() {
    marshalNode(this);
    return C._ts_node_child_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's number of *named* children.
   *
   * See also {@link Node#isNamed}.
   */
  get namedChildCount() {
    marshalNode(this);
    return C._ts_node_named_child_count_wasm(this.tree[0]);
  }
  /** Get this node's first child. */
  get firstChild() {
    return this.child(0);
  }
  /**
   * Get this node's first named child.
   *
   * See also {@link Node#isNamed}.
   */
  get firstNamedChild() {
    return this.namedChild(0);
  }
  /** Get this node's last child. */
  get lastChild() {
    return this.child(this.childCount - 1);
  }
  /**
   * Get this node's last named child.
   *
   * See also {@link Node#isNamed}.
   */
  get lastNamedChild() {
    return this.namedChild(this.namedChildCount - 1);
  }
  /**
   * Iterate over this node's children.
   *
   * If you're walking the tree recursively, you may want to use the
   * {@link TreeCursor} APIs directly instead.
   */
  get children() {
    if (!this._children) {
      marshalNode(this);
      C._ts_node_children_wasm(this.tree[0]);
      const count = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._children = new Array(count);
      if (count > 0) {
        let address = buffer2;
        for (let i22 = 0; i22 < count; i22++) {
          this._children[i22] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer2);
      }
    }
    return this._children;
  }
  /**
   * Iterate over this node's named children.
   *
   * See also {@link Node#children}.
   */
  get namedChildren() {
    if (!this._namedChildren) {
      marshalNode(this);
      C._ts_node_named_children_wasm(this.tree[0]);
      const count = C.getValue(TRANSFER_BUFFER, "i32");
      const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      this._namedChildren = new Array(count);
      if (count > 0) {
        let address = buffer2;
        for (let i22 = 0; i22 < count; i22++) {
          this._namedChildren[i22] = unmarshalNode(this.tree, address);
          address += SIZE_OF_NODE;
        }
        C._free(buffer2);
      }
    }
    return this._namedChildren;
  }
  /**
   * Get the descendants of this node that are the given type, or in the given types array.
   *
   * The types array should contain node type strings, which can be retrieved from {@link Language#types}.
   *
   * Additionally, a `startPosition` and `endPosition` can be passed in to restrict the search to a byte range.
   */
  descendantsOfType(types, startPosition = ZERO_POINT, endPosition = ZERO_POINT) {
    if (!Array.isArray(types)) types = [types];
    const symbols = [];
    const typesBySymbol = this.tree.language.types;
    for (const node_type of types) {
      if (node_type == "ERROR") {
        symbols.push(65535);
      }
    }
    for (let i22 = 0, n3 = typesBySymbol.length; i22 < n3; i22++) {
      if (types.includes(typesBySymbol[i22])) {
        symbols.push(i22);
      }
    }
    const symbolsAddress = C._malloc(SIZE_OF_INT * symbols.length);
    for (let i22 = 0, n3 = symbols.length; i22 < n3; i22++) {
      C.setValue(symbolsAddress + i22 * SIZE_OF_INT, symbols[i22], "i32");
    }
    marshalNode(this);
    C._ts_node_descendants_of_type_wasm(
      this.tree[0],
      symbolsAddress,
      symbols.length,
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column
    );
    const descendantCount = C.getValue(TRANSFER_BUFFER, "i32");
    const descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(descendantCount);
    if (descendantCount > 0) {
      let address = descendantAddress;
      for (let i22 = 0; i22 < descendantCount; i22++) {
        result[i22] = unmarshalNode(this.tree, address);
        address += SIZE_OF_NODE;
      }
    }
    C._free(descendantAddress);
    C._free(symbolsAddress);
    return result;
  }
  /** Get this node's next sibling. */
  get nextSibling() {
    marshalNode(this);
    C._ts_node_next_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get this node's previous sibling. */
  get previousSibling() {
    marshalNode(this);
    C._ts_node_prev_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's next *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get nextNamedSibling() {
    marshalNode(this);
    C._ts_node_next_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get this node's previous *named* sibling.
   *
   * See also {@link Node#isNamed}.
   */
  get previousNamedSibling() {
    marshalNode(this);
    C._ts_node_prev_named_sibling_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the node's number of descendants, including one for the node itself. */
  get descendantCount() {
    marshalNode(this);
    return C._ts_node_descendant_count_wasm(this.tree[0]);
  }
  /**
   * Get this node's immediate parent.
   * Prefer {@link Node#childWithDescendant} for iterating over this node's ancestors.
   */
  get parent() {
    marshalNode(this);
    C._ts_node_parent_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Get the node that contains `descendant`.
   *
   * Note that this can return `descendant` itself.
   */
  childWithDescendant(descendant) {
    marshalNode(this);
    marshalNode(descendant, 1);
    C._ts_node_child_with_descendant_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given byte range. */
  descendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given byte range. */
  namedDescendantForIndex(start2, end = start2) {
    if (typeof start2 !== "number" || typeof end !== "number") {
      throw new Error("Arguments must be numbers");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    C.setValue(address, start2, "i32");
    C.setValue(address + SIZE_OF_INT, end, "i32");
    C._ts_node_named_descendant_for_index_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest node within this node that spans the given point range. */
  descendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /** Get the smallest named node within this node that spans the given point range. */
  namedDescendantForPosition(start2, end = start2) {
    if (!isPoint(start2) || !isPoint(end)) {
      throw new Error("Arguments must be {row, column} objects");
    }
    marshalNode(this);
    const address = TRANSFER_BUFFER + SIZE_OF_NODE;
    marshalPoint(address, start2);
    marshalPoint(address + SIZE_OF_POINT, end);
    C._ts_node_named_descendant_for_position_wasm(this.tree[0]);
    return unmarshalNode(this.tree);
  }
  /**
   * Create a new {@link TreeCursor} starting from this node.
   *
   * Note that the given node is considered the root of the cursor,
   * and the cursor cannot walk outside this node.
   */
  walk() {
    marshalNode(this);
    C._ts_tree_cursor_new_wasm(this.tree[0]);
    return new TreeCursor(INTERNAL, this.tree);
  }
  /**
   * Edit this node to keep it in-sync with source code that has been edited.
   *
   * This function is only rarely needed. When you edit a syntax tree with
   * the {@link Tree#edit} method, all of the nodes that you retrieve from
   * the tree afterward will already reflect the edit. You only need to
   * use {@link Node#edit} when you have a specific {@link Node} instance that
   * you want to keep and continue to use after an edit.
   */
  edit(edit) {
    if (this.startIndex >= edit.oldEndIndex) {
      this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex);
      let subbedPointRow;
      let subbedPointColumn;
      if (this.startPosition.row > edit.oldEndPosition.row) {
        subbedPointRow = this.startPosition.row - edit.oldEndPosition.row;
        subbedPointColumn = this.startPosition.column;
      } else {
        subbedPointRow = 0;
        subbedPointColumn = this.startPosition.column;
        if (this.startPosition.column >= edit.oldEndPosition.column) {
          subbedPointColumn = this.startPosition.column - edit.oldEndPosition.column;
        }
      }
      if (subbedPointRow > 0) {
        this.startPosition.row += subbedPointRow;
        this.startPosition.column = subbedPointColumn;
      } else {
        this.startPosition.column += subbedPointColumn;
      }
    } else if (this.startIndex > edit.startIndex) {
      this.startIndex = edit.newEndIndex;
      this.startPosition.row = edit.newEndPosition.row;
      this.startPosition.column = edit.newEndPosition.column;
    }
  }
  /** Get the S-expression representation of this node. */
  toString() {
    marshalNode(this);
    const address = C._ts_node_to_string_wasm(this.tree[0]);
    const result = C.AsciiToString(address);
    C._free(address);
    return result;
  }
};
function unmarshalCaptures(query, tree, address, patternIndex, result) {
  for (let i22 = 0, n3 = result.length; i22 < n3; i22++) {
    const captureIndex = C.getValue(address, "i32");
    address += SIZE_OF_INT;
    const node = unmarshalNode(tree, address);
    address += SIZE_OF_NODE;
    result[i22] = { patternIndex, name: query.captureNames[captureIndex], node };
  }
  return address;
}
__name(unmarshalCaptures, "unmarshalCaptures");
function marshalNode(node, index = 0) {
  let address = TRANSFER_BUFFER + index * SIZE_OF_NODE;
  C.setValue(address, node.id, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.row, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node.startPosition.column, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, node[0], "i32");
}
__name(marshalNode, "marshalNode");
function unmarshalNode(tree, address = TRANSFER_BUFFER) {
  const id = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  if (id === 0) return null;
  const index = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const row = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const column = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  const other = C.getValue(address, "i32");
  const result = new Node(INTERNAL, {
    id,
    tree,
    startIndex: index,
    startPosition: { row, column },
    other
  });
  return result;
}
__name(unmarshalNode, "unmarshalNode");
function marshalTreeCursor(cursor, address = TRANSFER_BUFFER) {
  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], "i32");
  C.setValue(address + 1 * SIZE_OF_INT, cursor[1], "i32");
  C.setValue(address + 2 * SIZE_OF_INT, cursor[2], "i32");
  C.setValue(address + 3 * SIZE_OF_INT, cursor[3], "i32");
}
__name(marshalTreeCursor, "marshalTreeCursor");
function unmarshalTreeCursor(cursor) {
  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32");
  cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32");
  cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
  cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, "i32");
}
__name(unmarshalTreeCursor, "unmarshalTreeCursor");
function marshalPoint(address, point) {
  C.setValue(address, point.row, "i32");
  C.setValue(address + SIZE_OF_INT, point.column, "i32");
}
__name(marshalPoint, "marshalPoint");
function unmarshalPoint(address) {
  const result = {
    row: C.getValue(address, "i32") >>> 0,
    column: C.getValue(address + SIZE_OF_INT, "i32") >>> 0
  };
  return result;
}
__name(unmarshalPoint, "unmarshalPoint");
function marshalRange(address, range) {
  marshalPoint(address, range.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, range.endPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, range.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, range.endIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalRange, "marshalRange");
function unmarshalRange(address) {
  const result = {};
  result.startPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.endPosition = unmarshalPoint(address);
  address += SIZE_OF_POINT;
  result.startIndex = C.getValue(address, "i32") >>> 0;
  address += SIZE_OF_INT;
  result.endIndex = C.getValue(address, "i32") >>> 0;
  return result;
}
__name(unmarshalRange, "unmarshalRange");
function marshalEdit(edit, address = TRANSFER_BUFFER) {
  marshalPoint(address, edit.startPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.oldEndPosition);
  address += SIZE_OF_POINT;
  marshalPoint(address, edit.newEndPosition);
  address += SIZE_OF_POINT;
  C.setValue(address, edit.startIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.oldEndIndex, "i32");
  address += SIZE_OF_INT;
  C.setValue(address, edit.newEndIndex, "i32");
  address += SIZE_OF_INT;
}
__name(marshalEdit, "marshalEdit");
function unmarshalLanguageMetadata(address) {
  const result = {};
  result.major_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.minor_version = C.getValue(address, "i32");
  address += SIZE_OF_INT;
  result.field_count = C.getValue(address, "i32");
  return result;
}
__name(unmarshalLanguageMetadata, "unmarshalLanguageMetadata");
var PREDICATE_STEP_TYPE_CAPTURE = 1;
var PREDICATE_STEP_TYPE_STRING = 2;
var QUERY_WORD_REGEX = /[\w-]+/g;
var CaptureQuantifier = {
  Zero: 0,
  ZeroOrOne: 1,
  ZeroOrMore: 2,
  One: 3,
  OneOrMore: 4
};
var isCaptureStep = /* @__PURE__ */ __name((step) => step.type === "capture", "isCaptureStep");
var isStringStep = /* @__PURE__ */ __name((step) => step.type === "string", "isStringStep");
var QueryErrorKind = {
  Syntax: 1,
  NodeName: 2,
  FieldName: 3,
  CaptureName: 4,
  PatternStructure: 5
};
var QueryError = class _QueryError extends Error {
  constructor(kind, info2, index, length) {
    super(_QueryError.formatMessage(kind, info2));
    this.kind = kind;
    this.info = info2;
    this.index = index;
    this.length = length;
    this.name = "QueryError";
  }
  static {
    __name(this, "QueryError");
  }
  /** Formats an error message based on the error kind and info */
  static formatMessage(kind, info2) {
    switch (kind) {
      case QueryErrorKind.NodeName:
        return `Bad node name '${info2.word}'`;
      case QueryErrorKind.FieldName:
        return `Bad field name '${info2.word}'`;
      case QueryErrorKind.CaptureName:
        return `Bad capture name @${info2.word}`;
      case QueryErrorKind.PatternStructure:
        return `Bad pattern structure at offset ${info2.suffix}`;
      case QueryErrorKind.Syntax:
        return `Bad syntax at offset ${info2.suffix}`;
    }
  }
};
function parseAnyPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}`
    );
  }
  if (!isCaptureStep(steps[1])) {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}"`
    );
  }
  const isPositive = operator === "eq?" || operator === "any-eq?";
  const matchAll = !operator.startsWith("any-");
  if (isCaptureStep(steps[2])) {
    const captureName1 = steps[1].name;
    const captureName2 = steps[2].name;
    textPredicates[index].push((captures) => {
      const nodes1 = [];
      const nodes2 = [];
      for (const c of captures) {
        if (c.name === captureName1) nodes1.push(c.node);
        if (c.name === captureName2) nodes2.push(c.node);
      }
      const compare = /* @__PURE__ */ __name((n1, n22, positive) => {
        return positive ? n1.text === n22.text : n1.text !== n22.text;
      }, "compare");
      return matchAll ? nodes1.every((n1) => nodes2.some((n22) => compare(n1, n22, isPositive))) : nodes1.some((n1) => nodes2.some((n22) => compare(n1, n22, isPositive)));
    });
  } else {
    const captureName = steps[1].name;
    const stringValue = steps[2].value;
    const matches = /* @__PURE__ */ __name((n3) => n3.text === stringValue, "matches");
    const doesNotMatch = /* @__PURE__ */ __name((n3) => n3.text !== stringValue, "doesNotMatch");
    textPredicates[index].push((captures) => {
      const nodes = [];
      for (const c of captures) {
        if (c.name === captureName) nodes.push(c.node);
      }
      const test = isPositive ? matches : doesNotMatch;
      return matchAll ? nodes.every(test) : nodes.some(test);
    });
  }
}
__name(parseAnyPredicate, "parseAnyPredicate");
function parseMatchPredicate(steps, index, operator, textPredicates) {
  if (steps.length !== 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  if (steps[2].type !== "string") {
    throw new Error(
      `Second argument of \`#${operator}\` predicate must be a string. Got @${steps[2].name}.`
    );
  }
  const isPositive = operator === "match?" || operator === "any-match?";
  const matchAll = !operator.startsWith("any-");
  const captureName = steps[1].name;
  const regex = new RegExp(steps[2].value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    const test = /* @__PURE__ */ __name((text, positive) => {
      return positive ? regex.test(text) : !regex.test(text);
    }, "test");
    if (nodes.length === 0) return !isPositive;
    return matchAll ? nodes.every((text) => test(text, isPositive)) : nodes.some((text) => test(text, isPositive));
  });
}
__name(parseMatchPredicate, "parseMatchPredicate");
function parseAnyOfPredicate(steps, index, operator, textPredicates) {
  if (steps.length < 2) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected at least 1. Got ${steps.length - 1}.`
    );
  }
  if (steps[1].type !== "capture") {
    throw new Error(
      `First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`
    );
  }
  const isPositive = operator === "any-of?";
  const captureName = steps[1].name;
  const stringSteps = steps.slice(2);
  if (!stringSteps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const values = stringSteps.map((s) => s.value);
  textPredicates[index].push((captures) => {
    const nodes = [];
    for (const c of captures) {
      if (c.name === captureName) nodes.push(c.node.text);
    }
    if (nodes.length === 0) return !isPositive;
    return nodes.every((text) => values.includes(text)) === isPositive;
  });
}
__name(parseAnyOfPredicate, "parseAnyOfPredicate");
function parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`
    );
  }
  if (!steps.every(isStringStep)) {
    throw new Error(
      `Arguments to \`#${operator}\` predicate must be strings.".`
    );
  }
  const properties = operator === "is?" ? assertedProperties : refutedProperties;
  if (!properties[index]) properties[index] = {};
  properties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseIsPredicate, "parseIsPredicate");
function parseSetDirective(steps, index, setProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`);
  }
  if (!steps.every(isStringStep)) {
    throw new Error(`Arguments to \`#set!\` predicate must be strings.".`);
  }
  if (!setProperties[index]) setProperties[index] = {};
  setProperties[index][steps[1].value] = steps[2]?.value ?? null;
}
__name(parseSetDirective, "parseSetDirective");
function parsePattern(index, stepType, stepValueId, captureNames, stringValues, steps, textPredicates, predicates, setProperties, assertedProperties, refutedProperties) {
  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {
    const name2 = captureNames[stepValueId];
    steps.push({ type: "capture", name: name2 });
  } else if (stepType === PREDICATE_STEP_TYPE_STRING) {
    steps.push({ type: "string", value: stringValues[stepValueId] });
  } else if (steps.length > 0) {
    if (steps[0].type !== "string") {
      throw new Error("Predicates must begin with a literal value");
    }
    const operator = steps[0].value;
    switch (operator) {
      case "any-not-eq?":
      case "not-eq?":
      case "any-eq?":
      case "eq?":
        parseAnyPredicate(steps, index, operator, textPredicates);
        break;
      case "any-not-match?":
      case "not-match?":
      case "any-match?":
      case "match?":
        parseMatchPredicate(steps, index, operator, textPredicates);
        break;
      case "not-any-of?":
      case "any-of?":
        parseAnyOfPredicate(steps, index, operator, textPredicates);
        break;
      case "is?":
      case "is-not?":
        parseIsPredicate(steps, index, operator, assertedProperties, refutedProperties);
        break;
      case "set!":
        parseSetDirective(steps, index, setProperties);
        break;
      default:
        predicates[index].push({ operator, operands: steps.slice(1) });
    }
    steps.length = 0;
  }
}
__name(parsePattern, "parsePattern");
var Query = class {
  static {
    __name(this, "Query");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  exceededMatchLimit;
  /** @internal */
  textPredicates;
  /** The names of the captures used in the query. */
  captureNames;
  /** The quantifiers of the captures used in the query. */
  captureQuantifiers;
  /**
   * The other user-defined predicates associated with the given index.
   *
   * This includes predicates with operators other than:
   * - `match?`
   * - `eq?` and `not-eq?`
   * - `any-of?` and `not-any-of?`
   * - `is?` and `is-not?`
   * - `set!`
   */
  predicates;
  /** The properties for predicates with the operator `set!`. */
  setProperties;
  /** The properties for predicates with the operator `is?`. */
  assertedProperties;
  /** The properties for predicates with the operator `is-not?`. */
  refutedProperties;
  /** The maximum number of in-progress matches for this cursor. */
  matchLimit;
  /**
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  constructor(language, source) {
    const sourceLength = C.lengthBytesUTF8(source);
    const sourceAddress = C._malloc(sourceLength + 1);
    C.stringToUTF8(source, sourceAddress, sourceLength + 1);
    const address = C._ts_query_new(
      language[0],
      sourceAddress,
      sourceLength,
      TRANSFER_BUFFER,
      TRANSFER_BUFFER + SIZE_OF_INT
    );
    if (!address) {
      const errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
      const errorByte = C.getValue(TRANSFER_BUFFER, "i32");
      const errorIndex = C.UTF8ToString(sourceAddress, errorByte).length;
      const suffix = source.slice(errorIndex, errorIndex + 100).split("\n")[0];
      const word = suffix.match(QUERY_WORD_REGEX)?.[0] ?? "";
      C._free(sourceAddress);
      switch (errorId) {
        case QueryErrorKind.Syntax:
          throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
        case QueryErrorKind.NodeName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.FieldName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.CaptureName:
          throw new QueryError(errorId, { word }, errorIndex, word.length);
        case QueryErrorKind.PatternStructure:
          throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix}'...` }, errorIndex, 0);
      }
    }
    const stringCount = C._ts_query_string_count(address);
    const captureCount = C._ts_query_capture_count(address);
    const patternCount = C._ts_query_pattern_count(address);
    const captureNames = new Array(captureCount);
    const captureQuantifiers = new Array(patternCount);
    const stringValues = new Array(stringCount);
    for (let i22 = 0; i22 < captureCount; i22++) {
      const nameAddress = C._ts_query_capture_name_for_id(
        address,
        i22,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      captureNames[i22] = C.UTF8ToString(nameAddress, nameLength);
    }
    for (let i22 = 0; i22 < patternCount; i22++) {
      const captureQuantifiersArray = new Array(captureCount);
      for (let j = 0; j < captureCount; j++) {
        const quantifier = C._ts_query_capture_quantifier_for_id(address, i22, j);
        captureQuantifiersArray[j] = quantifier;
      }
      captureQuantifiers[i22] = captureQuantifiersArray;
    }
    for (let i22 = 0; i22 < stringCount; i22++) {
      const valueAddress = C._ts_query_string_value_for_id(
        address,
        i22,
        TRANSFER_BUFFER
      );
      const nameLength = C.getValue(TRANSFER_BUFFER, "i32");
      stringValues[i22] = C.UTF8ToString(valueAddress, nameLength);
    }
    const setProperties = new Array(patternCount);
    const assertedProperties = new Array(patternCount);
    const refutedProperties = new Array(patternCount);
    const predicates = new Array(patternCount);
    const textPredicates = new Array(patternCount);
    for (let i22 = 0; i22 < patternCount; i22++) {
      const predicatesAddress = C._ts_query_predicates_for_pattern(address, i22, TRANSFER_BUFFER);
      const stepCount = C.getValue(TRANSFER_BUFFER, "i32");
      predicates[i22] = [];
      textPredicates[i22] = [];
      const steps = new Array();
      let stepAddress = predicatesAddress;
      for (let j = 0; j < stepCount; j++) {
        const stepType = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        const stepValueId = C.getValue(stepAddress, "i32");
        stepAddress += SIZE_OF_INT;
        parsePattern(
          i22,
          stepType,
          stepValueId,
          captureNames,
          stringValues,
          steps,
          textPredicates,
          predicates,
          setProperties,
          assertedProperties,
          refutedProperties
        );
      }
      Object.freeze(textPredicates[i22]);
      Object.freeze(predicates[i22]);
      Object.freeze(setProperties[i22]);
      Object.freeze(assertedProperties[i22]);
      Object.freeze(refutedProperties[i22]);
    }
    C._free(sourceAddress);
    this[0] = address;
    this.captureNames = captureNames;
    this.captureQuantifiers = captureQuantifiers;
    this.textPredicates = textPredicates;
    this.predicates = predicates;
    this.setProperties = setProperties;
    this.assertedProperties = assertedProperties;
    this.refutedProperties = refutedProperties;
    this.exceededMatchLimit = false;
  }
  /** Delete the query, freeing its resources. */
  delete() {
    C._ts_query_delete(this[0]);
    this[0] = 0;
  }
  /**
   * Iterate over all of the matches in the order that they were found.
   *
   * Each match contains the index of the pattern that matched, and a list of
   * captures. Because multiple patterns can match the same set of nodes,
   * one match may contain captures that appear *before* some of the
   * captures from a previous match.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  matches(node, options = {}) {
    const startPosition = options.startPosition ?? ZERO_POINT;
    const endPosition = options.endPosition ?? ZERO_POINT;
    const startIndex = options.startIndex ?? 0;
    const endIndex = options.endIndex ?? 0;
    const matchLimit = options.matchLimit ?? 4294967295;
    const maxStartDepth = options.maxStartDepth ?? 4294967295;
    const timeoutMicros = options.timeoutMicros ?? 0;
    const progressCallback = options.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_matches_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const rawCount = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array(rawCount);
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    let filteredCount = 0;
    let address = startAddress;
    for (let i22 = 0; i22 < rawCount; i22++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captures = new Array(captureCount);
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        result[filteredCount] = { pattern: patternIndex, patternIndex, captures };
        const setProperties = this.setProperties[patternIndex];
        result[filteredCount].setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        result[filteredCount].assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        result[filteredCount].refutedProperties = refutedProperties;
        filteredCount++;
      }
    }
    result.length = filteredCount;
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /**
   * Iterate over all of the individual captures in the order that they
   * appear.
   *
   * This is useful if you don't care about which pattern matched, and just
   * want a single, ordered sequence of captures.
   *
   * @param {Node} node - The node to execute the query on.
   *
   * @param {QueryOptions} options - Options for query execution.
   */
  captures(node, options = {}) {
    const startPosition = options.startPosition ?? ZERO_POINT;
    const endPosition = options.endPosition ?? ZERO_POINT;
    const startIndex = options.startIndex ?? 0;
    const endIndex = options.endIndex ?? 0;
    const matchLimit = options.matchLimit ?? 4294967295;
    const maxStartDepth = options.maxStartDepth ?? 4294967295;
    const timeoutMicros = options.timeoutMicros ?? 0;
    const progressCallback = options.progressCallback;
    if (typeof matchLimit !== "number") {
      throw new Error("Arguments must be numbers");
    }
    this.matchLimit = matchLimit;
    if (endIndex !== 0 && startIndex > endIndex) {
      throw new Error("`startIndex` cannot be greater than `endIndex`");
    }
    if (endPosition !== ZERO_POINT && (startPosition.row > endPosition.row || startPosition.row === endPosition.row && startPosition.column > endPosition.column)) {
      throw new Error("`startPosition` cannot be greater than `endPosition`");
    }
    if (progressCallback) {
      C.currentQueryProgressCallback = progressCallback;
    }
    marshalNode(node);
    C._ts_query_captures_wasm(
      this[0],
      node.tree[0],
      startPosition.row,
      startPosition.column,
      endPosition.row,
      endPosition.column,
      startIndex,
      endIndex,
      matchLimit,
      maxStartDepth,
      timeoutMicros
    );
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
    const result = new Array();
    this.exceededMatchLimit = Boolean(didExceedMatchLimit);
    const captures = new Array();
    let address = startAddress;
    for (let i22 = 0; i22 < count; i22++) {
      const patternIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureCount = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      const captureIndex = C.getValue(address, "i32");
      address += SIZE_OF_INT;
      captures.length = captureCount;
      address = unmarshalCaptures(this, node.tree, address, patternIndex, captures);
      if (this.textPredicates[patternIndex].every((p) => p(captures))) {
        const capture = captures[captureIndex];
        const setProperties = this.setProperties[patternIndex];
        capture.setProperties = setProperties;
        const assertedProperties = this.assertedProperties[patternIndex];
        capture.assertedProperties = assertedProperties;
        const refutedProperties = this.refutedProperties[patternIndex];
        capture.refutedProperties = refutedProperties;
        result.push(capture);
      }
    }
    C._free(startAddress);
    C.currentQueryProgressCallback = null;
    return result;
  }
  /** Get the predicates for a given pattern. */
  predicatesForPattern(patternIndex) {
    return this.predicates[patternIndex];
  }
  /**
   * Disable a certain capture within a query.
   *
   * This prevents the capture from being returned in matches, and also
   * avoids any resource usage associated with recording the capture.
   */
  disableCapture(captureName) {
    const captureNameLength = C.lengthBytesUTF8(captureName);
    const captureNameAddress = C._malloc(captureNameLength + 1);
    C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1);
    C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength);
    C._free(captureNameAddress);
  }
  /**
   * Disable a certain pattern within a query.
   *
   * This prevents the pattern from matching, and also avoids any resource
   * usage associated with the pattern. This throws an error if the pattern
   * index is out of bounds.
   */
  disablePattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    C._ts_query_disable_pattern(this[0], patternIndex);
  }
  /**
   * Check if, on its last execution, this cursor exceeded its maximum number
   * of in-progress matches.
   */
  didExceedMatchLimit() {
    return this.exceededMatchLimit;
  }
  /** Get the byte offset where the given pattern starts in the query's source. */
  startIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_start_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the byte offset where the given pattern ends in the query's source. */
  endIndexForPattern(patternIndex) {
    if (patternIndex >= this.predicates.length) {
      throw new Error(
        `Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`
      );
    }
    return C._ts_query_end_byte_for_pattern(this[0], patternIndex);
  }
  /** Get the number of patterns in the query. */
  patternCount() {
    return C._ts_query_pattern_count(this[0]);
  }
  /** Get the index for a given capture name. */
  captureIndexForName(captureName) {
    return this.captureNames.indexOf(captureName);
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternRooted(patternIndex) {
    return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1;
  }
  /** Check if a given pattern within a query has a single root node. */
  isPatternNonLocal(patternIndex) {
    return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1;
  }
  /**
   * Check if a given step in a query is 'definite'.
   *
   * A query step is 'definite' if its parent pattern will be guaranteed to
   * match successfully once it reaches the step.
   */
  isPatternGuaranteedAtStep(byteIndex) {
    return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1;
  }
};
var LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\w+$/;
var Language = class _Language {
  static {
    __name(this, "Language");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /**
   * A list of all node types in the language. The index of each type in this
   * array is its node type id.
   */
  types;
  /**
   * A list of all field names in the language. The index of each field name in
   * this array is its field id.
   */
  fields;
  /** @internal */
  constructor(internal, address) {
    assertInternal(internal);
    this[0] = address;
    this.types = new Array(C._ts_language_symbol_count(this[0]));
    for (let i22 = 0, n3 = this.types.length; i22 < n3; i22++) {
      if (C._ts_language_symbol_type(this[0], i22) < 2) {
        this.types[i22] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i22));
      }
    }
    this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
    for (let i22 = 0, n3 = this.fields.length; i22 < n3; i22++) {
      const fieldName = C._ts_language_field_name_for_id(this[0], i22);
      if (fieldName !== 0) {
        this.fields[i22] = C.UTF8ToString(fieldName);
      } else {
        this.fields[i22] = null;
      }
    }
  }
  /**
   * Gets the name of the language.
   */
  get name() {
    const ptr = C._ts_language_name(this[0]);
    if (ptr === 0) return null;
    return C.UTF8ToString(ptr);
  }
  /**
   * @deprecated since version 0.25.0, use {@link Language#abiVersion} instead
   * Gets the version of the language.
   */
  get version() {
    return C._ts_language_version(this[0]);
  }
  /**
   * Gets the ABI version of the language.
   */
  get abiVersion() {
    return C._ts_language_abi_version(this[0]);
  }
  /**
  * Get the metadata for this language. This information is generated by the
  * CLI, and relies on the language author providing the correct metadata in
  * the language's `tree-sitter.json` file.
  */
  get metadata() {
    C._ts_language_metadata(this[0]);
    const length = C.getValue(TRANSFER_BUFFER, "i32");
    const address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    if (length === 0) return null;
    return unmarshalLanguageMetadata(address);
  }
  /**
   * Gets the number of fields in the language.
   */
  get fieldCount() {
    return this.fields.length - 1;
  }
  /**
   * Gets the number of states in the language.
   */
  get stateCount() {
    return C._ts_language_state_count(this[0]);
  }
  /**
   * Get the field id for a field name.
   */
  fieldIdForName(fieldName) {
    const result = this.fields.indexOf(fieldName);
    return result !== -1 ? result : null;
  }
  /**
   * Get the field name for a field id.
   */
  fieldNameForId(fieldId) {
    return this.fields[fieldId] ?? null;
  }
  /**
   * Get the node type id for a node type name.
   */
  idForNodeType(type, named) {
    const typeLength = C.lengthBytesUTF8(type);
    const typeAddress = C._malloc(typeLength + 1);
    C.stringToUTF8(type, typeAddress, typeLength + 1);
    const result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0);
    C._free(typeAddress);
    return result || null;
  }
  /**
   * Gets the number of node types in the language.
   */
  get nodeTypeCount() {
    return C._ts_language_symbol_count(this[0]);
  }
  /**
   * Get the node type name for a node type id.
   */
  nodeTypeForId(typeId) {
    const name2 = C._ts_language_symbol_name(this[0], typeId);
    return name2 ? C.UTF8ToString(name2) : null;
  }
  /**
   * Check if a node type is named.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/2-basic-parsing.html#named-vs-anonymous-nodes}
   */
  nodeTypeIsNamed(typeId) {
    return C._ts_language_type_is_named_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Check if a node type is visible.
   */
  nodeTypeIsVisible(typeId) {
    return C._ts_language_type_is_visible_wasm(this[0], typeId) ? true : false;
  }
  /**
   * Get the supertypes ids of this language.
   *
   * @see {@link https://tree-sitter.github.io/tree-sitter/using-parsers/6-static-node-types.html?highlight=supertype#supertype-nodes}
   */
  get supertypes() {
    C._ts_language_supertypes_wasm(this[0]);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the subtype ids for a given supertype node id.
   */
  subtypes(supertype) {
    C._ts_language_subtypes_wasm(this[0], supertype);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = C.getValue(address, "i16");
        address += SIZE_OF_SHORT;
      }
    }
    return result;
  }
  /**
   * Get the next state id for a given state id and node type id.
   */
  nextState(stateId, typeId) {
    return C._ts_language_next_state(this[0], stateId, typeId);
  }
  /**
   * Create a new lookahead iterator for this language and parse state.
   *
   * This returns `null` if state is invalid for this language.
   *
   * Iterating {@link LookaheadIterator} will yield valid symbols in the given
   * parse state. Newly created lookahead iterators will return the `ERROR`
   * symbol from {@link LookaheadIterator#currentType}.
   *
   * Lookahead iterators can be useful for generating suggestions and improving
   * syntax error diagnostics. To get symbols valid in an `ERROR` node, use the
   * lookahead iterator on its first leaf node state. For `MISSING` nodes, a
   * lookahead iterator created on the previous non-extra leaf node may be
   * appropriate.
   */
  lookaheadIterator(stateId) {
    const address = C._ts_lookahead_iterator_new(this[0], stateId);
    if (address) return new LookaheadIterator(INTERNAL, address, this);
    return null;
  }
  /**
   * @deprecated since version 0.25.0, call `new` on a {@link Query} instead
   *
   * Create a new query from a string containing one or more S-expression
   * patterns.
   *
   * The query is associated with a particular language, and can only be run
   * on syntax nodes parsed with that language. References to Queries can be
   * shared between multiple threads.
   *
   * @link {@see https://tree-sitter.github.io/tree-sitter/using-parsers/queries}
   */
  query(source) {
    console.warn("Language.query is deprecated. Use new Query(language, source) instead.");
    return new Query(this, source);
  }
  /**
   * Load a language from a WebAssembly module.
   * The module can be provided as a path to a file or as a buffer.
   */
  static async load(input) {
    let bytes;
    if (input instanceof Uint8Array) {
      bytes = Promise.resolve(input);
    } else {
      if (globalThis.process?.versions.node) {
        const fs22 = await import("fs/promises");
        bytes = fs22.readFile(input);
      } else {
        bytes = fetch(input).then((response) => response.arrayBuffer().then((buffer2) => {
          if (response.ok) {
            return new Uint8Array(buffer2);
          } else {
            const body2 = new TextDecoder("utf-8").decode(buffer2);
            throw new Error(`Language.load failed with status ${response.status}.

${body2}`);
          }
        }));
      }
    }
    const mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: true });
    const symbolNames = Object.keys(mod);
    const functionName = symbolNames.find((key) => LANGUAGE_FUNCTION_REGEX.test(key) && !key.includes("external_scanner_"));
    if (!functionName) {
      console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(symbolNames, null, 2)}`);
      throw new Error("Language.load failed: no language function found in WASM file");
    }
    const languageAddress = mod[functionName]();
    return new _Language(INTERNAL, languageAddress);
  }
};
var Module2 = (() => {
  var _scriptName = import.meta.url;
  return async function(moduleArg = {}) {
    var moduleRtn;
    var Module = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve4, reject) => {
      readyPromiseResolve = resolve4;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    if (ENVIRONMENT_IS_NODE) {
      const { createRequire } = await import("module");
      var require = createRequire(import.meta.url);
    }
    Module.currentQueryProgressCallback = null;
    Module.currentProgressCallback = null;
    Module.currentLogCallback = null;
    Module.currentParseCallback = null;
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = /* @__PURE__ */ __name((status, toThrow) => {
      throw toThrow;
    }, "quit_");
    var scriptDirectory = "";
    function locateFile(path2) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path2, scriptDirectory);
      }
      return scriptDirectory + path2;
    }
    __name(locateFile, "locateFile");
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs");
      var nodePath = require("path");
      if (!import.meta.url.startsWith("data:")) {
        scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import.meta.url)) + "/";
      }
      readBinary = /* @__PURE__ */ __name((filename) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename);
        return ret;
      }, "readBinary");
      readAsync = /* @__PURE__ */ __name(async (filename, binary2 = true) => {
        filename = isFileURI(filename) ? new URL(filename) : filename;
        var ret = fs.readFileSync(filename, binary2 ? void 0 : "utf8");
        return ret;
      }, "readAsync");
      if (!Module["thisProgram"] && process.argv.length > 1) {
        thisProgram = process.argv[1].replace(/\\/g, "/");
      }
      arguments_ = process.argv.slice(2);
      quit_ = /* @__PURE__ */ __name((status, toThrow) => {
        process.exitCode = status;
        throw toThrow;
      }, "quit_");
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = /* @__PURE__ */ __name((url2) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url2, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(
              /** @type{!ArrayBuffer} */
              xhr.response
            );
          }, "readBinary");
        }
        readAsync = /* @__PURE__ */ __name(async (url2) => {
          if (isFileURI(url2)) {
            return new Promise((resolve4, reject) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  resolve4(xhr.response);
                  return;
                }
                reject(xhr.status);
              };
              xhr.onerror = reject;
              xhr.send(null);
            });
          }
          var response = await fetch(url2, {
            credentials: "same-origin"
          });
          if (response.ok) {
            return response.arrayBuffer();
          }
          throw new Error(response.status + " : " + response.url);
        }, "readAsync");
      }
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.error.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    var dynamicLibraries = Module["dynamicLibraries"] || [];
    var wasmBinary = Module["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert(condition, text) {
      if (!condition) {
        abort(text);
      }
    }
    __name(assert, "assert");
    var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    var HEAP_DATA_VIEW;
    var runtimeInitialized = false;
    var isFileURI = /* @__PURE__ */ __name((filename) => filename.startsWith("file://"), "isFileURI");
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module["HEAP_DATA_VIEW"] = HEAP_DATA_VIEW = new DataView(b);
      Module["HEAP8"] = HEAP8 = new Int8Array(b);
      Module["HEAP16"] = HEAP16 = new Int16Array(b);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module["HEAP32"] = HEAP32 = new Int32Array(b);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      Module["HEAP64"] = HEAP64 = new BigInt64Array(b);
      Module["HEAPU64"] = HEAPU64 = new BigUint64Array(b);
    }
    __name(updateMemoryViews, "updateMemoryViews");
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 33554432;
      wasmMemory = new WebAssembly.Memory({
        "initial": INITIAL_MEMORY / 65536,
        // In theory we should not need to emit the maximum if we want "unlimited"
        // or 4GB of memory, but VMs error on that atm, see
        // https://github.com/emscripten-core/emscripten/issues/14130
        // And in the pthreads case we definitely need to emit a maximum. So
        // always emit one.
        "maximum": 32768
      });
    }
    updateMemoryViews();
    var __RELOC_FUNCS__ = [];
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(onPreRuns);
    }
    __name(preRun, "preRun");
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__RELOC_FUNCS__);
      wasmExports["__wasm_call_ctors"]();
      callRuntimeCallbacks(onPostCtors);
    }
    __name(initRuntime, "initRuntime");
    function preMain() {
    }
    __name(preMain, "preMain");
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(onPostRuns);
    }
    __name(postRun, "postRun");
    var runDependencies = 0;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id) {
      return id;
    }
    __name(getUniqueRunDependency, "getUniqueRunDependency");
    function addRunDependency(id) {
      runDependencies++;
      Module["monitorRunDependencies"]?.(runDependencies);
    }
    __name(addRunDependency, "addRunDependency");
    function removeRunDependency(id) {
      runDependencies--;
      Module["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    __name(removeRunDependency, "removeRunDependency");
    function abort(what) {
      Module["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    __name(abort, "abort");
    var wasmBinaryFile;
    function findWasmBinary() {
      if (Module["locateFile"]) {
        return locateFile("tree-sitter.wasm");
      }
      return new URL("tree-sitter.wasm", import.meta.url).href;
    }
    __name(findWasmBinary, "findWasmBinary");
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    __name(getBinarySync, "getBinarySync");
    async function getWasmBinary(binaryFile) {
      if (!wasmBinary) {
        try {
          var response = await readAsync(binaryFile);
          return new Uint8Array(response);
        } catch {
        }
      }
      return getBinarySync(binaryFile);
    }
    __name(getWasmBinary, "getWasmBinary");
    async function instantiateArrayBuffer(binaryFile, imports) {
      try {
        var binary2 = await getWasmBinary(binaryFile);
        var instance2 = await WebAssembly.instantiate(binary2, imports);
        return instance2;
      } catch (reason) {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort(reason);
      }
    }
    __name(instantiateArrayBuffer, "instantiateArrayBuffer");
    async function instantiateAsync(binary2, binaryFile, imports) {
      if (!binary2 && typeof WebAssembly.instantiateStreaming == "function" && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE) {
        try {
          var response = fetch(binaryFile, {
            credentials: "same-origin"
          });
          var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
          return instantiationResult;
        } catch (reason) {
          err(`wasm streaming compile failed: ${reason}`);
          err("falling back to ArrayBuffer instantiation");
        }
      }
      return instantiateArrayBuffer(binaryFile, imports);
    }
    __name(instantiateAsync, "instantiateAsync");
    function getWasmImports() {
      return {
        "env": wasmImports,
        "wasi_snapshot_preview1": wasmImports,
        "GOT.mem": new Proxy(wasmImports, GOTHandler),
        "GOT.func": new Proxy(wasmImports, GOTHandler)
      };
    }
    __name(getWasmImports, "getWasmImports");
    async function createWasm() {
      function receiveInstance(instance2, module22) {
        wasmExports = instance2.exports;
        wasmExports = relocateExports(wasmExports, 1024);
        var metadata2 = getDylinkMetadata(module22);
        if (metadata2.neededDynlibs) {
          dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries);
        }
        mergeLibSymbols(wasmExports, "main");
        LDSO.init();
        loadDylibs();
        __RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      __name(receiveInstance, "receiveInstance");
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result2) {
        return receiveInstance(result2["instance"], result2["module"]);
      }
      __name(receiveInstantiationResult, "receiveInstantiationResult");
      var info2 = getWasmImports();
      if (Module["instantiateWasm"]) {
        return new Promise((resolve4, reject) => {
          Module["instantiateWasm"](info2, (mod, inst) => {
            receiveInstance(mod, inst);
            resolve4(mod.exports);
          });
        });
      }
      wasmBinaryFile ??= findWasmBinary();
      try {
        var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info2);
        var exports = receiveInstantiationResult(result);
        return exports;
      } catch (e) {
        readyPromiseReject(e);
        return Promise.reject(e);
      }
    }
    __name(createWasm, "createWasm");
    var ASM_CONSTS = {};
    class ExitStatus {
      static {
        __name(this, "ExitStatus");
      }
      name = "ExitStatus";
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }
    var GOT = {};
    var currentModuleWeakSymbols = /* @__PURE__ */ new Set([]);
    var GOTHandler = {
      get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({
            "value": "i32",
            "mutable": true
          });
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          rtn.required = true;
        }
        return rtn;
      }
    };
    var LE_HEAP_LOAD_F32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat32(byteOffset, true), "LE_HEAP_LOAD_F32");
    var LE_HEAP_LOAD_F64 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getFloat64(byteOffset, true), "LE_HEAP_LOAD_F64");
    var LE_HEAP_LOAD_I16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt16(byteOffset, true), "LE_HEAP_LOAD_I16");
    var LE_HEAP_LOAD_I32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getInt32(byteOffset, true), "LE_HEAP_LOAD_I32");
    var LE_HEAP_LOAD_U16 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint16(byteOffset, true), "LE_HEAP_LOAD_U16");
    var LE_HEAP_LOAD_U32 = /* @__PURE__ */ __name((byteOffset) => HEAP_DATA_VIEW.getUint32(byteOffset, true), "LE_HEAP_LOAD_U32");
    var LE_HEAP_STORE_F32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat32(byteOffset, value, true), "LE_HEAP_STORE_F32");
    var LE_HEAP_STORE_F64 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setFloat64(byteOffset, value, true), "LE_HEAP_STORE_F64");
    var LE_HEAP_STORE_I16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt16(byteOffset, value, true), "LE_HEAP_STORE_I16");
    var LE_HEAP_STORE_I32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setInt32(byteOffset, value, true), "LE_HEAP_STORE_I32");
    var LE_HEAP_STORE_U16 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint16(byteOffset, value, true), "LE_HEAP_STORE_U16");
    var LE_HEAP_STORE_U32 = /* @__PURE__ */ __name((byteOffset, value) => HEAP_DATA_VIEW.setUint32(byteOffset, value, true), "LE_HEAP_STORE_U32");
    var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    }, "callRuntimeCallbacks");
    var onPostRuns = [];
    var addOnPostRun = /* @__PURE__ */ __name((cb) => onPostRuns.unshift(cb), "addOnPostRun");
    var onPreRuns = [];
    var addOnPreRun = /* @__PURE__ */ __name((cb) => onPreRuns.unshift(cb), "addOnPreRun");
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    }, "UTF8ArrayToString");
    var getDylinkMetadata = /* @__PURE__ */ __name((binary2) => {
      var offset = 0;
      var end = 0;
      function getU8() {
        return binary2[offset++];
      }
      __name(getU8, "getU8");
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary2[offset++];
          ret += (byte & 127) * mul;
          mul *= 128;
          if (!(byte & 128)) break;
        }
        return ret;
      }
      __name(getLEB, "getLEB");
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary2, offset - len, len);
      }
      __name(getString, "getString");
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
      __name(failIf, "failIf");
      var name2 = "dylink.0";
      if (binary2 instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary2, name2);
        if (dylinkSection.length === 0) {
          name2 = "dylink";
          dylinkSection = WebAssembly.Module.customSections(binary2, name2);
        }
        failIf(dylinkSection.length === 0, "need dylink section");
        binary2 = new Uint8Array(dylinkSection[0]);
        end = binary2.length;
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541;
        failIf(!magicNumberFound, "need to see wasm magic number");
        failIf(binary2[8] !== 0, "need the dylink section to be first");
        offset = 9;
        var section_size = getLEB();
        end = offset + section_size;
        name2 = getString();
      }
      var customSection = {
        neededDynlibs: [],
        tlsExports: /* @__PURE__ */ new Set(),
        weakImports: /* @__PURE__ */ new Set()
      };
      if (name2 == "dylink") {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        var neededDynlibsCount = getLEB();
        for (var i22 = 0; i22 < neededDynlibsCount; ++i22) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name2 !== "dylink.0");
        var WASM_DYLINK_MEM_INFO = 1;
        var WASM_DYLINK_NEEDED = 2;
        var WASM_DYLINK_EXPORT_INFO = 3;
        var WASM_DYLINK_IMPORT_INFO = 4;
        var WASM_SYMBOL_TLS = 256;
        var WASM_SYMBOL_BINDING_MASK = 3;
        var WASM_SYMBOL_BINDING_WEAK = 1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i22 = 0; i22 < neededDynlibsCount; ++i22) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags22 = getLEB();
              if (flags22 & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var modname = getString();
              var symname = getString();
              var flags22 = getLEB();
              if ((flags22 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            offset += subsectionSize;
          }
        }
      }
      return customSection;
    }, "getDylinkMetadata");
    function getValue(ptr, type = "i8") {
      if (type.endsWith("*")) type = "*";
      switch (type) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return LE_HEAP_LOAD_I16((ptr >> 1) * 2);
        case "i32":
          return LE_HEAP_LOAD_I32((ptr >> 2) * 4);
        case "i64":
          return HEAP64[ptr >> 3];
        case "float":
          return LE_HEAP_LOAD_F32((ptr >> 2) * 4);
        case "double":
          return LE_HEAP_LOAD_F64((ptr >> 3) * 8);
        case "*":
          return LE_HEAP_LOAD_U32((ptr >> 2) * 4);
        default:
          abort(`invalid type for getValue: ${type}`);
      }
    }
    __name(getValue, "getValue");
    var newDSO = /* @__PURE__ */ __name((name2, handle2, syms) => {
      var dso = {
        refcount: Infinity,
        name: name2,
        exports: syms,
        global: true
      };
      LDSO.loadedLibsByName[name2] = dso;
      if (handle2 != void 0) {
        LDSO.loadedLibsByHandle[handle2] = dso;
      }
      return dso;
    }, "newDSO");
    var LDSO = {
      loadedLibsByName: {},
      loadedLibsByHandle: {},
      init() {
        newDSO("__main__", 0, wasmImports);
      }
    };
    var ___heap_base = 78224;
    var alignMemory = /* @__PURE__ */ __name((size, alignment) => Math.ceil(size / alignment) * alignment, "alignMemory");
    var getMemory = /* @__PURE__ */ __name((size) => {
      if (runtimeInitialized) {
        return _calloc(size, 1);
      }
      var ret = ___heap_base;
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT["__heap_base"].value = end;
      return ret;
    }, "getMemory");
    var isInternalSym = /* @__PURE__ */ __name((symName) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(symName) || symName.startsWith("__em_js__"), "isInternalSym");
    var uleb128Encode = /* @__PURE__ */ __name((n3, target) => {
      if (n3 < 128) {
        target.push(n3);
      } else {
        target.push(n3 % 128 | 128, n3 >> 7);
      }
    }, "uleb128Encode");
    var sigToWasmTypes = /* @__PURE__ */ __name((sig) => {
      var typeNames = {
        "i": "i32",
        "j": "i64",
        "f": "f32",
        "d": "f64",
        "e": "externref",
        "p": "i32"
      };
      var type = {
        parameters: [],
        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]
      };
      for (var i22 = 1; i22 < sig.length; ++i22) {
        type.parameters.push(typeNames[sig[i22]]);
      }
      return type;
    }, "sigToWasmTypes");
    var generateFuncType = /* @__PURE__ */ __name((sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        "i": 127,
        // i32
        "p": 127,
        // i32
        "j": 126,
        // i64
        "f": 125,
        // f32
        "d": 124,
        // f64
        "e": 111
      };
      target.push(96);
      uleb128Encode(sigParam.length, target);
      for (var i22 = 0; i22 < sigParam.length; ++i22) {
        target.push(typeCodes[sigParam[i22]]);
      }
      if (sigRet == "v") {
        target.push(0);
      } else {
        target.push(1, typeCodes[sigRet]);
      }
    }, "generateFuncType");
    var convertJsFunctionToWasm = /* @__PURE__ */ __name((func2, sig) => {
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func2);
      }
      var typeSectionBody = [1];
      generateFuncType(sig, typeSectionBody);
      var bytes = [
        0,
        97,
        115,
        109,
        // magic ("\0asm")
        1,
        0,
        0,
        0,
        // version: 1
        1
      ];
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
      bytes.push(
        2,
        7,
        // import section
        // (import "e" "f" (func 0 (type 0)))
        1,
        1,
        101,
        1,
        102,
        0,
        0,
        7,
        5,
        // export section
        // (export "f" (func 0 (type 0)))
        1,
        1,
        102,
        0,
        0
      );
      var module22 = new WebAssembly.Module(new Uint8Array(bytes));
      var instance2 = new WebAssembly.Instance(module22, {
        "e": {
          "f": func2
        }
      });
      var wrappedFunc = instance2.exports["f"];
      return wrappedFunc;
    }, "convertJsFunctionToWasm");
    var wasmTableMirror = [];
    var wasmTable = new WebAssembly.Table({
      "initial": 31,
      "element": "anyfunc"
    });
    var getWasmTableEntry = /* @__PURE__ */ __name((funcPtr) => {
      var func2 = wasmTableMirror[funcPtr];
      if (!func2) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr);
      }
      return func2;
    }, "getWasmTableEntry");
    var updateTableMap = /* @__PURE__ */ __name((offset, count) => {
      if (functionsInTableMap) {
        for (var i22 = offset; i22 < offset + count; i22++) {
          var item = getWasmTableEntry(i22);
          if (item) {
            functionsInTableMap.set(item, i22);
          }
        }
      }
    }, "updateTableMap");
    var functionsInTableMap;
    var getFunctionAddress = /* @__PURE__ */ __name((func2) => {
      if (!functionsInTableMap) {
        functionsInTableMap = /* @__PURE__ */ new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func2) || 0;
    }, "getFunctionAddress");
    var freeTableIndexes = [];
    var getEmptyTableSlot = /* @__PURE__ */ __name(() => {
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      try {
        wasmTable.grow(1);
      } catch (err2) {
        if (!(err2 instanceof RangeError)) {
          throw err2;
        }
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return wasmTable.length - 1;
    }, "getEmptyTableSlot");
    var setWasmTableEntry = /* @__PURE__ */ __name((idx, func2) => {
      wasmTable.set(idx, func2);
      wasmTableMirror[idx] = wasmTable.get(idx);
    }, "setWasmTableEntry");
    var addFunction = /* @__PURE__ */ __name((func2, sig) => {
      var rtn = getFunctionAddress(func2);
      if (rtn) {
        return rtn;
      }
      var ret = getEmptyTableSlot();
      try {
        setWasmTableEntry(ret, func2);
      } catch (err2) {
        if (!(err2 instanceof TypeError)) {
          throw err2;
        }
        var wrapped = convertJsFunctionToWasm(func2, sig);
        setWasmTableEntry(ret, wrapped);
      }
      functionsInTableMap.set(func2, ret);
      return ret;
    }, "addFunction");
    var updateGOT = /* @__PURE__ */ __name((exports, replace) => {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }
        var value = exports[symName];
        GOT[symName] ||= new WebAssembly.Global({
          "value": "i32",
          "mutable": true
        });
        if (replace || GOT[symName].value == 0) {
          if (typeof value == "function") {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == "number") {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "updateGOT");
    var relocateExports = /* @__PURE__ */ __name((exports, memoryBase2, replace) => {
      var relocated = {};
      for (var e in exports) {
        var value = exports[e];
        if (typeof value == "object") {
          value = value.value;
        }
        if (typeof value == "number") {
          value += memoryBase2;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    }, "relocateExports");
    var isSymbolDefined = /* @__PURE__ */ __name((symName) => {
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    }, "isSymbolDefined");
    var dynCall = /* @__PURE__ */ __name((sig, ptr, args2 = []) => {
      var rtn = getWasmTableEntry(ptr)(...args2);
      return rtn;
    }, "dynCall");
    var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), "stackSave");
    var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), "stackRestore");
    var createInvokeFunction = /* @__PURE__ */ __name((sig) => (ptr, ...args2) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0) throw e;
        _setThrew(1, 0);
        if (sig[0] == "j") return 0n;
      }
    }, "createInvokeFunction");
    var resolveGlobalSymbol = /* @__PURE__ */ __name((symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      } else if (symName.startsWith("invoke_")) {
        sym = wasmImports[symName] = createInvokeFunction(symName.split("_")[1]);
      }
      return {
        sym,
        name: symName
      };
    }, "resolveGlobalSymbol");
    var onPostCtors = [];
    var addOnPostCtor = /* @__PURE__ */ __name((cb) => onPostCtors.unshift(cb), "addOnPostCtor");
    var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "", "UTF8ToString");
    var loadWebAssemblyModule = /* @__PURE__ */ __name((binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var memAlign = Math.pow(2, metadata.memoryAlign);
        var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0;
        var tableBase = metadata.tableSize ? wasmTable.length : 0;
        if (handle) {
          HEAP8[handle + 8] = 1;
          LE_HEAP_STORE_U32((handle + 12 >> 2) * 4, memoryBase);
          LE_HEAP_STORE_I32((handle + 16 >> 2) * 4, metadata.memorySize);
          LE_HEAP_STORE_U32((handle + 20 >> 2) * 4, tableBase);
          LE_HEAP_STORE_I32((handle + 24 >> 2) * 4, metadata.tableSize);
        }
        if (metadata.tableSize) {
          wasmTable.grow(metadata.tableSize);
        }
        var moduleExports;
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }
        __name(resolveSymbol, "resolveSymbol");
        var proxyHandler = {
          get(stubs, prop) {
            switch (prop) {
              case "__memory_base":
                return memoryBase;
              case "__table_base":
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              var res = wasmImports[prop];
              return res;
            }
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args2) => {
                resolved ||= resolveSymbol(prop);
                return resolved(...args2);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          "GOT.mem": new Proxy({}, GOTHandler),
          "GOT.func": new Proxy({}, GOTHandler),
          "env": proxy,
          "wasi_snapshot_preview1": proxy
        };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf("$" + arity) != -1) {
                args.push("$" + arity);
              } else {
                break;
              }
            }
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          __name(addEmAsm, "addEmAsm");
          if ("__start_em_asm" in moduleExports) {
            var start = moduleExports["__start_em_asm"];
            var stop = moduleExports["__stop_em_asm"];
            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            cSig = cSig.slice(1, -1);
            if (cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replace("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          __name(addEmJs, "addEmJs");
          for (var name in moduleExports) {
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name];
              var jsString = UTF8ToString(start);
              var parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }
          var applyRelocs = moduleExports["__wasm_apply_data_relocs"];
          if (applyRelocs) {
            if (runtimeInitialized) {
              applyRelocs();
            } else {
              __RELOC_FUNCS__.push(applyRelocs);
            }
          }
          var init = moduleExports["__wasm_call_ctors"];
          if (init) {
            if (runtimeInitialized) {
              init();
            } else {
              addOnPostCtor(init);
            }
          }
          return moduleExports;
        }
        __name(postInstantiation, "postInstantiation");
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then((result) => postInstantiation(result.module, result.instance));
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      __name(loadModule, "loadModule");
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce((chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)), Promise.resolve()).then(loadModule);
      }
      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    }, "loadWebAssemblyModule");
    var mergeLibSymbols = /* @__PURE__ */ __name((exports, libName2) => {
      for (var [sym, exp] of Object.entries(exports)) {
        const setImport = /* @__PURE__ */ __name((target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        }, "setImport");
        setImport(sym);
        const main_alias = "__main_argc_argv";
        if (sym == "main") {
          setImport(main_alias);
        }
        if (sym == main_alias) {
          setImport("main");
        }
      }
    }, "mergeLibSymbols");
    var asyncLoad = /* @__PURE__ */ __name(async (url2) => {
      var arrayBuffer = await readAsync(url2);
      return new Uint8Array(arrayBuffer);
    }, "asyncLoad");
    function loadDynamicLibrary(libName2, flags22 = {
      global: true,
      nodelete: true
    }, localScope2, handle2) {
      var dso = LDSO.loadedLibsByName[libName2];
      if (dso) {
        if (!flags22.global) {
          if (localScope2) {
            Object.assign(localScope2, dso.exports);
          }
        } else if (!dso.global) {
          dso.global = true;
          mergeLibSymbols(dso.exports, libName2);
        }
        if (flags22.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++;
        if (handle2) {
          LDSO.loadedLibsByHandle[handle2] = dso;
        }
        return flags22.loadAsync ? Promise.resolve(true) : true;
      }
      dso = newDSO(libName2, handle2, "loading");
      dso.refcount = flags22.nodelete ? Infinity : 1;
      dso.global = flags22.global;
      function loadLibData() {
        if (handle2) {
          var data2 = LE_HEAP_LOAD_U32((handle2 + 28 >> 2) * 4);
          var dataSize = LE_HEAP_LOAD_U32((handle2 + 32 >> 2) * 4);
          if (data2 && dataSize) {
            var libData = HEAP8.slice(data2, data2 + dataSize);
            return flags22.loadAsync ? Promise.resolve(libData) : libData;
          }
        }
        var libFile = locateFile(libName2);
        if (flags22.loadAsync) {
          return asyncLoad(libFile);
        }
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }
      __name(loadLibData, "loadLibData");
      function getExports() {
        if (flags22.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags22, libName2, localScope2, handle2));
        }
        return loadWebAssemblyModule(loadLibData(), flags22, libName2, localScope2, handle2);
      }
      __name(getExports, "getExports");
      function moduleLoaded(exports) {
        if (dso.global) {
          mergeLibSymbols(exports, libName2);
        } else if (localScope2) {
          Object.assign(localScope2, exports);
        }
        dso.exports = exports;
      }
      __name(moduleLoaded, "moduleLoaded");
      if (flags22.loadAsync) {
        return getExports().then((exports) => {
          moduleLoaded(exports);
          return true;
        });
      }
      moduleLoaded(getExports());
      return true;
    }
    __name(loadDynamicLibrary, "loadDynamicLibrary");
    var reportUndefinedSymbols = /* @__PURE__ */ __name(() => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            continue;
          }
          if (typeof value == "function") {
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == "number") {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    }, "reportUndefinedSymbols");
    var loadDylibs = /* @__PURE__ */ __name(() => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs");
      dynamicLibraries.reduce((chain, lib2) => chain.then(() => loadDynamicLibrary(lib2, {
        loadAsync: true,
        global: true,
        nodelete: true,
        allowUndefined: true
      })), Promise.resolve()).then(() => {
        reportUndefinedSymbols();
        removeRunDependency("loadDylibs");
      });
    }, "loadDylibs");
    var noExitRuntime = Module["noExitRuntime"] || true;
    function setValue(ptr, value, type = "i8") {
      if (type.endsWith("*")) type = "*";
      switch (type) {
        case "i1":
          HEAP8[ptr] = value;
          break;
        case "i8":
          HEAP8[ptr] = value;
          break;
        case "i16":
          LE_HEAP_STORE_I16((ptr >> 1) * 2, value);
          break;
        case "i32":
          LE_HEAP_STORE_I32((ptr >> 2) * 4, value);
          break;
        case "i64":
          HEAP64[ptr >> 3] = BigInt(value);
          break;
        case "float":
          LE_HEAP_STORE_F32((ptr >> 2) * 4, value);
          break;
        case "double":
          LE_HEAP_STORE_F64((ptr >> 3) * 8, value);
          break;
        case "*":
          LE_HEAP_STORE_U32((ptr >> 2) * 4, value);
          break;
        default:
          abort(`invalid type for setValue: ${type}`);
      }
    }
    __name(setValue, "setValue");
    var ___memory_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1024);
    var ___stack_pointer = new WebAssembly.Global({
      "value": "i32",
      "mutable": true
    }, 78224);
    var ___table_base = new WebAssembly.Global({
      "value": "i32",
      "mutable": false
    }, 1);
    var __abort_js = /* @__PURE__ */ __name(() => abort(""), "__abort_js");
    __abort_js.sig = "v";
    var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), "_emscripten_get_now");
    _emscripten_get_now.sig = "d";
    var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), "_emscripten_date_now");
    _emscripten_date_now.sig = "d";
    var nowIsMonotonic = 1;
    var checkWasiClock = /* @__PURE__ */ __name((clock_id) => clock_id >= 0 && clock_id <= 3, "checkWasiClock");
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = /* @__PURE__ */ __name((num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), "bigintToI53Checked");
    function _clock_time_get(clk_id, ignored_precision, ptime) {
      ignored_precision = bigintToI53Checked(ignored_precision);
      if (!checkWasiClock(clk_id)) {
        return 28;
      }
      var now;
      if (clk_id === 0) {
        now = _emscripten_date_now();
      } else if (nowIsMonotonic) {
        now = _emscripten_get_now();
      } else {
        return 52;
      }
      var nsec = Math.round(now * 1e3 * 1e3);
      HEAP64[ptime >> 3] = BigInt(nsec);
      return 0;
    }
    __name(_clock_time_get, "_clock_time_get");
    _clock_time_get.sig = "iijp";
    var getHeapMax = /* @__PURE__ */ __name(() => (
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648
    ), "getHeapMax");
    var growMemory = /* @__PURE__ */ __name((size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    }, "growMemory");
    var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }, "_emscripten_resize_heap");
    _emscripten_resize_heap.sig = "ip";
    var _fd_close = /* @__PURE__ */ __name((fd) => 52, "_fd_close");
    _fd_close.sig = "ii";
    function _fd_seek(fd, offset, whence, newOffset) {
      offset = bigintToI53Checked(offset);
      return 70;
    }
    __name(_fd_seek, "_fd_seek");
    _fd_seek.sig = "iijip";
    var printCharBuffers = [null, [], []];
    var printChar = /* @__PURE__ */ __name((stream2, curr) => {
      var buffer2 = printCharBuffers[stream2];
      if (curr === 0 || curr === 10) {
        (stream2 === 1 ? out : err)(UTF8ArrayToString(buffer2));
        buffer2.length = 0;
      } else {
        buffer2.push(curr);
      }
    }, "printChar");
    var flush_NO_FILESYSTEM = /* @__PURE__ */ __name(() => {
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    }, "flush_NO_FILESYSTEM");
    var SYSCALLS = {
      varargs: void 0,
      getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }
    };
    var _fd_write = /* @__PURE__ */ __name((fd, iov, iovcnt, pnum) => {
      var num = 0;
      for (var i22 = 0; i22 < iovcnt; i22++) {
        var ptr = LE_HEAP_LOAD_U32((iov >> 2) * 4);
        var len = LE_HEAP_LOAD_U32((iov + 4 >> 2) * 4);
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr + j]);
        }
        num += len;
      }
      LE_HEAP_STORE_U32((pnum >> 2) * 4, num);
      return 0;
    }, "_fd_write");
    _fd_write.sig = "iippp";
    function _tree_sitter_log_callback(isLexMessage, messageAddress) {
      if (Module.currentLogCallback) {
        const message = UTF8ToString(messageAddress);
        Module.currentLogCallback(message, isLexMessage !== 0);
      }
    }
    __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
    function _tree_sitter_parse_callback(inputBufferAddress, index, row, column, lengthAddress) {
      const INPUT_BUFFER_SIZE = 10 * 1024;
      const string = Module.currentParseCallback(index, {
        row,
        column
      });
      if (typeof string === "string") {
        setValue(lengthAddress, string.length, "i32");
        stringToUTF16(string, inputBufferAddress, INPUT_BUFFER_SIZE);
      } else {
        setValue(lengthAddress, 0, "i32");
      }
    }
    __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
    function _tree_sitter_progress_callback(currentOffset, hasError) {
      if (Module.currentProgressCallback) {
        return Module.currentProgressCallback({
          currentOffset,
          hasError
        });
      }
      return false;
    }
    __name(_tree_sitter_progress_callback, "_tree_sitter_progress_callback");
    function _tree_sitter_query_progress_callback(currentOffset) {
      if (Module.currentQueryProgressCallback) {
        return Module.currentQueryProgressCallback({
          currentOffset
        });
      }
      return false;
    }
    __name(_tree_sitter_query_progress_callback, "_tree_sitter_query_progress_callback");
    var runtimeKeepaliveCounter = 0;
    var keepRuntimeAlive = /* @__PURE__ */ __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, "keepRuntimeAlive");
    var _proc_exit = /* @__PURE__ */ __name((code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module["onExit"]?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    }, "_proc_exit");
    _proc_exit.sig = "vi";
    var exitJS = /* @__PURE__ */ __name((status, implicit) => {
      EXITSTATUS = status;
      _proc_exit(status);
    }, "exitJS");
    var handleException = /* @__PURE__ */ __name((e) => {
      if (e instanceof ExitStatus || e == "unwind") {
        return EXITSTATUS;
      }
      quit_(1, e);
    }, "handleException");
    var lengthBytesUTF8 = /* @__PURE__ */ __name((str) => {
      var len = 0;
      for (var i22 = 0; i22 < str.length; ++i22) {
        var c = str.charCodeAt(i22);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i22;
        } else {
          len += 3;
        }
      }
      return len;
    }, "lengthBytesUTF8");
    var stringToUTF8Array = /* @__PURE__ */ __name((str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i22 = 0; i22 < str.length; ++i22) {
        var u = str.charCodeAt(i22);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i22);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }, "stringToUTF8Array");
    var stringToUTF8 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite), "stringToUTF8");
    var stackAlloc = /* @__PURE__ */ __name((sz) => __emscripten_stack_alloc(sz), "stackAlloc");
    var stringToUTF8OnStack = /* @__PURE__ */ __name((str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    }, "stringToUTF8OnStack");
    var AsciiToString = /* @__PURE__ */ __name((ptr) => {
      var str = "";
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    }, "AsciiToString");
    var stringToUTF16 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i22 = 0; i22 < numCharsToWrite; ++i22) {
        var codeUnit = str.charCodeAt(i22);
        LE_HEAP_STORE_I16((outPtr >> 1) * 2, codeUnit);
        outPtr += 2;
      }
      LE_HEAP_STORE_I16((outPtr >> 1) * 2, 0);
      return outPtr - startPtr;
    }, "stringToUTF16");
    var wasmImports = {
      /** @export */
      __heap_base: ___heap_base,
      /** @export */
      __indirect_function_table: wasmTable,
      /** @export */
      __memory_base: ___memory_base,
      /** @export */
      __stack_pointer: ___stack_pointer,
      /** @export */
      __table_base: ___table_base,
      /** @export */
      _abort_js: __abort_js,
      /** @export */
      clock_time_get: _clock_time_get,
      /** @export */
      emscripten_resize_heap: _emscripten_resize_heap,
      /** @export */
      fd_close: _fd_close,
      /** @export */
      fd_seek: _fd_seek,
      /** @export */
      fd_write: _fd_write,
      /** @export */
      memory: wasmMemory,
      /** @export */
      tree_sitter_log_callback: _tree_sitter_log_callback,
      /** @export */
      tree_sitter_parse_callback: _tree_sitter_parse_callback,
      /** @export */
      tree_sitter_progress_callback: _tree_sitter_progress_callback,
      /** @export */
      tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback
    };
    var wasmExports = await createWasm();
    var ___wasm_call_ctors = wasmExports["__wasm_call_ctors"];
    var _malloc = Module["_malloc"] = wasmExports["malloc"];
    var _calloc = Module["_calloc"] = wasmExports["calloc"];
    var _realloc = Module["_realloc"] = wasmExports["realloc"];
    var _free = Module["_free"] = wasmExports["free"];
    var _memcmp = Module["_memcmp"] = wasmExports["memcmp"];
    var _ts_language_symbol_count = Module["_ts_language_symbol_count"] = wasmExports["ts_language_symbol_count"];
    var _ts_language_state_count = Module["_ts_language_state_count"] = wasmExports["ts_language_state_count"];
    var _ts_language_version = Module["_ts_language_version"] = wasmExports["ts_language_version"];
    var _ts_language_abi_version = Module["_ts_language_abi_version"] = wasmExports["ts_language_abi_version"];
    var _ts_language_metadata = Module["_ts_language_metadata"] = wasmExports["ts_language_metadata"];
    var _ts_language_name = Module["_ts_language_name"] = wasmExports["ts_language_name"];
    var _ts_language_field_count = Module["_ts_language_field_count"] = wasmExports["ts_language_field_count"];
    var _ts_language_next_state = Module["_ts_language_next_state"] = wasmExports["ts_language_next_state"];
    var _ts_language_symbol_name = Module["_ts_language_symbol_name"] = wasmExports["ts_language_symbol_name"];
    var _ts_language_symbol_for_name = Module["_ts_language_symbol_for_name"] = wasmExports["ts_language_symbol_for_name"];
    var _strncmp = Module["_strncmp"] = wasmExports["strncmp"];
    var _ts_language_symbol_type = Module["_ts_language_symbol_type"] = wasmExports["ts_language_symbol_type"];
    var _ts_language_field_name_for_id = Module["_ts_language_field_name_for_id"] = wasmExports["ts_language_field_name_for_id"];
    var _ts_lookahead_iterator_new = Module["_ts_lookahead_iterator_new"] = wasmExports["ts_lookahead_iterator_new"];
    var _ts_lookahead_iterator_delete = Module["_ts_lookahead_iterator_delete"] = wasmExports["ts_lookahead_iterator_delete"];
    var _ts_lookahead_iterator_reset_state = Module["_ts_lookahead_iterator_reset_state"] = wasmExports["ts_lookahead_iterator_reset_state"];
    var _ts_lookahead_iterator_reset = Module["_ts_lookahead_iterator_reset"] = wasmExports["ts_lookahead_iterator_reset"];
    var _ts_lookahead_iterator_next = Module["_ts_lookahead_iterator_next"] = wasmExports["ts_lookahead_iterator_next"];
    var _ts_lookahead_iterator_current_symbol = Module["_ts_lookahead_iterator_current_symbol"] = wasmExports["ts_lookahead_iterator_current_symbol"];
    var _ts_parser_delete = Module["_ts_parser_delete"] = wasmExports["ts_parser_delete"];
    var _ts_parser_reset = Module["_ts_parser_reset"] = wasmExports["ts_parser_reset"];
    var _ts_parser_set_language = Module["_ts_parser_set_language"] = wasmExports["ts_parser_set_language"];
    var _ts_parser_timeout_micros = Module["_ts_parser_timeout_micros"] = wasmExports["ts_parser_timeout_micros"];
    var _ts_parser_set_timeout_micros = Module["_ts_parser_set_timeout_micros"] = wasmExports["ts_parser_set_timeout_micros"];
    var _ts_parser_set_included_ranges = Module["_ts_parser_set_included_ranges"] = wasmExports["ts_parser_set_included_ranges"];
    var _ts_query_new = Module["_ts_query_new"] = wasmExports["ts_query_new"];
    var _ts_query_delete = Module["_ts_query_delete"] = wasmExports["ts_query_delete"];
    var _iswspace = Module["_iswspace"] = wasmExports["iswspace"];
    var _iswalnum = Module["_iswalnum"] = wasmExports["iswalnum"];
    var _ts_query_pattern_count = Module["_ts_query_pattern_count"] = wasmExports["ts_query_pattern_count"];
    var _ts_query_capture_count = Module["_ts_query_capture_count"] = wasmExports["ts_query_capture_count"];
    var _ts_query_string_count = Module["_ts_query_string_count"] = wasmExports["ts_query_string_count"];
    var _ts_query_capture_name_for_id = Module["_ts_query_capture_name_for_id"] = wasmExports["ts_query_capture_name_for_id"];
    var _ts_query_capture_quantifier_for_id = Module["_ts_query_capture_quantifier_for_id"] = wasmExports["ts_query_capture_quantifier_for_id"];
    var _ts_query_string_value_for_id = Module["_ts_query_string_value_for_id"] = wasmExports["ts_query_string_value_for_id"];
    var _ts_query_predicates_for_pattern = Module["_ts_query_predicates_for_pattern"] = wasmExports["ts_query_predicates_for_pattern"];
    var _ts_query_start_byte_for_pattern = Module["_ts_query_start_byte_for_pattern"] = wasmExports["ts_query_start_byte_for_pattern"];
    var _ts_query_end_byte_for_pattern = Module["_ts_query_end_byte_for_pattern"] = wasmExports["ts_query_end_byte_for_pattern"];
    var _ts_query_is_pattern_rooted = Module["_ts_query_is_pattern_rooted"] = wasmExports["ts_query_is_pattern_rooted"];
    var _ts_query_is_pattern_non_local = Module["_ts_query_is_pattern_non_local"] = wasmExports["ts_query_is_pattern_non_local"];
    var _ts_query_is_pattern_guaranteed_at_step = Module["_ts_query_is_pattern_guaranteed_at_step"] = wasmExports["ts_query_is_pattern_guaranteed_at_step"];
    var _ts_query_disable_capture = Module["_ts_query_disable_capture"] = wasmExports["ts_query_disable_capture"];
    var _ts_query_disable_pattern = Module["_ts_query_disable_pattern"] = wasmExports["ts_query_disable_pattern"];
    var _ts_tree_copy = Module["_ts_tree_copy"] = wasmExports["ts_tree_copy"];
    var _ts_tree_delete = Module["_ts_tree_delete"] = wasmExports["ts_tree_delete"];
    var _ts_init = Module["_ts_init"] = wasmExports["ts_init"];
    var _ts_parser_new_wasm = Module["_ts_parser_new_wasm"] = wasmExports["ts_parser_new_wasm"];
    var _ts_parser_enable_logger_wasm = Module["_ts_parser_enable_logger_wasm"] = wasmExports["ts_parser_enable_logger_wasm"];
    var _ts_parser_parse_wasm = Module["_ts_parser_parse_wasm"] = wasmExports["ts_parser_parse_wasm"];
    var _ts_parser_included_ranges_wasm = Module["_ts_parser_included_ranges_wasm"] = wasmExports["ts_parser_included_ranges_wasm"];
    var _ts_language_type_is_named_wasm = Module["_ts_language_type_is_named_wasm"] = wasmExports["ts_language_type_is_named_wasm"];
    var _ts_language_type_is_visible_wasm = Module["_ts_language_type_is_visible_wasm"] = wasmExports["ts_language_type_is_visible_wasm"];
    var _ts_language_supertypes_wasm = Module["_ts_language_supertypes_wasm"] = wasmExports["ts_language_supertypes_wasm"];
    var _ts_language_subtypes_wasm = Module["_ts_language_subtypes_wasm"] = wasmExports["ts_language_subtypes_wasm"];
    var _ts_tree_root_node_wasm = Module["_ts_tree_root_node_wasm"] = wasmExports["ts_tree_root_node_wasm"];
    var _ts_tree_root_node_with_offset_wasm = Module["_ts_tree_root_node_with_offset_wasm"] = wasmExports["ts_tree_root_node_with_offset_wasm"];
    var _ts_tree_edit_wasm = Module["_ts_tree_edit_wasm"] = wasmExports["ts_tree_edit_wasm"];
    var _ts_tree_included_ranges_wasm = Module["_ts_tree_included_ranges_wasm"] = wasmExports["ts_tree_included_ranges_wasm"];
    var _ts_tree_get_changed_ranges_wasm = Module["_ts_tree_get_changed_ranges_wasm"] = wasmExports["ts_tree_get_changed_ranges_wasm"];
    var _ts_tree_cursor_new_wasm = Module["_ts_tree_cursor_new_wasm"] = wasmExports["ts_tree_cursor_new_wasm"];
    var _ts_tree_cursor_copy_wasm = Module["_ts_tree_cursor_copy_wasm"] = wasmExports["ts_tree_cursor_copy_wasm"];
    var _ts_tree_cursor_delete_wasm = Module["_ts_tree_cursor_delete_wasm"] = wasmExports["ts_tree_cursor_delete_wasm"];
    var _ts_tree_cursor_reset_wasm = Module["_ts_tree_cursor_reset_wasm"] = wasmExports["ts_tree_cursor_reset_wasm"];
    var _ts_tree_cursor_reset_to_wasm = Module["_ts_tree_cursor_reset_to_wasm"] = wasmExports["ts_tree_cursor_reset_to_wasm"];
    var _ts_tree_cursor_goto_first_child_wasm = Module["_ts_tree_cursor_goto_first_child_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_wasm"];
    var _ts_tree_cursor_goto_last_child_wasm = Module["_ts_tree_cursor_goto_last_child_wasm"] = wasmExports["ts_tree_cursor_goto_last_child_wasm"];
    var _ts_tree_cursor_goto_first_child_for_index_wasm = Module["_ts_tree_cursor_goto_first_child_for_index_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_index_wasm"];
    var _ts_tree_cursor_goto_first_child_for_position_wasm = Module["_ts_tree_cursor_goto_first_child_for_position_wasm"] = wasmExports["ts_tree_cursor_goto_first_child_for_position_wasm"];
    var _ts_tree_cursor_goto_next_sibling_wasm = Module["_ts_tree_cursor_goto_next_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_next_sibling_wasm"];
    var _ts_tree_cursor_goto_previous_sibling_wasm = Module["_ts_tree_cursor_goto_previous_sibling_wasm"] = wasmExports["ts_tree_cursor_goto_previous_sibling_wasm"];
    var _ts_tree_cursor_goto_descendant_wasm = Module["_ts_tree_cursor_goto_descendant_wasm"] = wasmExports["ts_tree_cursor_goto_descendant_wasm"];
    var _ts_tree_cursor_goto_parent_wasm = Module["_ts_tree_cursor_goto_parent_wasm"] = wasmExports["ts_tree_cursor_goto_parent_wasm"];
    var _ts_tree_cursor_current_node_type_id_wasm = Module["_ts_tree_cursor_current_node_type_id_wasm"] = wasmExports["ts_tree_cursor_current_node_type_id_wasm"];
    var _ts_tree_cursor_current_node_state_id_wasm = Module["_ts_tree_cursor_current_node_state_id_wasm"] = wasmExports["ts_tree_cursor_current_node_state_id_wasm"];
    var _ts_tree_cursor_current_node_is_named_wasm = Module["_ts_tree_cursor_current_node_is_named_wasm"] = wasmExports["ts_tree_cursor_current_node_is_named_wasm"];
    var _ts_tree_cursor_current_node_is_missing_wasm = Module["_ts_tree_cursor_current_node_is_missing_wasm"] = wasmExports["ts_tree_cursor_current_node_is_missing_wasm"];
    var _ts_tree_cursor_current_node_id_wasm = Module["_ts_tree_cursor_current_node_id_wasm"] = wasmExports["ts_tree_cursor_current_node_id_wasm"];
    var _ts_tree_cursor_start_position_wasm = Module["_ts_tree_cursor_start_position_wasm"] = wasmExports["ts_tree_cursor_start_position_wasm"];
    var _ts_tree_cursor_end_position_wasm = Module["_ts_tree_cursor_end_position_wasm"] = wasmExports["ts_tree_cursor_end_position_wasm"];
    var _ts_tree_cursor_start_index_wasm = Module["_ts_tree_cursor_start_index_wasm"] = wasmExports["ts_tree_cursor_start_index_wasm"];
    var _ts_tree_cursor_end_index_wasm = Module["_ts_tree_cursor_end_index_wasm"] = wasmExports["ts_tree_cursor_end_index_wasm"];
    var _ts_tree_cursor_current_field_id_wasm = Module["_ts_tree_cursor_current_field_id_wasm"] = wasmExports["ts_tree_cursor_current_field_id_wasm"];
    var _ts_tree_cursor_current_depth_wasm = Module["_ts_tree_cursor_current_depth_wasm"] = wasmExports["ts_tree_cursor_current_depth_wasm"];
    var _ts_tree_cursor_current_descendant_index_wasm = Module["_ts_tree_cursor_current_descendant_index_wasm"] = wasmExports["ts_tree_cursor_current_descendant_index_wasm"];
    var _ts_tree_cursor_current_node_wasm = Module["_ts_tree_cursor_current_node_wasm"] = wasmExports["ts_tree_cursor_current_node_wasm"];
    var _ts_node_symbol_wasm = Module["_ts_node_symbol_wasm"] = wasmExports["ts_node_symbol_wasm"];
    var _ts_node_field_name_for_child_wasm = Module["_ts_node_field_name_for_child_wasm"] = wasmExports["ts_node_field_name_for_child_wasm"];
    var _ts_node_field_name_for_named_child_wasm = Module["_ts_node_field_name_for_named_child_wasm"] = wasmExports["ts_node_field_name_for_named_child_wasm"];
    var _ts_node_children_by_field_id_wasm = Module["_ts_node_children_by_field_id_wasm"] = wasmExports["ts_node_children_by_field_id_wasm"];
    var _ts_node_first_child_for_byte_wasm = Module["_ts_node_first_child_for_byte_wasm"] = wasmExports["ts_node_first_child_for_byte_wasm"];
    var _ts_node_first_named_child_for_byte_wasm = Module["_ts_node_first_named_child_for_byte_wasm"] = wasmExports["ts_node_first_named_child_for_byte_wasm"];
    var _ts_node_grammar_symbol_wasm = Module["_ts_node_grammar_symbol_wasm"] = wasmExports["ts_node_grammar_symbol_wasm"];
    var _ts_node_child_count_wasm = Module["_ts_node_child_count_wasm"] = wasmExports["ts_node_child_count_wasm"];
    var _ts_node_named_child_count_wasm = Module["_ts_node_named_child_count_wasm"] = wasmExports["ts_node_named_child_count_wasm"];
    var _ts_node_child_wasm = Module["_ts_node_child_wasm"] = wasmExports["ts_node_child_wasm"];
    var _ts_node_named_child_wasm = Module["_ts_node_named_child_wasm"] = wasmExports["ts_node_named_child_wasm"];
    var _ts_node_child_by_field_id_wasm = Module["_ts_node_child_by_field_id_wasm"] = wasmExports["ts_node_child_by_field_id_wasm"];
    var _ts_node_next_sibling_wasm = Module["_ts_node_next_sibling_wasm"] = wasmExports["ts_node_next_sibling_wasm"];
    var _ts_node_prev_sibling_wasm = Module["_ts_node_prev_sibling_wasm"] = wasmExports["ts_node_prev_sibling_wasm"];
    var _ts_node_next_named_sibling_wasm = Module["_ts_node_next_named_sibling_wasm"] = wasmExports["ts_node_next_named_sibling_wasm"];
    var _ts_node_prev_named_sibling_wasm = Module["_ts_node_prev_named_sibling_wasm"] = wasmExports["ts_node_prev_named_sibling_wasm"];
    var _ts_node_descendant_count_wasm = Module["_ts_node_descendant_count_wasm"] = wasmExports["ts_node_descendant_count_wasm"];
    var _ts_node_parent_wasm = Module["_ts_node_parent_wasm"] = wasmExports["ts_node_parent_wasm"];
    var _ts_node_child_with_descendant_wasm = Module["_ts_node_child_with_descendant_wasm"] = wasmExports["ts_node_child_with_descendant_wasm"];
    var _ts_node_descendant_for_index_wasm = Module["_ts_node_descendant_for_index_wasm"] = wasmExports["ts_node_descendant_for_index_wasm"];
    var _ts_node_named_descendant_for_index_wasm = Module["_ts_node_named_descendant_for_index_wasm"] = wasmExports["ts_node_named_descendant_for_index_wasm"];
    var _ts_node_descendant_for_position_wasm = Module["_ts_node_descendant_for_position_wasm"] = wasmExports["ts_node_descendant_for_position_wasm"];
    var _ts_node_named_descendant_for_position_wasm = Module["_ts_node_named_descendant_for_position_wasm"] = wasmExports["ts_node_named_descendant_for_position_wasm"];
    var _ts_node_start_point_wasm = Module["_ts_node_start_point_wasm"] = wasmExports["ts_node_start_point_wasm"];
    var _ts_node_end_point_wasm = Module["_ts_node_end_point_wasm"] = wasmExports["ts_node_end_point_wasm"];
    var _ts_node_start_index_wasm = Module["_ts_node_start_index_wasm"] = wasmExports["ts_node_start_index_wasm"];
    var _ts_node_end_index_wasm = Module["_ts_node_end_index_wasm"] = wasmExports["ts_node_end_index_wasm"];
    var _ts_node_to_string_wasm = Module["_ts_node_to_string_wasm"] = wasmExports["ts_node_to_string_wasm"];
    var _ts_node_children_wasm = Module["_ts_node_children_wasm"] = wasmExports["ts_node_children_wasm"];
    var _ts_node_named_children_wasm = Module["_ts_node_named_children_wasm"] = wasmExports["ts_node_named_children_wasm"];
    var _ts_node_descendants_of_type_wasm = Module["_ts_node_descendants_of_type_wasm"] = wasmExports["ts_node_descendants_of_type_wasm"];
    var _ts_node_is_named_wasm = Module["_ts_node_is_named_wasm"] = wasmExports["ts_node_is_named_wasm"];
    var _ts_node_has_changes_wasm = Module["_ts_node_has_changes_wasm"] = wasmExports["ts_node_has_changes_wasm"];
    var _ts_node_has_error_wasm = Module["_ts_node_has_error_wasm"] = wasmExports["ts_node_has_error_wasm"];
    var _ts_node_is_error_wasm = Module["_ts_node_is_error_wasm"] = wasmExports["ts_node_is_error_wasm"];
    var _ts_node_is_missing_wasm = Module["_ts_node_is_missing_wasm"] = wasmExports["ts_node_is_missing_wasm"];
    var _ts_node_is_extra_wasm = Module["_ts_node_is_extra_wasm"] = wasmExports["ts_node_is_extra_wasm"];
    var _ts_node_parse_state_wasm = Module["_ts_node_parse_state_wasm"] = wasmExports["ts_node_parse_state_wasm"];
    var _ts_node_next_parse_state_wasm = Module["_ts_node_next_parse_state_wasm"] = wasmExports["ts_node_next_parse_state_wasm"];
    var _ts_query_matches_wasm = Module["_ts_query_matches_wasm"] = wasmExports["ts_query_matches_wasm"];
    var _ts_query_captures_wasm = Module["_ts_query_captures_wasm"] = wasmExports["ts_query_captures_wasm"];
    var _memset = Module["_memset"] = wasmExports["memset"];
    var _memcpy = Module["_memcpy"] = wasmExports["memcpy"];
    var _memmove = Module["_memmove"] = wasmExports["memmove"];
    var _iswalpha = Module["_iswalpha"] = wasmExports["iswalpha"];
    var _iswblank = Module["_iswblank"] = wasmExports["iswblank"];
    var _iswdigit = Module["_iswdigit"] = wasmExports["iswdigit"];
    var _iswlower = Module["_iswlower"] = wasmExports["iswlower"];
    var _iswupper = Module["_iswupper"] = wasmExports["iswupper"];
    var _iswxdigit = Module["_iswxdigit"] = wasmExports["iswxdigit"];
    var _memchr = Module["_memchr"] = wasmExports["memchr"];
    var _strlen = Module["_strlen"] = wasmExports["strlen"];
    var _strcmp = Module["_strcmp"] = wasmExports["strcmp"];
    var _strncat = Module["_strncat"] = wasmExports["strncat"];
    var _strncpy = Module["_strncpy"] = wasmExports["strncpy"];
    var _towlower = Module["_towlower"] = wasmExports["towlower"];
    var _towupper = Module["_towupper"] = wasmExports["towupper"];
    var _setThrew = wasmExports["setThrew"];
    var __emscripten_stack_restore = wasmExports["_emscripten_stack_restore"];
    var __emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"];
    var _emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"];
    var ___wasm_apply_data_relocs = wasmExports["__wasm_apply_data_relocs"];
    Module["setValue"] = setValue;
    Module["getValue"] = getValue;
    Module["UTF8ToString"] = UTF8ToString;
    Module["stringToUTF8"] = stringToUTF8;
    Module["lengthBytesUTF8"] = lengthBytesUTF8;
    Module["AsciiToString"] = AsciiToString;
    Module["stringToUTF16"] = stringToUTF16;
    Module["loadWebAssemblyModule"] = loadWebAssemblyModule;
    function callMain(args2 = []) {
      var entryFunction = resolveGlobalSymbol("main").sym;
      if (!entryFunction) return;
      args2.unshift(thisProgram);
      var argc = args2.length;
      var argv = stackAlloc((argc + 1) * 4);
      var argv_ptr = argv;
      args2.forEach((arg) => {
        LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, stringToUTF8OnStack(arg));
        argv_ptr += 4;
      });
      LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, 0);
      try {
        var ret = entryFunction(argc, argv);
        exitJS(
          ret,
          /* implicit = */
          true
        );
        return ret;
      } catch (e) {
        return handleException(e);
      }
    }
    __name(callMain, "callMain");
    function run(args2 = arguments_) {
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      preRun();
      if (runDependencies > 0) {
        dependenciesFulfilled = run;
        return;
      }
      function doRun() {
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        preMain();
        readyPromiseResolve(Module);
        Module["onRuntimeInitialized"]?.();
        var noInitialRun = Module["noInitialRun"];
        if (!noInitialRun) callMain(args2);
        postRun();
      }
      __name(doRun, "doRun");
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    __name(run, "run");
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    moduleRtn = readyPromise;
    return moduleRtn;
  };
})();
var tree_sitter_default = Module2;
var Module3 = null;
async function initializeBinding(moduleOptions) {
  if (!Module3) {
    Module3 = await tree_sitter_default(moduleOptions);
  }
  return Module3;
}
__name(initializeBinding, "initializeBinding");
function checkModule() {
  return !!Module3;
}
__name(checkModule, "checkModule");
var TRANSFER_BUFFER;
var LANGUAGE_VERSION;
var MIN_COMPATIBLE_VERSION;
var Parser = class {
  static {
    __name(this, "Parser");
  }
  /** @internal */
  [0] = 0;
  // Internal handle for WASM
  /** @internal */
  [1] = 0;
  // Internal handle for WASM
  /** @internal */
  logCallback = null;
  /** The parser's current language. */
  language = null;
  /**
   * This must always be called before creating a Parser.
   *
   * You can optionally pass in options to configure the WASM module, the most common
   * one being `locateFile` to help the module find the `.wasm` file.
   */
  static async init(moduleOptions) {
    setModule(await initializeBinding(moduleOptions));
    TRANSFER_BUFFER = C._ts_init();
    LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, "i32");
    MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /**
   * Create a new parser.
   */
  constructor() {
    this.initialize();
  }
  /** @internal */
  initialize() {
    if (!checkModule()) {
      throw new Error("cannot construct a Parser before calling `init()`");
    }
    C._ts_parser_new_wasm();
    this[0] = C.getValue(TRANSFER_BUFFER, "i32");
    this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
  }
  /** Delete the parser, freeing its resources. */
  delete() {
    C._ts_parser_delete(this[0]);
    C._free(this[1]);
    this[0] = 0;
    this[1] = 0;
  }
  /**
   * Set the language that the parser should use for parsing.
   *
   * If the language was not successfully assigned, an error will be thrown.
   * This happens if the language was generated with an incompatible
   * version of the Tree-sitter CLI. Check the language's version using
   * {@link Language#version} and compare it to this library's
   * {@link LANGUAGE_VERSION} and {@link MIN_COMPATIBLE_VERSION} constants.
   */
  setLanguage(language) {
    let address;
    if (!language) {
      address = 0;
      this.language = null;
    } else if (language.constructor === Language) {
      address = language[0];
      const version = C._ts_language_version(address);
      if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {
        throw new Error(
          `Incompatible language version ${version}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`
        );
      }
      this.language = language;
    } else {
      throw new Error("Argument must be a Language");
    }
    C._ts_parser_set_language(this[0], address);
    return this;
  }
  /**
   * Parse a slice of UTF8 text.
   *
   * @param {string | ParseCallback} callback - The UTF8-encoded text to parse or a callback function.
   *
   * @param {Tree | null} [oldTree] - A previous syntax tree parsed from the same document. If the text of the
   *   document has changed since `oldTree` was created, then you must edit `oldTree` to match
   *   the new text using {@link Tree#edit}.
   *
   * @param {ParseOptions} [options] - Options for parsing the text.
   *  This can be used to set the included ranges, or a progress callback.
   *
   * @returns {Tree | null} A {@link Tree} if parsing succeeded, or `null` if:
   *  - The parser has not yet had a language assigned with {@link Parser#setLanguage}.
   *  - The progress callback returned true.
   */
  parse(callback, oldTree, options) {
    if (typeof callback === "string") {
      C.currentParseCallback = (index) => callback.slice(index);
    } else if (typeof callback === "function") {
      C.currentParseCallback = callback;
    } else {
      throw new Error("Argument must be a string or a function");
    }
    if (options?.progressCallback) {
      C.currentProgressCallback = options.progressCallback;
    } else {
      C.currentProgressCallback = null;
    }
    if (this.logCallback) {
      C.currentLogCallback = this.logCallback;
      C._ts_parser_enable_logger_wasm(this[0], 1);
    } else {
      C.currentLogCallback = null;
      C._ts_parser_enable_logger_wasm(this[0], 0);
    }
    let rangeCount = 0;
    let rangeAddress = 0;
    if (options?.includedRanges) {
      rangeCount = options.includedRanges.length;
      rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE);
      let address = rangeAddress;
      for (let i22 = 0; i22 < rangeCount; i22++) {
        marshalRange(address, options.includedRanges[i22]);
        address += SIZE_OF_RANGE;
      }
    }
    const treeAddress = C._ts_parser_parse_wasm(
      this[0],
      this[1],
      oldTree ? oldTree[0] : 0,
      rangeAddress,
      rangeCount
    );
    if (!treeAddress) {
      C.currentParseCallback = null;
      C.currentLogCallback = null;
      C.currentProgressCallback = null;
      return null;
    }
    if (!this.language) {
      throw new Error("Parser must have a language to parse");
    }
    const result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback);
    C.currentParseCallback = null;
    C.currentLogCallback = null;
    C.currentProgressCallback = null;
    return result;
  }
  /**
   * Instruct the parser to start the next parse from the beginning.
   *
   * If the parser previously failed because of a timeout, cancellation,
   * or callback, then by default, it will resume where it left off on the
   * next call to {@link Parser#parse} or other parsing functions.
   * If you don't want to resume, and instead intend to use this parser to
   * parse some other document, you must call `reset` first.
   */
  reset() {
    C._ts_parser_reset(this[0]);
  }
  /** Get the ranges of text that the parser will include when parsing. */
  getIncludedRanges() {
    C._ts_parser_included_ranges_wasm(this[0]);
    const count = C.getValue(TRANSFER_BUFFER, "i32");
    const buffer2 = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
    const result = new Array(count);
    if (count > 0) {
      let address = buffer2;
      for (let i22 = 0; i22 < count; i22++) {
        result[i22] = unmarshalRange(address);
        address += SIZE_OF_RANGE;
      }
      C._free(buffer2);
    }
    return result;
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Get the duration in microseconds that parsing is allowed to take.
   *
   * This is set via {@link Parser#setTimeoutMicros}.
   */
  getTimeoutMicros() {
    return C._ts_parser_timeout_micros(this[0]);
  }
  /**
   * @deprecated since version 0.25.0, prefer passing a progress callback to {@link Parser#parse}
   *
   * Set the maximum duration in microseconds that parsing should be allowed
   * to take before halting.
   *
   * If parsing takes longer than this, it will halt early, returning `null`.
   * See {@link Parser#parse} for more information.
   */
  setTimeoutMicros(timeout) {
    C._ts_parser_set_timeout_micros(this[0], 0, timeout);
  }
  /** Set the logging callback that a parser should use during parsing. */
  setLogger(callback) {
    if (!callback) {
      this.logCallback = null;
    } else if (typeof callback !== "function") {
      throw new Error("Logger callback must be a function");
    } else {
      this.logCallback = callback;
    }
    return this;
  }
  /** Get the parser's current logger. */
  getLogger() {
    return this.logCallback;
  }
};

// dist/jvm-reachability-analyzer.js
import { extname as extname4 } from "node:path";

// dist/class-graph/tree-sitter-utils.js
function cursorHasChildOfType(cursor, type, subtypeMap) {
  if (cursor.gotoFirstChild()) {
    do {
      if (isSubtype(cursor.nodeType, type, subtypeMap)) {
        cursor.gotoParent();
        return true;
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return false;
}
function cursorGoToChildOfFieldName(cursor, fieldName) {
  if (cursor.gotoFirstChild()) {
    do {
      if (cursor.currentFieldName === fieldName) {
        return true;
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return false;
}
function cursorGoToChildOfType(cursor, type, subtypeMap) {
  if (cursor.gotoFirstChild()) {
    do {
      if (isSubtype(cursor.nodeType, type, subtypeMap)) {
        return true;
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return false;
}
function cursorGoToSiblingOfType(cursor, type, subtypeMap) {
  while (cursor.gotoNextSibling()) {
    if (isSubtype(cursor.nodeType, type, subtypeMap)) {
      return true;
    }
  }
  return false;
}
function cursorGoToSiblingOfFieldName(cursor, fieldName) {
  while (cursor.gotoNextSibling()) {
    if (cursor.currentFieldName === fieldName) {
      return true;
    }
  }
  return false;
}
function cursorChildForFieldNameText(cursor, fieldName) {
  if (cursor.gotoFirstChild()) {
    do {
      if (cursor.currentFieldName === fieldName) {
        const text = cursor.nodeText;
        cursor.gotoParent();
        return text;
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return void 0;
}
function cursorChildForTypeText(cursor, type, subtypeMap) {
  if (cursor.gotoFirstChild()) {
    do {
      if (subtypeMap && isSubtype(cursor.nodeType, type, subtypeMap)) {
        const text = cursor.nodeText;
        cursor.gotoParent();
        return text;
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return void 0;
}
function cursorChildrenForFieldNameText(cursor, fieldName) {
  const texts = [];
  if (cursor.gotoFirstChild()) {
    do {
      if (cursor.currentFieldName === fieldName) {
        texts.push(cursor.nodeText);
      }
    } while (cursor.gotoNextSibling());
    cursor.gotoParent();
  }
  return texts.length ? texts : void 0;
}
function walkTreeToIndex(tree, targetDescendantIndex, cb) {
  const root = tree.walk();
  const cursor = tree.walk();
  while (true) {
    const currentDescendantIndex = cursor.currentDescendantIndex;
    if (cursor.nodeIsNamed) {
      cb(cursor);
      cursor.resetTo(root);
      cursor.gotoDescendant(currentDescendantIndex);
    }
    if (currentDescendantIndex === targetDescendantIndex) {
      return cursor;
    }
    if (cursor.gotoNextSibling()) {
      if (cursor.currentDescendantIndex <= targetDescendantIndex) {
        continue;
      }
      cursor.resetTo(root);
      cursor.gotoDescendant(currentDescendantIndex);
    }
    if (cursor.gotoFirstChild()) {
      continue;
    }
    return void 0;
  }
}
function isSubtype(a, b, subtypeMap) {
  return a === b || !!subtypeMap.get(b)?.has(a);
}
function stringifyCursorPosition(cursor) {
  return `(${cursor.startPosition.row}, ${cursor.startPosition.column}) - (${cursor.endPosition.row}, ${cursor.endPosition.column})`;
}

// dist/class-graph/resolvers/constants.js
var TYPE_REFERENCE_CONFIDENCE = 1;
var REFLECTION_CONFIDENCE = 0.8;

// dist/class-graph/jvm/java-source-resolver.js
import { basename, extname } from "node:path";

// dist/class-graph/resolvers/abstract-tree-sitter-source-resolver.js
import { join } from "node:path";
import { readFile } from "node:fs/promises";

// dist/class-graph/resolvers/abstract-source-resolver.js
var AbstractSourceResolver = class {
  containerToFileToNodeIds = /* @__PURE__ */ new Map();
};

// dist/class-graph/resolvers/abstract-tree-sitter-source-resolver.js
var AbstractTreeSitterSourceResolver = class extends AbstractSourceResolver {
  parser;
  subtypeMap;
  nodeIdToTreeIndes = /* @__PURE__ */ new Map();
  constructor(parser2, subtypeMap) {
    super();
    this.parser = parser2;
    this.subtypeMap = subtypeMap;
  }
  /**
   * Type-safe record function that creates nodes with additional properties.
   * Subclasses provide the additional properties needed for their specific node type.
   */
  record(packageId, container, file, fullyQualifiedName, cursor, graph, additionalProps = {}) {
    const nodeId = `${packageId}#${container}#${file}#${fullyQualifiedName}#${stringifyCursorPosition(cursor)}`;
    const baseNode = {
      fullyQualifiedName,
      nodeId,
      packageId,
      container,
      file,
      nodeType: "type",
      resolutionType: "src"
    };
    const node = { ...baseNode, ...additionalProps };
    const nodeIndex = graph.addNode(node);
    if (nodeIndex !== void 0) {
      if (!this.containerToFileToNodeIds.has(container)) {
        this.containerToFileToNodeIds.set(container, /* @__PURE__ */ new Map());
      }
      const fileToNodeIds = this.containerToFileToNodeIds.get(container);
      if (!fileToNodeIds.has(file)) {
        fileToNodeIds.set(file, []);
      }
      fileToNodeIds.get(file).push(nodeId);
      this.nodeIdToTreeIndes.set(nodeId, cursor.currentDescendantIndex);
    }
    return nodeIndex;
  }
  /**
   * Parse a file and add declaration nodes to the graph. Handles tree lifecycle automatically.
   */
  async getDeclarationNodes(packageId, container, file, ecosystemSpecificPackageInfo, graph) {
    const tree = this.parser.parse(await readFile(join(container, file), "utf-8"));
    if (!tree)
      return;
    try {
      await this.parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph);
    } finally {
      tree.delete();
    }
  }
  /**
   * Parse a file and add definition nodes to the graph (if implemented). Handles tree lifecycle automatically.
   */
  async getDefinitionNodes(packageId, container, file, resolutionContext, ecosystemSpecificPackageInfo, graph) {
    if (!this.parseDefinitionNodes) {
      return;
    }
    const tree = this.parser.parse(await readFile(join(container, file), "utf-8"));
    if (!tree)
      return;
    try {
      await this.parseDefinitionNodes(packageId, container, file, tree, resolutionContext, ecosystemSpecificPackageInfo, graph);
    } finally {
      tree.delete();
    }
  }
  /**
   * Parse a file and add edges to the graph. Handles tree lifecycle automatically.
   */
  async getEdges(node, resolutionContext, graph) {
    const tree = this.parser.parse(await readFile(join(node.container, node.file), "utf-8"));
    if (!tree)
      return;
    try {
      await this.parseEdges(node, tree, resolutionContext, graph);
    } finally {
      tree.delete();
    }
  }
};

// dist/class-graph/import-utils.js
function resolveImport(target, importsMap, separator = ".") {
  const [first, ...rest] = target.split(separator);
  return importsMap.get(first)?.map((resolvedFirst) => [resolvedFirst, ...rest].join(separator)) ?? [target];
}
function copyImportsMap(src) {
  return new Map([...src].map(([key, value]) => [key, [...value]]));
}

// dist/class-graph/jvm/java-source-resolver.js
var JavaSourceResolver = class extends AbstractTreeSitterSourceResolver {
  constructor(parser2, subtypeMap) {
    super(parser2, subtypeMap);
  }
  async parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph) {
    if (ecosystemSpecificPackageInfo.type !== "JVM")
      return;
    function getFullyQualifiedName(context) {
      const packageName = context.packageParts.join(".");
      const className = context.classParts.join("$") || basename(file, extname(file));
      return packageName ? `${packageName}.${className}` : className;
    }
    const contextStack = [
      {
        packageParts: [],
        classParts: [],
        importsMap: /* @__PURE__ */ new Map(),
        maybeReferences: []
      }
    ];
    const cursor = tree.walk();
    this.record(packageId, container, file, getFullyQualifiedName(contextStack[0]), cursor, graph);
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext(oldContext, cursor, this.subtypeMap);
      switch (cursor.nodeType) {
        case "class_declaration":
        case "interface_declaration":
        case "record_declaration":
        case "enum_declaration":
        case "annotation_type_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          break;
        }
        case "package_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          contextStack[contextStack.length - 1] = newContext;
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
    tree.delete();
  }
  async parseEdges(requestedNode, tree, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    for (const nodeId of this.containerToFileToNodeIds.get(requestedNode.container)?.get(requestedNode.file) ?? []) {
      const idx = resolutionContext.nodeIdToIndex.get(nodeId);
      if (idx === void 0 || resolutionContext.visited.has(idx) || resolutionContext.nodes[idx].resolutionType !== "src") {
        continue;
      }
      resolutionContext.visited.add(idx);
      const resolveNode = resolutionContext.nodes[idx];
      this.getEdgesForNode(tree, resolveNode, resolutionContext, graph);
    }
  }
  getEdgesForNode(tree, fromNode, jvmResolutionContext, graph) {
    const fromIdx = jvmResolutionContext.nodeIdToIndex.get(fromNode.nodeId);
    if (fromIdx === void 0)
      return;
    function addReference(fromIdx2, toIdx, confidence) {
      graph.addEdge(fromIdx2, toIdx, confidence);
    }
    const [fqnOfEnclosingClass] = fromNode.fullyQualifiedName.split("$");
    for (const toIdx of jvmResolutionContext.nestedClassMap.get(fqnOfEnclosingClass) ?? []) {
      if (fromIdx !== toIdx) {
        addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
      }
    }
    const packageName = fqnOfEnclosingClass.split(".").slice(0, -1).join(".");
    const packageImportsMap = new Map(Array.from(jvmResolutionContext.childMap.get(packageName) ?? []).map((child) => [
      child,
      [`${packageName}.${child}`]
    ]));
    let initialContext = {
      packageParts: [],
      classParts: [],
      importsMap: packageImportsMap,
      maybeReferences: []
    };
    const updateInitialContextCB = (cursor2) => {
      initialContext = getUpdatedContext(initialContext, cursor2, this.subtypeMap, jvmResolutionContext.childMap);
    };
    const treeIndex = this.nodeIdToTreeIndes.get(fromNode.nodeId);
    if (treeIndex === void 0)
      return void 0;
    const cursor = walkTreeToIndex(tree, treeIndex, updateInitialContextCB);
    if (!cursor)
      return void 0;
    const contextStack = [initialContext];
    let done = false;
    let start2 = true;
    let startedBefore = false;
    while (!done) {
      let addReferencesToName2 = function(fromIdx2, fqnOrSimpleName) {
        function tryAdd(fqn) {
          let added = false;
          for (const toIdx of jvmResolutionContext.fqnMap.get(fqn) ?? []) {
            addReference(fromIdx2, toIdx, TYPE_REFERENCE_CONFIDENCE);
            added = true;
          }
          for (const toIdx of jvmResolutionContext.reflectionMap.get(fqn) ?? []) {
            addReference(fromIdx2, toIdx, REFLECTION_CONFIDENCE);
            added = true;
          }
          return added;
        }
        if (!fqnOrSimpleName)
          return;
        for (const resolvedFqn of resolveImport(fqnOrSimpleName, currentContext.importsMap)) {
          if (!tryAdd(resolvedFqn)) {
            const fqnParts = resolvedFqn.split(".");
            if (fqnParts.length > 1) {
              const parentFqn = fqnParts.slice(0, -1).join(".");
              tryAdd(parentFqn);
            }
          }
        }
      };
      var addReferencesToName = addReferencesToName2;
      start2 &&= !startedBefore;
      startedBefore = true;
      const currentContext = contextStack[contextStack.length - 1];
      for (const fqn of currentContext.maybeReferences) {
        for (const toIdx of jvmResolutionContext.fqnMap.get(fqn) ?? []) {
          addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
        }
      }
      switch (cursor.nodeType) {
        case "type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "scoped_identifier":
        case "scoped_type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName(cursor));
          const parts2 = cursor.nodeText.split(".");
          if (parts2.length > 1) {
            addReferencesToName2(fromIdx, parts2.slice(0, -1).join("."));
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "method_invocation": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "object") ?? cursorChildForFieldNameText(cursor, "name"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "field_access": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "object"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "object_creation_expression":
        case "cast_expression": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "type"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "instanceof_expression": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "right"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "annotation":
        case "marker_annotation": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "name"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "string_literal": {
          const str = parseJavaString(cursor.nodeText);
          for (const toIdx of jvmResolutionContext.reflectionMap.get(str) ?? []) {
            addReference(fromIdx, toIdx, REFLECTION_CONFIDENCE);
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "import_declaration": {
          contextStack[contextStack.length - 1] = getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
          break;
        }
        case "class_declaration":
        case "interface_declaration":
        case "record_declaration":
        case "enum_declaration":
        case "annotation_type_declaration": {
          if (start2) {
            if (cursor.gotoFirstChild()) {
              contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            } else {
              done = true;
            }
            continue;
          }
          break;
        }
        case "package_declaration": {
          if (start2) {
            contextStack[contextStack.length - 1] = getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
          } else {
            contextStack.pop();
            if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
              done = true;
              break;
            }
          }
          break;
        }
        default: {
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
          done = true;
          break;
        }
      }
    }
  }
};
function getUpdatedContext(oldContext, cursor, subtypeMap, childMap) {
  const newContext = { ...oldContext };
  function processImportDeclaration(cursor2) {
    const path2 = cursorChildForTypeText(cursor2, "scoped_identifier", subtypeMap) ?? cursorChildForTypeText(cursor2, "identifier", subtypeMap);
    if (!path2)
      return;
    newContext.importsMap = copyImportsMap(newContext.importsMap);
    const isWildcard = cursorHasChildOfType(cursor2, "asterisk", subtypeMap);
    if (isWildcard) {
      childMap?.get(path2)?.forEach((child) => {
        newContext.importsMap.set(child, [`${path2}.${child}`]);
      });
      newContext.maybeReferences = newContext.maybeReferences.concat(path2);
    } else {
      const simpleName = path2.split(".").pop();
      if (simpleName) {
        newContext.importsMap.set(simpleName, [path2]);
      }
    }
  }
  switch (cursor.nodeType) {
    case "class_declaration":
    case "interface_declaration":
    case "record_declaration":
    case "enum_declaration":
    case "annotation_type_declaration": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      if (name2) {
        newContext.classParts = newContext.classParts.concat(name2);
      }
      break;
    }
    case "package_declaration": {
      const name2 = cursorChildForTypeText(cursor, "scoped_identifier", subtypeMap) ?? cursorChildForTypeText(cursor, "identifier", subtypeMap);
      if (name2) {
        newContext.packageParts = newContext.packageParts.concat(name2);
        newContext.classParts = [];
      }
      break;
    }
    case "import_declaration": {
      processImportDeclaration(cursor);
      break;
    }
  }
  return newContext;
}
function sanitizeName(cursor) {
  switch (cursor.nodeType) {
    case "identifier":
    case "type_identifier": {
      return cursor.nodeText;
    }
    case "scoped_identifier":
    case "scoped_type_identifier": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "generic_type": {
      if (cursor.gotoFirstChild()) {
        const baseName = sanitizeName(cursor);
        cursor.gotoParent();
        return baseName;
      }
      return cursor.nodeText;
    }
    case "array_type": {
      if (cursorGoToChildOfFieldName(cursor, "element")) {
        const baseType = sanitizeName(cursor);
        cursor.gotoParent();
        return baseType;
      } else if (cursor.gotoFirstChild()) {
        const baseType = sanitizeName(cursor);
        cursor.gotoParent();
        return baseType;
      }
      return cursor.nodeText;
    }
    case "integral_type":
    case "floating_point_type":
    case "boolean_type":
    case "void_type": {
      return cursor.nodeText;
    }
    default:
      return cursor.nodeText;
  }
}
function parseJavaString(input) {
  if (input.startsWith('"""') && input.endsWith('"""')) {
    return input.slice(3, -3);
  }
  if (input.startsWith('"') && input.endsWith('"')) {
    return input.slice(1, -1);
  }
  return input;
}

// dist/class-graph/jvm/kotlin-source-resolver.js
import { basename as basename2, extname as extname2 } from "node:path";
var KotlinSourceResolver = class extends AbstractTreeSitterSourceResolver {
  constructor(parser2, subtypeMap) {
    super(parser2, subtypeMap);
  }
  async parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph) {
    if (ecosystemSpecificPackageInfo.type !== "JVM")
      return;
    function getFullyQualifiedName(context) {
      const packageName = context.packageParts.join(".") || void 0;
      const className = context.classParts.join("$") || `${basename2(file, extname2(file))}Kt`;
      return packageName ? `${packageName}.${className}` : className;
    }
    const contextStack = [
      {
        packageParts: [],
        classParts: [],
        importsMap: /* @__PURE__ */ new Map(),
        maybeReferences: []
      }
    ];
    const cursor = tree.walk();
    this.record(packageId, container, file, getFullyQualifiedName(contextStack[0]), cursor, graph);
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext2(oldContext, cursor, this.subtypeMap);
      switch (cursor.nodeType) {
        case "top_level_objects":
        case "class_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          break;
        }
        case "package_header": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          contextStack[contextStack.length - 1] = newContext;
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
    tree.delete();
  }
  async parseEdges(requestedNode, tree, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    for (const nodeId of this.containerToFileToNodeIds.get(requestedNode.container)?.get(requestedNode.file) ?? []) {
      const idx = resolutionContext.nodeIdToIndex.get(nodeId);
      if (idx === void 0 || resolutionContext.visited.has(idx) || resolutionContext.nodes[idx].resolutionType !== "src") {
        continue;
      }
      resolutionContext.visited.add(idx);
      const resolveNode = resolutionContext.nodes[idx];
      this.getEdgesForNode(tree, resolveNode, resolutionContext, graph);
    }
  }
  getEdgesForNode(tree, fromNode, jvmResolutionContext, graph) {
    const fromIdx = jvmResolutionContext.nodeIdToIndex.get(fromNode.nodeId);
    if (fromIdx === void 0)
      return;
    function addReference(fromIdx2, toIdx, confidence) {
      graph.addEdge(fromIdx2, toIdx, confidence);
    }
    const [fqnOfEnclosingClass] = fromNode.fullyQualifiedName.split("$");
    for (const toIdx of jvmResolutionContext.nestedClassMap.get(fqnOfEnclosingClass) ?? []) {
      if (fromIdx !== toIdx) {
        addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
      }
    }
    const packageName = fqnOfEnclosingClass.split(".").slice(0, -1).join(".");
    const packageImportsMap = new Map(Array.from(jvmResolutionContext.childMap.get(packageName) ?? []).map((child) => [
      child,
      [`${packageName}.${child}`]
    ]));
    let initialContext = {
      packageParts: [],
      classParts: [],
      importsMap: packageImportsMap,
      maybeReferences: []
    };
    const updateInitialContextCB = (cursor2) => {
      initialContext = getUpdatedContext2(initialContext, cursor2, this.subtypeMap, jvmResolutionContext.childMap);
    };
    const treeIndex = this.nodeIdToTreeIndes.get(fromNode.nodeId);
    if (treeIndex === void 0)
      return void 0;
    const cursor = walkTreeToIndex(tree, treeIndex, updateInitialContextCB);
    if (!cursor)
      return void 0;
    const contextStack = [initialContext];
    let done = false;
    let start2 = true;
    let startedBefore = false;
    while (!done) {
      let addReferencesToName2 = function(fromIdx2, fqnOrSimpleName) {
        function tryAdd(fqn) {
          let added = false;
          const variants = [fqn, `${fqn}.Companion`];
          for (const variant of variants) {
            for (const toIdx of jvmResolutionContext.fqnMap.get(variant) ?? []) {
              addReference(fromIdx2, toIdx, TYPE_REFERENCE_CONFIDENCE);
              added = true;
            }
            for (const toIdx of [...jvmResolutionContext.reflectionMap.get(variant) ?? []]) {
              addReference(fromIdx2, toIdx, REFLECTION_CONFIDENCE);
              added = true;
            }
          }
          return added;
        }
        if (!fqnOrSimpleName)
          return;
        for (const resolvedFqn of resolveImport(fqnOrSimpleName, currentContext.importsMap)) {
          if (!tryAdd(resolvedFqn)) {
            const fqnParts = resolvedFqn.split(".");
            if (fqnParts.length > 1) {
              const parentFqn = fqnParts.slice(0, -1).join(".");
              tryAdd(parentFqn);
            }
          }
        }
      };
      var addReferencesToName = addReferencesToName2;
      start2 &&= !startedBefore;
      startedBefore = true;
      const currentContext = contextStack[contextStack.length - 1];
      for (const fqn of currentContext.maybeReferences) {
        for (const toIdx of jvmResolutionContext.fqnMap.get(fqn) ?? []) {
          addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
        }
      }
      switch (cursor.nodeType) {
        case "type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName2(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "call_expression": {
          if (cursor.gotoFirstChild()) {
            addReferencesToName2(fromIdx, sanitizeName2(cursor));
            contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "navigation_expression": {
          addReferencesToName2(fromIdx, sanitizeName2(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "string_literal": {
          const str = parseKotlinString(cursor.nodeText);
          for (const toIdx of [...jvmResolutionContext.reflectionMap.get(str) ?? []]) {
            addReference(fromIdx, toIdx, REFLECTION_CONFIDENCE);
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "import_declaration": {
          contextStack[contextStack.length - 1] = getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
          break;
        }
        case "top_level_objects":
        case "class_declaration": {
          if (start2) {
            if (cursor.gotoFirstChild()) {
              contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            } else {
              done = true;
            }
            continue;
          }
          break;
        }
        case "package_header": {
          if (start2) {
            contextStack[contextStack.length - 1] = getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
          } else {
            contextStack.pop();
            if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
              done = true;
              break;
            }
          }
          break;
        }
        default: {
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext2(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
          done = true;
          break;
        }
      }
    }
  }
};
function getUpdatedContext2(oldContext, cursor, subtypeMap, childMap) {
  const newContext = { ...oldContext };
  function processImportHeader(cursor2) {
    const path2 = cursorChildForTypeText(cursor2, "identifier", subtypeMap);
    if (!path2)
      return;
    newContext.importsMap = copyImportsMap(newContext.importsMap);
    const isWildcard = cursorHasChildOfType(cursor2, "wildcard_import", subtypeMap);
    if (isWildcard) {
      childMap?.get(path2)?.forEach((child) => {
        newContext.importsMap.set(child, [`${path2}.${child}`]);
      });
      newContext.maybeReferences = newContext.maybeReferences.concat([path2, `${path2}.Companion`]);
    } else if (cursorGoToChildOfType(cursor2, "import_alias", subtypeMap)) {
      const alias = cursorChildForTypeText(cursor2, "type_identifier", subtypeMap);
      if (alias && alias !== "_") {
        newContext.importsMap.set(alias, [path2]);
      }
      cursor2.gotoParent();
    } else {
      const simpleName = path2.split(".").pop();
      if (simpleName) {
        newContext.importsMap.set(simpleName, [path2]);
      }
    }
  }
  switch (cursor.nodeType) {
    case "class_declaration":
    case "object_declaration": {
      const name2 = cursorChildForTypeText(cursor, "type_identifier", subtypeMap);
      if (name2) {
        newContext.classParts = newContext.classParts.concat(name2);
      }
      break;
    }
    case "package_header": {
      const name2 = cursorChildForTypeText(cursor, "identifier", subtypeMap);
      if (name2) {
        newContext.packageParts = newContext.packageParts.concat(name2);
        newContext.classParts = [];
      }
      break;
    }
    case "import_list": {
      if (cursor.gotoFirstChild()) {
        do {
          switch (cursor.nodeType) {
            case "import_header": {
              processImportHeader(cursor);
              break;
            }
          }
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
      }
      break;
    }
  }
  return newContext;
}
function sanitizeName2(cursor) {
  switch (cursor.nodeType) {
    case "simple_identifier":
    case "type_identifier": {
      return cursor.nodeText;
    }
    case "identifier": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName2(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "user_type": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName2(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "type_arguments": {
      return "";
    }
    case "nullable_type": {
      if (cursor.gotoFirstChild()) {
        const baseType = sanitizeName2(cursor);
        cursor.gotoParent();
        return baseType;
      }
      return cursor.nodeText;
    }
    default:
      return cursor.nodeText;
  }
}
function parseKotlinString(input) {
  if (input.startsWith('"""') && input.endsWith('"""')) {
    return input.slice(3, -3);
  }
  if (input.startsWith('"') && input.endsWith('"')) {
    return input.slice(1, -1);
  }
  return input;
}

// dist/class-graph/jvm/properties-source-resolver.js
import { readFile as readFile2 } from "node:fs/promises";

// dist/class-graph/resolvers/abstract-reflective-source-resolver.js
var AbstractReflectiveSourceResolver = class extends AbstractSourceResolver {
  getNodeId(packageId, container, file, key, start2, end) {
    return `${packageId}#${container}#${file}#${key}@${start2}-${end}`;
  }
  record(packageId, container, file, key, graph, start2, end) {
    const nodeId = this.getNodeId(packageId, container, file, key, start2, end);
    const node = {
      packageId,
      nodeId,
      container,
      file,
      fullyQualifiedName: key,
      // Use the reflective key as the FQN
      nodeType: "reflective",
      resolutionType: "src"
    };
    const nodeIndex = graph.addNode(node);
    if (nodeIndex !== void 0) {
      if (!this.containerToFileToNodeIds.has(container)) {
        this.containerToFileToNodeIds.set(container, /* @__PURE__ */ new Map());
      }
      const fileToNodeIds = this.containerToFileToNodeIds.get(container);
      if (!fileToNodeIds.has(file)) {
        fileToNodeIds.set(file, []);
      }
      fileToNodeIds.get(file).push(nodeId);
    }
    return nodeIndex;
  }
};

// dist/class-graph/jvm/properties-source-resolver.js
import { join as join2 } from "node:path";
var PropertiesSourceResolver = class extends AbstractReflectiveSourceResolver {
  async getDeclarationNodes(packageId, container, file, _ecosystemSpecificPackageInfo, graph) {
    const content = await readFile2(join2(container, file), "utf-8");
    const lines = content.split("\n");
    let byteOffset = 0;
    for (let i3 = 0; i3 < lines.length; i3++) {
      const line = lines[i3];
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const [key] = trimmedLine.split("=");
        if (key) {
          const keyStartInLine = line.indexOf(key.trim());
          const keyStart = byteOffset + keyStartInLine;
          const keyEnd = keyStart + key.trim().length;
          this.record(packageId, container, file, key, graph, keyStart, keyEnd);
        }
      }
      byteOffset += line.length + 1;
    }
  }
  async getEdges(requestedNode, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    const jvmResolutionContext = resolutionContext;
    const content = await readFile2(join2(requestedNode.container, requestedNode.file), "utf-8");
    const lines = content.split("\n");
    let byteOffset = 0;
    for (let i3 = 0; i3 < lines.length; i3++) {
      const line = lines[i3];
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const [key, value] = trimmedLine.split("=");
        if (key && value) {
          const keyStartInLine = line.indexOf(key.trim());
          const keyStart = byteOffset + keyStartInLine;
          const keyEnd = keyStart + key.trim().length;
          const nodeId = this.getNodeId(requestedNode.packageId, requestedNode.container, requestedNode.file, key, keyStart, keyEnd);
          const fromIdx = jvmResolutionContext.nodeIdToIndex.get(nodeId);
          if (fromIdx !== void 0) {
            const toIndices = jvmResolutionContext.fqnMap.get(value.trim()) ?? jvmResolutionContext.reflectionMap.get(value.trim()) ?? [];
            for (const toIdx of toIndices) {
              graph.addEdge(fromIdx, toIdx, REFLECTION_CONFIDENCE);
            }
          }
        }
      }
      byteOffset += line.length + 1;
    }
  }
};

// dist/class-graph/jvm/scala-source-resolver.js
import { basename as basename3, extname as extname3 } from "node:path";
var ScalaSourceResolver = class extends AbstractTreeSitterSourceResolver {
  constructor(parser2, subtypeMap) {
    super(parser2, subtypeMap);
  }
  async parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph) {
    if (ecosystemSpecificPackageInfo.type !== "JVM")
      return;
    function getFullyQualifiedName(context) {
      const packageName = context.packageParts.join(".") || basename3(file, extname3(file));
      const className = context.classParts.join("$").replaceAll("$$", "$") || "package$";
      return `${packageName}.${className}`;
    }
    const contextStack = [
      {
        packageParts: [],
        classParts: [],
        importsMap: /* @__PURE__ */ new Map(),
        maybeReferences: []
      }
    ];
    const cursor = tree.walk();
    this.record(packageId, container, file, getFullyQualifiedName(contextStack[0]), cursor, graph);
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext3(oldContext, cursor, this.subtypeMap);
      switch (cursor.nodeType) {
        case "compilation_unit":
        case "class_definition":
        case "object_definition":
        case "package_object":
        case "trait_definition":
        case "full_enum_case": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          break;
        }
        case "package_clause": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          if (!cursorHasChildOfType(cursor, "package_body", this.subtypeMap)) {
            contextStack[contextStack.length - 1] = newContext;
          }
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
    tree.delete();
  }
  async parseEdges(requestedNode, tree, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    for (const nodeId of this.containerToFileToNodeIds.get(requestedNode.container)?.get(requestedNode.file) ?? []) {
      const idx = resolutionContext.nodeIdToIndex.get(nodeId);
      if (idx === void 0 || resolutionContext.visited.has(idx) || resolutionContext.nodes[idx].resolutionType !== "src") {
        continue;
      }
      resolutionContext.visited.add(idx);
      const node = resolutionContext.nodes[idx];
      this.getEdgesForNode(tree, node, resolutionContext, graph);
    }
  }
  getEdgesForNode(tree, fromNode, jvmResolutionContext, graph) {
    const fromIdx = jvmResolutionContext.nodeIdToIndex.get(fromNode.nodeId);
    if (fromIdx === void 0)
      return;
    function addReference(fromIdx2, toIdx, confidence) {
      graph.addEdge(fromIdx2, toIdx, confidence);
    }
    const [fqnOfEnclosingClass] = fromNode.fullyQualifiedName.split("$");
    for (const toIdx of jvmResolutionContext.nestedClassMap.get(fqnOfEnclosingClass) ?? []) {
      if (fromIdx !== toIdx) {
        addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
      }
    }
    const packageName = fqnOfEnclosingClass.split(".").slice(0, -1).join(".");
    const packageImportsMap = new Map(Array.from(jvmResolutionContext.childMap.get(packageName) ?? []).map((child) => [
      child,
      [`${packageName}.${child}`]
    ]));
    let initialContext = {
      packageParts: [],
      classParts: [],
      importsMap: packageImportsMap,
      maybeReferences: []
    };
    const updateInitialContextCB = (cursor2) => {
      initialContext = getUpdatedContext3(initialContext, cursor2, this.subtypeMap, jvmResolutionContext.childMap);
    };
    const treeIndex = this.nodeIdToTreeIndes.get(fromNode.nodeId);
    if (treeIndex === void 0)
      return void 0;
    const cursor = walkTreeToIndex(tree, treeIndex, updateInitialContextCB);
    if (!cursor)
      return void 0;
    const contextStack = [initialContext];
    let done = false;
    let start2 = true;
    let startedBefore = false;
    while (!done) {
      let addReferencesToName2 = function(fromIdx2, fqnOrSimpleName) {
        function tryAdd(fqn) {
          let added = false;
          const variants = fqn.endsWith("$") ? [fqn] : [fqn, `${fqn}$`, `${fqn}.package`, `${fqn}.package$`];
          for (const variant of variants) {
            for (const toIdx of jvmResolutionContext.fqnMap.get(variant) ?? []) {
              addReference(fromIdx2, toIdx, TYPE_REFERENCE_CONFIDENCE);
              added = true;
            }
            for (const toIdx of [...jvmResolutionContext.reflectionMap.get(variant) ?? []]) {
              addReference(fromIdx2, toIdx, REFLECTION_CONFIDENCE);
              added = true;
            }
          }
          return added;
        }
        if (!fqnOrSimpleName)
          return;
        for (const resolvedFqn of resolveImport(fqnOrSimpleName, currentContext.importsMap)) {
          if (!tryAdd(resolvedFqn)) {
            const fqnParts = resolvedFqn.split(".");
            if (fqnParts.length > 1) {
              const parentFqn = fqnParts.slice(0, -1).join(".");
              tryAdd(parentFqn);
            }
          }
        }
      };
      var addReferencesToName = addReferencesToName2;
      start2 &&= !startedBefore;
      startedBefore = true;
      const currentContext = contextStack[contextStack.length - 1];
      for (const fqn of currentContext.maybeReferences) {
        for (const toIdx of jvmResolutionContext.fqnMap.get(fqn) ?? []) {
          addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
        }
      }
      switch (cursor.nodeType) {
        case "type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName3(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "stable_identifier":
        case "stable_type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName3(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "call_expression":
        case "colon_call_expression": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "function"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "field_expression": {
          addReferencesToName2(fromIdx, cursorChildForFieldNameText(cursor, "value"));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "string": {
          const str = parseScalaString(cursor.nodeText);
          for (const toIdx of [...jvmResolutionContext.reflectionMap.get(str) ?? []]) {
            addReference(fromIdx, toIdx, REFLECTION_CONFIDENCE);
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "import_declaration": {
          contextStack[contextStack.length - 1] = getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
          break;
        }
        case "compilation_unit":
        case "class_definition":
        case "object_definition":
        case "package_object":
        case "trait_definition":
        case "full_enum_case": {
          if (start2) {
            if (cursor.gotoFirstChild()) {
              contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            } else {
              done = true;
            }
            continue;
          }
          break;
        }
        case "package_clause": {
          const hasBody = cursorHasChildOfType(cursor, "package_body", this.subtypeMap);
          if (start2) {
            if (hasBody) {
              if (cursor.gotoFirstChild()) {
                contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
                continue;
              }
            } else {
              contextStack[contextStack.length - 1] = getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap);
            }
          } else {
            if (!hasBody) {
              contextStack.pop();
              if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
                done = true;
                break;
              }
            }
          }
          break;
        }
        default: {
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext3(currentContext, cursor, this.subtypeMap, jvmResolutionContext.childMap));
            continue;
          }
          break;
        }
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
          done = true;
          break;
        }
      }
    }
  }
};
function getUpdatedContext3(oldContext, cursor, subtypeMap, childMap) {
  const newContext = { ...oldContext };
  function processNamespaceExpression(cursor2) {
    const path2 = cursorChildrenForFieldNameText(cursor2, "path")?.join("");
    if (!path2)
      return;
    newContext.importsMap = copyImportsMap(newContext.importsMap);
    if (cursorGoToChildOfType(cursor2, "namespace_selectors", subtypeMap)) {
      if (cursor2.gotoFirstChild()) {
        do {
          switch (cursor2.nodeType) {
            case "identifier": {
              if (!newContext.importsMap.has(cursor2.nodeText)) {
                newContext.importsMap.set(cursor2.nodeText, []);
              }
              for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
                newContext.importsMap.get(cursor2.nodeText).push(`${resolvedPath}.${cursor2.nodeText}`);
              }
              break;
            }
            case "namespace_wildcard": {
              for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
                childMap?.get(resolvedPath)?.forEach((child) => {
                  if (!newContext.importsMap.has(child)) {
                    newContext.importsMap.set(child, []);
                  }
                  newContext.importsMap.get(child).push(`${resolvedPath}.${child}`);
                });
                newContext.maybeReferences = newContext.maybeReferences.concat([
                  resolvedPath,
                  `${resolvedPath}$`,
                  `${resolvedPath}.package`,
                  `${resolvedPath}.package$`
                ]);
              }
              break;
            }
            case "arrow_renamed_identifier":
            case "as_renamed_identifier": {
              const name2 = cursorChildForFieldNameText(cursor2, "name");
              const alias = cursorChildForFieldNameText(cursor2, "alias");
              if (name2 && alias && alias !== "_") {
                if (!newContext.importsMap.has(alias)) {
                  newContext.importsMap.set(alias, []);
                }
                for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
                  newContext.importsMap.get(alias).push(`${resolvedPath}.${name2}`);
                }
              }
              break;
            }
          }
        } while (cursor2.gotoNextSibling());
        cursor2.gotoParent();
      }
      cursor2.gotoParent();
    } else {
      let handled = false;
      if (cursor2.gotoFirstChild()) {
        do {
          switch (cursor2.nodeType) {
            case "namespace_wildcard": {
              for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
                childMap?.get(resolvedPath)?.forEach((child) => {
                  if (!newContext.importsMap.has(child)) {
                    newContext.importsMap.set(child, []);
                  }
                  newContext.importsMap.get(child).push(`${resolvedPath}.${child}`);
                });
                newContext.maybeReferences = newContext.maybeReferences.concat([
                  resolvedPath,
                  `${resolvedPath}$`,
                  `${resolvedPath}.package`,
                  `${resolvedPath}.package$`
                ]);
              }
              handled = true;
              break;
            }
            case "as_renamed_identifier": {
              const name2 = cursorChildForFieldNameText(cursor2, "name");
              const alias = cursorChildForFieldNameText(cursor2, "alias");
              if (name2 && alias && alias !== "_") {
                if (!newContext.importsMap.has(alias)) {
                  newContext.importsMap.set(alias, []);
                }
                for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
                  newContext.importsMap.get(alias).push(`${resolvedPath}.${name2}`);
                }
              }
              handled = true;
              break;
            }
          }
        } while (cursor2.gotoNextSibling());
        cursor2.gotoParent();
      }
      if (!handled) {
        const simpleName = path2.split(".").pop();
        if (simpleName) {
          if (!newContext.importsMap.has(simpleName)) {
            newContext.importsMap.set(simpleName, []);
          }
          for (const resolvedPath of resolveImport(path2, newContext.importsMap)) {
            newContext.importsMap.get(simpleName).push(resolvedPath);
          }
        }
      }
    }
  }
  switch (cursor.nodeType) {
    case "class_definition":
    case "trait_definition": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      if (name2) {
        newContext.classParts = newContext.classParts.concat(name2);
      }
      break;
    }
    case "object_definition":
    case "full_enum_case": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      if (name2) {
        newContext.classParts = newContext.classParts.concat(`${name2}$`);
      }
      break;
    }
    case "package_clause":
    case "package_object": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      if (name2) {
        newContext.packageParts = newContext.packageParts.concat(name2);
        newContext.classParts = [];
      }
      break;
    }
    case "import_declaration": {
      if (cursor.gotoFirstChild()) {
        do {
          switch (cursor.nodeType) {
            case "namespace_expression": {
              processNamespaceExpression(cursor);
              break;
            }
          }
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
      }
      break;
    }
  }
  return newContext;
}
function sanitizeName3(cursor) {
  switch (cursor.nodeType) {
    case "identifier":
    case "type_identifier": {
      return cursor.nodeText;
    }
    case "stable_identifier":
    case "stable_type_identifier": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName3(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "generic_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const baseName = sanitizeName3(cursor);
        cursor.gotoParent();
        return baseName;
      }
      return cursor.nodeText;
    }
    case "projected_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const type = sanitizeName3(cursor);
        if (cursorGoToSiblingOfFieldName(cursor, "selector")) {
          const selector = sanitizeName3(cursor);
          return `${type}.${selector}`;
        }
      }
      return cursor.nodeText.replaceAll("#", ".");
    }
    default:
      return cursor.nodeText;
  }
}
function parseScalaString(input) {
  let prefixLength = 0;
  if (/^[a-z]+"""/.test(input)) {
    prefixLength = input.indexOf('"""');
    if (input.endsWith('"""')) {
      return input.slice(prefixLength + 3, -3);
    }
  } else if (/^[a-z]+"/.test(input)) {
    prefixLength = input.indexOf('"');
    if (input.endsWith('"')) {
      return input.slice(prefixLength + 1, -1);
    }
  }
  const rawStringMatch = input.match(/^(#+)"(.+?)"(\1)$/);
  if (rawStringMatch) {
    return rawStringMatch[2];
  }
  if (input.startsWith('"""') && input.endsWith('"""')) {
    return input.slice(3, -3);
  }
  if (input.startsWith('"') && input.endsWith('"')) {
    return input.slice(1, -1);
  }
  return input;
}

// dist/class-graph/jvm/service-source-resolver.js
import { basename as basename4, join as join3 } from "node:path";
import { readFile as readFile3 } from "node:fs/promises";
var ServiceSourceResolver = class extends AbstractReflectiveSourceResolver {
  async getDeclarationNodes(packageId, container, file, _ecosystemSpecificPackageInfo, graph) {
    const serviceInterface = basename4(file);
    if (serviceInterface) {
      const content = await readFile3(join3(container, file), "utf-8");
      this.record(packageId, container, file, serviceInterface, graph, 0, content.length);
    }
  }
  async getEdges(requestedNode, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    const jvmResolutionContext = resolutionContext;
    const serviceInterface = basename4(requestedNode.file);
    if (serviceInterface) {
      const content = await readFile3(join3(requestedNode.container, requestedNode.file), "utf-8");
      const implementations = content.split("\n").map((line) => line.trim()).filter(Boolean);
      const nodeId = this.getNodeId(requestedNode.packageId, requestedNode.container, requestedNode.file, serviceInterface, 0, content.length);
      const fromIdx = jvmResolutionContext.nodeIdToIndex.get(nodeId);
      if (fromIdx !== void 0) {
        for (const implementation2 of implementations) {
          const toIndices = jvmResolutionContext.fqnMap.get(implementation2) ?? jvmResolutionContext.reflectionMap.get(implementation2) ?? [];
          for (const toIdx of toIndices) {
            graph.addEdge(fromIdx, toIdx, REFLECTION_CONFIDENCE);
          }
        }
      }
    }
  }
};

// dist/class-graph/jvm/xml-source-resolver.js
var import_parse_xml = __toESM(require_dist(), 1);
import { readFile as readFile4 } from "node:fs/promises";
import { join as join4 } from "node:path";
var XmlSourceResolver = class extends AbstractReflectiveSourceResolver {
  async getDeclarationNodes(packageId, container, file, _ecosystemSpecificPackageInfo, graph) {
    const parsedXml = (0, import_parse_xml.parseXml)(await readFile4(join4(container, file), "utf-8"), { includeOffsets: true });
    const entriesElement = parsedXml.children.filter((child) => child instanceof import_parse_xml.XmlElement).find((child) => child.name === "entries");
    if (entriesElement) {
      const entryElements = entriesElement.children.filter((child) => child instanceof import_parse_xml.XmlElement && child.name === "entry");
      for (const entry of entryElements) {
        const key = entry.attributes?.key;
        if (key) {
          this.record(packageId, container, file, key, graph, entry.start, entry.end);
        }
      }
    }
  }
  async getEdges(requestedNode, resolutionContext, graph) {
    if (resolutionContext.type !== "JVM")
      return;
    const jvmResolutionContext = resolutionContext;
    const parsedXml = (0, import_parse_xml.parseXml)(await readFile4(join4(requestedNode.container, requestedNode.file), "utf-8"), { includeOffsets: true });
    const entriesElement = parsedXml.children.filter((child) => child instanceof import_parse_xml.XmlElement).find((child) => child.name === "entries");
    if (entriesElement) {
      const entryElements = entriesElement.children.filter((child) => child instanceof import_parse_xml.XmlElement && child.name === "entry");
      for (const entry of entryElements) {
        const key = entry.attributes?.key;
        const textChild = entry.children?.find((child) => child instanceof import_parse_xml.XmlText);
        const value = textChild?.text?.trim();
        if (key && value) {
          const nodeId = this.getNodeId(requestedNode.packageId, requestedNode.container, requestedNode.file, key, entry.start, entry.end);
          const fromIdx = jvmResolutionContext.nodeIdToIndex.get(nodeId);
          if (fromIdx !== void 0) {
            const toIndices = jvmResolutionContext.fqnMap.get(value) ?? jvmResolutionContext.reflectionMap.get(value) ?? [];
            for (const toIdx of toIndices) {
              graph.addEdge(fromIdx, toIdx, REFLECTION_CONFIDENCE);
            }
          }
        }
      }
    }
  }
};

// node_modules/.pnpm/remeda@2.30.0/node_modules/remeda/dist/utilityEvaluators-DORpnx39.js
var t = { done: false, hasNext: false };

// node_modules/.pnpm/remeda@2.30.0/node_modules/remeda/dist/pipe-BWjVFU-o.js
function t2(e, ...t5) {
  let a = e, o = t5.map((e2) => `lazy` in e2 ? r(e2) : void 0), s = 0;
  for (; s < t5.length; ) {
    let e2 = o[s];
    if (e2 === void 0 || !i2(a)) {
      let e3 = t5[s];
      a = e3(a), s += 1;
      continue;
    }
    let r3 = [];
    for (let e3 = s; e3 < t5.length; e3++) {
      let t6 = o[e3];
      if (t6 === void 0 || (r3.push(t6), t6.isSingle)) break;
    }
    let c = [];
    for (let e3 of a) {
      let t6 = n(e3, c, r3);
      if (t6) break;
    }
    let { isSingle: l } = r3.at(-1);
    a = l ? c[0] : c, s += r3.length;
  }
  return a;
}
function n(t5, r3, i3) {
  if (i3.length === 0) return r3.push(t5), false;
  let a = t5, o = t, s = false;
  for (let [e, t6] of i3.entries()) {
    let { index: c, items: l } = t6;
    if (l.push(a), o = t6(a, c, l), t6.index += 1, o.hasNext) {
      if (o.hasMany ?? false) {
        for (let t7 of o.next) {
          let a2 = n(t7, r3, i3.slice(e + 1));
          if (a2) return true;
        }
        return s;
      }
      a = o.next;
    }
    if (!o.hasNext) break;
    o.done && (s = true);
  }
  return o.hasNext && r3.push(a), s;
}
function r(e) {
  let { lazy: t5, lazyArgs: n3 } = e, r3 = t5(...n3);
  return Object.assign(r3, { isSingle: t5.single ?? false, index: 0, items: [] });
}
function i2(e) {
  return typeof e == `string` || typeof e == `object` && !!e && Symbol.iterator in e;
}

// node_modules/.pnpm/remeda@2.30.0/node_modules/remeda/dist/purryFromLazy-B9_SOA_s.js
function t3(t5, n3) {
  let r3 = n3.length - t5.length;
  if (r3 === 1) {
    let [r4, ...i3] = n3, a = { lazy: t5, lazyArgs: i3 };
    return t2(r4, a);
  }
  if (r3 === 0) {
    let r4 = { lazy: t5, lazyArgs: n3 }, i3 = (t6) => t2(t6, r4);
    return Object.assign(i3, r4);
  }
  throw Error(`Wrong number of arguments`);
}

// node_modules/.pnpm/remeda@2.30.0/node_modules/remeda/dist/unique-DyGWKslr.js
function n2(...e) {
  return t3(r2, e);
}
function r2() {
  let t5 = /* @__PURE__ */ new Set();
  return (n3) => t5.has(n3) ? t : (t5.add(n3), { done: false, hasNext: true, next: n3 });
}

// dist/class-graph/analysis-runner/class-graph.js
var ClassGraph = class {
  nodeIds = /* @__PURE__ */ new Set();
  // Note, the order in the nodes array matters!
  nodes = [];
  // Edges in the graph are modelled as a nested record: child index -> parent index -> confidence
  // Child and parent index are with respect to the position in the `nodes` array
  // Confidence is a confidence score [0.0, 1.0]
  edges = /* @__PURE__ */ new Map();
  // Add node and return it's index
  addNode(node) {
    if (this.nodeIds.has(node.nodeId))
      return void 0;
    this.nodeIds.add(node.nodeId);
    return this.nodes.push(node) - 1;
  }
  addNodes(newNodes) {
    for (const newNode of newNodes) {
      this.addNode(newNode);
    }
  }
  getNodes() {
    return this.nodes;
  }
  addEdge(from, to, confidence) {
    if (from < 0 || from >= this.nodes.length || to < 0 || to >= this.nodes.length) {
      return false;
    }
    const children = this.edges.get(from);
    if (children) {
      const existingConfidence = children.get(to);
      children.set(to, Math.max(confidence, existingConfidence ?? 0));
      return existingConfidence === void 0;
    } else {
      this.edges.set(from, /* @__PURE__ */ new Map([[to, confidence]]));
      return true;
    }
  }
  getEdges() {
    return this.edges;
  }
};

// dist/class-graph/analysis-runner/graph-utils.js
function findReachableNodes(graph, sources) {
  if (sources.length === 0)
    return /* @__PURE__ */ new Set();
  const edges = graph.getEdges();
  const reachable = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const queue = [...sources];
  for (const source of sources) {
    reachable.add(source);
  }
  while (queue.length > 0) {
    const curr = queue.shift();
    if (visited.has(curr))
      continue;
    visited.add(curr);
    const children = edges.get(curr);
    for (const [child] of children?.entries() ?? []) {
      if (!reachable.has(child)) {
        reachable.add(child);
        queue.push(child);
      }
    }
  }
  return reachable;
}
var PriorityQueue = class {
  costFn;
  heap = [];
  constructor(costFn) {
    this.costFn = costFn;
  }
  isEmpty() {
    return this.heap.length === 0;
  }
  add(element) {
    const cost = this.costFn(element);
    this.heap.push({ element, cost });
    this.heapifyUp(this.heap.length - 1);
  }
  poll() {
    if (this.heap.length === 0)
      return void 0;
    if (this.heap.length === 1)
      return this.heap.pop()?.element;
    const result = this.heap[0].element;
    this.heap[0] = this.heap.pop();
    this.heapifyDown(0);
    return result;
  }
  size() {
    return this.heap.length;
  }
  heapifyUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[parentIndex].cost <= this.heap[index].cost)
        break;
      [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
      index = parentIndex;
    }
  }
  heapifyDown(index) {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;
      if (leftChild < this.heap.length && this.heap[leftChild].cost < this.heap[smallest].cost) {
        smallest = leftChild;
      }
      if (rightChild < this.heap.length && this.heap[rightChild].cost < this.heap[smallest].cost) {
        smallest = rightChild;
      }
      if (smallest === index)
        break;
      [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
      index = smallest;
    }
  }
};
function buildReverseGraph(graph) {
  const edges = graph.getEdges();
  const reverseEdges = /* @__PURE__ */ new Map();
  for (const [from, toMap] of edges.entries()) {
    for (const [to, confidence] of toMap.entries()) {
      if (!reverseEdges.has(to)) {
        reverseEdges.set(to, /* @__PURE__ */ new Map());
      }
      reverseEdges.get(to).set(from, confidence);
    }
  }
  return reverseEdges;
}
function computeShortestPathTree(edges, sourceNode) {
  const routingTable = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const costMap = /* @__PURE__ */ new Map();
  const parentMap = /* @__PURE__ */ new Map();
  const worklist = new PriorityQueue((node) => costMap.get(node) ?? Number.MAX_VALUE);
  costMap.set(sourceNode, 0);
  worklist.add(sourceNode);
  while (!worklist.isEmpty()) {
    const current = worklist.poll();
    if (visited.has(current))
      continue;
    visited.add(current);
    const currCost = costMap.get(current) ?? 0;
    if (current !== sourceNode) {
      const nextHop = parentMap.get(current) ?? current;
      routingTable.set(current, {
        cost: currCost,
        nextHop
      });
    }
    const neighbors = edges.get(current);
    if (neighbors) {
      for (const [neighbor, confidence] of neighbors.entries()) {
        const newCost = currCost + 1 / confidence;
        const existingCost = costMap.get(neighbor);
        if (existingCost === void 0 || newCost < existingCost) {
          costMap.set(neighbor, newCost);
          parentMap.set(neighbor, current);
          worklist.add(neighbor);
        }
      }
    }
  }
  return routingTable;
}

// dist/class-graph/analysis-runner/vulnerable-path-utils.js
function findAppChildrenWithParents(appSources, forwardEdges) {
  const appSourceSet = new Set(appSources);
  const appChildrenWithParents = [];
  for (const appIdx of appSources) {
    const children = forwardEdges.get(appIdx);
    if (children) {
      for (const [childIdx, confidence] of children.entries()) {
        if (!appSourceSet.has(childIdx)) {
          appChildrenWithParents.push({ child: childIdx, parent: appIdx, confidence });
        }
      }
    }
  }
  return appChildrenWithParents;
}
function connectAppChildrenToParents(vulnerablePathsToChildren, appChildrenWithParents, graph, k) {
  const childToParentMap = /* @__PURE__ */ new Map();
  for (const { child, parent, confidence } of appChildrenWithParents) {
    if (!childToParentMap.has(child)) {
      childToParentMap.set(child, []);
    }
    childToParentMap.get(child).push({ parent, confidence });
  }
  const vulnerablePathsComplete = {};
  for (const [fqn, childPaths] of Object.entries(vulnerablePathsToChildren)) {
    const completePathsWithCosts = [];
    for (const childPath of childPaths) {
      if (childPath.length === 0)
        continue;
      const firstChild = childPath[0];
      const parentOptions = childToParentMap.get(firstChild);
      if (parentOptions) {
        for (const { parent, confidence } of parentOptions) {
          const completePath = [parent, ...childPath];
          const appToChildCost = 1 / confidence;
          const childPathCost = calculatePathCost(childPath, graph);
          const totalCost = appToChildCost + childPathCost;
          completePathsWithCosts.push({ path: completePath, cost: totalCost });
        }
      }
    }
    if (completePathsWithCosts.length > 0) {
      completePathsWithCosts.sort((a, b) => a.cost - b.cost);
      const bestPaths = completePathsWithCosts.slice(0, k);
      vulnerablePathsComplete[fqn] = bestPaths.map((item) => item.path);
    }
  }
  return vulnerablePathsComplete;
}
function calculatePathCost(path2, graph) {
  if (path2.length <= 1)
    return 0;
  const edges = graph.getEdges();
  let totalCost = 0;
  for (let i3 = 0; i3 < path2.length - 1; i3++) {
    const confidence = edges.get(path2[i3])?.get(path2[i3 + 1]) ?? 1;
    totalCost += 1 / confidence;
  }
  return totalCost;
}
function convertRawPathToVulnerablePath(rawPath, allNodes, graph) {
  if (rawPath.length === 0)
    return [];
  let parentIndex = rawPath[0];
  const appNode = allNodes[parentIndex];
  const pathWithConfidence = [
    {
      packageId: appNode.packageId,
      fullyQualifiedName: appNode.nodeType === "type" ? appNode.fullyQualifiedName : `${appNode.fullyQualifiedName} (file ${appNode.fileEntry ?? appNode.file ?? appNode.container})`,
      confidence: 1
    }
  ];
  for (const childIndex of rawPath.slice(1)) {
    if (childIndex >= allNodes.length)
      throw Error(`child index out of bounds! ${childIndex} >= ${allNodes.length}`);
    const childNode = allNodes[childIndex];
    const confidence = graph.getEdges().get(parentIndex)?.get(childIndex);
    if (confidence === void 0)
      throw Error(`confidence undefined for edge ${parentIndex}->${childIndex}`);
    pathWithConfidence.push({
      packageId: childNode.packageId,
      fullyQualifiedName: childNode.nodeType === "type" ? childNode.fullyQualifiedName : `${childNode.fullyQualifiedName} (file ${childNode.fileEntry ?? childNode.file ?? childNode.container})`,
      confidence
    });
    parentIndex = childIndex;
  }
  return pathWithConfidence;
}
function findPathsToVulnerability(reverseEdges, sources, vulnerabilitySinks, k) {
  if (sources.length === 0 || vulnerabilitySinks.length === 0)
    return [];
  const sourceSet = new Set(sources);
  const syntheticNodeIdx = -1;
  const syntheticEdges = /* @__PURE__ */ new Map();
  for (const vulnIdx of vulnerabilitySinks) {
    syntheticEdges.set(vulnIdx, 1);
  }
  reverseEdges.set(syntheticNodeIdx, syntheticEdges);
  const routingTable = computeShortestPathTree(reverseEdges, syntheticNodeIdx);
  reverseEdges.delete(syntheticNodeIdx);
  const sourcesWithCosts = [];
  for (const sourceIdx of sources) {
    const routeInfo = routingTable.get(sourceIdx);
    if (routeInfo) {
      sourcesWithCosts.push({ source: sourceIdx, cost: routeInfo.cost });
    }
  }
  sourcesWithCosts.sort((a, b) => a.cost - b.cost);
  const bestSources = sourcesWithCosts.slice(0, k);
  const paths = [];
  for (const { source: sourceIdx } of bestSources) {
    const path2 = reconstructPath(routingTable, sourceIdx, syntheticNodeIdx, sourceSet);
    if (path2.length > 0) {
      paths.push(path2);
    }
  }
  return paths;
}
function reconstructPath(routingTable, sourceIdx, destinationIdx, sourceNodes) {
  const path2 = [];
  let current = sourceIdx;
  const visited = /* @__PURE__ */ new Set();
  path2.push(current);
  visited.add(current);
  while (current !== destinationIdx) {
    const routeInfo = routingTable.get(current);
    if (!routeInfo)
      break;
    const nextNode = routeInfo.nextHop;
    if (nextNode === current)
      break;
    if (visited.has(nextNode))
      break;
    if (nextNode === destinationIdx)
      break;
    if (sourceNodes.has(nextNode)) {
      return [];
    }
    path2.push(nextNode);
    visited.add(nextNode);
    current = nextNode;
  }
  return path2;
}

// dist/class-graph/analysis-runner/class-graph-runner.js
var ClassGraphRunner = class {
  options;
  graph;
  constructor(options) {
    this.options = options;
    this.graph = new ClassGraph();
  }
  async runDirectDependencyAnalysis() {
    const resolutionManagers = {
      src: this.options.srcResolutionManager,
      bin: this.options.binResolutionManager
    };
    await Promise.all([
      resolutionManagers.src?.resolveDeclarations(this.graph, this.options.apps, this.options.deps),
      resolutionManagers.bin?.resolveDeclarations(this.graph, this.options.apps, this.options.deps)
    ]);
    await Promise.all([
      resolutionManagers.src?.resolveDefinitions?.(this.graph, this.options.apps, this.options.deps),
      resolutionManagers.bin?.resolveDefinitions?.(this.graph, this.options.apps, this.options.deps)
    ]);
    const allNodes = this.graph.getNodes();
    const appIndices = allNodes.map((node, idx) => this.options.apps[node.packageId] && node.nodeType === "type" ? idx : void 0).filter((idx) => idx !== void 0);
    const visited = /* @__PURE__ */ new Set();
    const appSrcIndices = appIndices.filter((idx) => allNodes[idx].resolutionType === "src");
    const appBinIndices = appIndices.filter((idx) => allNodes[idx].resolutionType === "bin");
    await Promise.all([
      appSrcIndices.length ? resolutionManagers.src?.resolveEdges(this.graph, appIndices, appSrcIndices, visited, "DIRECT_DEPENDENCIES") : Promise.resolve(),
      appBinIndices.length ? resolutionManagers.bin?.resolveEdges(this.graph, appIndices, appBinIndices, visited, "DIRECT_DEPENDENCIES") : Promise.resolve()
    ]);
    const reachableNodes = [];
    for (const reachableIdx of this.graph.getEdges().keys()) {
      reachableNodes.push(allNodes[reachableIdx]);
    }
    return n2(reachableNodes.map((node) => node.packageId));
  }
  async runAnalysis(vulnerableClasses) {
    try {
      return await this.actuallyRunAnalysis(vulnerableClasses);
    } catch (e) {
      const analysisDiagnostics = {
        timeout: false,
        aborted: false
      };
      return {
        success: false,
        vulnerablePaths: {},
        analysisDiagnostics,
        error: e.message
      };
    }
  }
  async actuallyRunAnalysis(vulnerableClasses) {
    const vulnerableClassesSet = new Set(vulnerableClasses);
    const resolutionManagers = {
      src: this.options.srcResolutionManager,
      bin: this.options.binResolutionManager
    };
    await Promise.all([
      resolutionManagers.src?.resolveDeclarations(this.graph, this.options.apps, this.options.deps),
      resolutionManagers.bin?.resolveDeclarations(this.graph, this.options.apps, this.options.deps)
    ]);
    await Promise.all([
      resolutionManagers.src?.resolveDefinitions?.(this.graph, this.options.apps, this.options.deps),
      resolutionManagers.bin?.resolveDefinitions?.(this.graph, this.options.apps, this.options.deps)
    ]);
    const allNodes = this.graph.getNodes();
    const appIndices = allNodes.map((node, idx) => this.options.apps[node.packageId] && node.nodeType === "type" ? idx : void 0).filter((idx) => idx !== void 0);
    const worklist = {
      src: appIndices.filter((idx) => allNodes[idx].resolutionType === "src"),
      bin: appIndices.filter((idx) => allNodes[idx].resolutionType === "bin")
    };
    const visited = /* @__PURE__ */ new Set();
    const createWorker = async (type, resolutionManager) => {
      while (true) {
        const worklistForType = worklist[type].filter((idx) => !visited.has(idx));
        if (worklistForType.length === 0)
          break;
        worklist[type] = [];
        await resolutionManager?.resolveEdges(this.graph, appIndices, worklistForType, visited, "FULL_GRAPH");
      }
    };
    while (true) {
      await Promise.all([createWorker("src", resolutionManagers.src), createWorker("bin", resolutionManagers.bin)]);
      if (worklist.src.length === 0 && worklist.bin.length === 0) {
        const allReachableNodes = findReachableNodes(this.graph, appIndices);
        for (const reachableIdx of allReachableNodes) {
          if (!visited.has(reachableIdx)) {
            const resolutionType = allNodes[reachableIdx].resolutionType;
            if (resolutionType === "src" || resolutionType === "bin") {
              worklist[resolutionType].push(reachableIdx);
            }
          }
        }
        if (worklist.src.length === 0 && worklist.bin.length === 0) {
          break;
        }
      }
    }
    const vulnerableClassToIndices = /* @__PURE__ */ new Map();
    allNodes.forEach((node, idx) => {
      if (!this.options.deps[node.packageId] || !vulnerableClassesSet.has(node.fullyQualifiedName))
        return;
      if (!vulnerableClassToIndices.has(node.fullyQualifiedName)) {
        vulnerableClassToIndices.set(node.fullyQualifiedName, []);
      }
      vulnerableClassToIndices.get(node.fullyQualifiedName).push(idx);
    });
    const vulnerablePaths = this.computeVulnerablePaths(this.graph, appIndices, allNodes, vulnerableClassToIndices);
    const analysisDiagnostics = {
      timeout: false,
      aborted: false
    };
    const result = {
      success: true,
      vulnerablePaths,
      analysisDiagnostics,
      error: null
    };
    return result;
  }
  computeVulnerablePaths(graph, appIndices, allNodes, vulnerableClassToIndices) {
    const sources = appIndices;
    const reverseGraph = buildReverseGraph(graph);
    const forwardEdges = graph.getEdges();
    const appChildrenWithParents = findAppChildrenWithParents(sources, forwardEdges);
    const childIndices = appChildrenWithParents.map((item) => item.child);
    const vulnerablePathsToChildren = {};
    for (const [fqn, vulnerabilitySinks] of vulnerableClassToIndices.entries()) {
      const paths = findPathsToVulnerability(reverseGraph, childIndices, vulnerabilitySinks, 10);
      if (paths.length > 0) {
        vulnerablePathsToChildren[fqn] = paths;
      }
    }
    const vulnerablePathsRaw = connectAppChildrenToParents(vulnerablePathsToChildren, appChildrenWithParents, graph, 10);
    const vulnerablePaths = Object.fromEntries(Object.entries(vulnerablePathsRaw).map(([fqn, rawPaths]) => {
      const pathsWithConfidence = rawPaths.map((rawPath) => convertRawPathToVulnerablePath(rawPath, allNodes, graph));
      return [fqn, pathsWithConfidence];
    }));
    return vulnerablePaths;
  }
};

// dist/utils/file.js
import { readdir } from "node:fs/promises";
import { join as join5 } from "node:path";
async function getFilesRelative(dir, excludeDirs) {
  async function helper(subDir, arrayOfFiles) {
    for (const item of await readdir(join5(dir, subDir), { withFileTypes: true })) {
      const itemPath = join5(subDir, item.name);
      if (item.isDirectory()) {
        if (!excludeDirs?.includes(item.name))
          await helper(itemPath, arrayOfFiles);
      } else if (item.isFile()) {
        arrayOfFiles.push(itemPath);
      }
    }
    return arrayOfFiles;
  }
  return n2(await helper(".", []));
}

// dist/utils/async.js
async function asyncForEach(array, fn, concurrency = 1) {
  let index = 0;
  async function worker() {
    while (index < array.length) {
      const i3 = index++;
      await fn(array[i3], i3);
    }
  }
  await Promise.all(Array.from({ length: concurrency }, async () => worker()));
}

// dist/class-graph/resolvers/source-resolution-manager.js
var SourceResolutionManager = class {
  resolverCb;
  resolutionContextProvider;
  excludeDirs;
  constructor(resolverCb, resolutionContextProvider, excludeDirs) {
    this.resolverCb = resolverCb;
    this.resolutionContextProvider = resolutionContextProvider;
    this.excludeDirs = excludeDirs;
  }
  async resolveDeclarations(graph, apps, deps) {
    const promiseFns = [];
    for (const [packageId, packageInfo] of Object.entries({ ...apps, ...deps })) {
      const { src, ecosystemSpecificPackageInfo } = packageInfo;
      if (!src)
        continue;
      for (const sourceDir of new Set(src)) {
        for (const file of await getFilesRelative(sourceDir, this.excludeDirs)) {
          promiseFns.push(async () => {
            const resolver = this.resolverCb(file);
            if (resolver) {
              await resolver.getDeclarationNodes(packageId, sourceDir, file, ecosystemSpecificPackageInfo, graph);
            }
          });
        }
      }
    }
    await asyncForEach(promiseFns, async (f) => f(), 8);
  }
  async resolveDefinitions(graph, apps, deps) {
    const resolutionContext = this.resolutionContextProvider.getResolutionContext(graph.getNodes());
    const promiseFns = [];
    const allPackages = { ...apps, ...deps };
    for (const [packageId, packageInfo] of Object.entries(allPackages)) {
      const { src, ecosystemSpecificPackageInfo } = packageInfo;
      if (!src)
        continue;
      for (const sourceDir of new Set(src)) {
        for (const file of await getFilesRelative(sourceDir, this.excludeDirs)) {
          promiseFns.push(async () => {
            const resolver = this.resolverCb(file);
            if (resolver) {
              if (resolver.getDefinitionNodes) {
                await resolver.getDefinitionNodes(packageId, sourceDir, file, resolutionContext, ecosystemSpecificPackageInfo, graph);
              }
            }
          });
        }
      }
    }
    await asyncForEach(promiseFns, async (f) => f(), 8);
  }
  async resolveEdges(graph, appIndices, worklist, visited, mode) {
    const allNodes = graph.getNodes();
    const resolutionContext = this.resolutionContextProvider.getResolutionContext(allNodes, visited);
    while (worklist.length > 0) {
      const idx = worklist.pop();
      if (visited.has(idx))
        continue;
      const node = allNodes[idx];
      if (node.resolutionType !== "src")
        continue;
      const resolver = this.resolverCb(node.file);
      if (!resolver)
        continue;
      await resolver.getEdges(node, resolutionContext, graph);
      visited.add(idx);
    }
    if (mode === "FULL_GRAPH") {
      for (const reachableIdx of findReachableNodes(graph, appIndices)) {
        if (!visited.has(reachableIdx) && allNodes[reachableIdx].resolutionType === "src") {
          worklist.push(reachableIdx);
        }
      }
      while (worklist.length > 0) {
        const idx = worklist.pop();
        if (visited.has(idx))
          continue;
        const node = allNodes[idx];
        if (node.resolutionType !== "src")
          continue;
        const resolver = this.resolverCb(node.file);
        if (!resolver)
          continue;
        await resolver.getEdges(node, resolutionContext, graph);
        visited.add(idx);
      }
    }
  }
};

// dist/class-graph/jvm/jvm-resolution-context-provider.js
var JvmResolutionContextProvider = class {
  getResolutionContext(nodes, visited) {
    const nodeIdToIndex = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < nodes.length; ++i3) {
      nodeIdToIndex.set(nodes[i3].nodeId, i3);
    }
    const fqnMap = /* @__PURE__ */ new Map();
    const reflectionMap = /* @__PURE__ */ new Map();
    const nestedClassMap = /* @__PURE__ */ new Map();
    const childMap = /* @__PURE__ */ new Map();
    nodes.forEach((node, idx) => {
      const fqn = node.fullyQualifiedName;
      if (node.nodeType === "type") {
        const prettyFqn = node.fullyQualifiedName.split("$").filter(Boolean).join(".");
        if (!fqnMap.has(prettyFqn)) {
          fqnMap.set(prettyFqn, []);
        }
        fqnMap.get(prettyFqn).push(idx);
        const [fqnOfEnclosingClass] = fqn.split("$");
        if (!nestedClassMap.has(fqnOfEnclosingClass)) {
          nestedClassMap.set(fqnOfEnclosingClass, []);
        }
        nestedClassMap.get(fqnOfEnclosingClass).push(idx);
        const parts2 = fqn.split(/[.$]/).filter(Boolean);
        for (let i3 = 1; i3 < parts2.length; i3++) {
          const parent = parts2.slice(0, i3).join(".");
          const child = parts2[i3];
          if (!childMap.has(parent)) {
            childMap.set(parent, []);
          }
          childMap.get(parent).push(child);
        }
      }
      if (!reflectionMap.has(fqn)) {
        reflectionMap.set(fqn, []);
      }
      reflectionMap.get(fqn).push(idx);
    });
    visited ??= /* @__PURE__ */ new Set();
    return {
      type: "JVM",
      nodes,
      visited,
      nodeIdToIndex,
      fqnMap,
      reflectionMap,
      nestedClassMap,
      childMap
    };
  }
};

// dist/class-graph/jvm/alucard-resolution-manager.js
import { readFile as readFile5, writeFile } from "node:fs/promises";
import { resolve } from "node:path";

// dist/utils/exec.js
import assert2 from "node:assert";
import { execFile } from "node:child_process";
async function execNeverFail(cmd, dir, options) {
  return new Promise((resolve4) => {
    let args2;
    if (typeof cmd !== "string")
      [cmd, ...args2] = cmd;
    const childProcess = execFile(cmd, args2, {
      ...options,
      cwd: dir,
      maxBuffer: 1024 * 1024 * 1024,
      shell: args2 === void 0
    }, (error, stdout, stderr) => {
      resolve4({ error, stdout, stderr });
    });
    if (options?.pipe) {
      childProcess.stdout?.on("data", (data2) => {
        process.stdout.write(data2);
      });
      childProcess.stderr?.on("data", (data2) => {
        process.stderr.write(data2);
      });
    }
    if (options?.stdin)
      childProcess.stdin?.write(options.stdin);
    childProcess.stdin?.end();
  });
}
function assertCmd(args2) {
  assert2(args2.length > 0);
  assert2(args2[0]);
}
function cmdt(statics, ...values) {
  const res = argt(statics, ...values);
  assertCmd(res);
  return res;
}
function argt(statics, ...values) {
  const n3 = values.length;
  const sParts = statics.map((s, i3) => {
    if (i3 === 0)
      s = s.trimStart();
    if (i3 === n3)
      s = s.trimEnd();
    return s.split(/\s+/);
  });
  const res = sParts.shift();
  let carry = res.pop();
  const add = (s) => {
    if (carry !== void 0)
      carry += s;
  };
  const addL = (arr) => {
    add(arr.shift());
    if (arr.length) {
      if (carry !== void 0)
        res.push(carry);
      carry = arr.pop();
      res.push(...arr);
    }
  };
  for (let i3 = 0; i3 < n3; i3++) {
    const v = values[i3];
    if (typeof v === "string")
      add(v);
    else if (typeof v === "number")
      add(String(v));
    else if (!v || !v.length)
      carry = void 0;
    else
      addL(v.slice());
    addL(sParts[i3]);
  }
  if (carry !== void 0)
    res.push(carry);
  return res;
}

// dist/utils/tmp.js
import { rm, mkdtemp } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join as join6 } from "node:path";
async function createTmpDirectory(prefix) {
  try {
    const tmpDir = await mkdtemp(join6(tmpdir(), prefix));
    return tmpDir;
  } catch (err2) {
    console.log("Error creating tmp directory", err2);
    throw err2;
  }
}
async function withTmpDirectory(prefix, fn, deleteTmpDir = true) {
  const tmpDir = await createTmpDirectory(prefix);
  try {
    return await fn(tmpDir);
  } finally {
    if (deleteTmpDir) {
      await rm(tmpDir, { recursive: true, force: true });
    } else {
      console.log("Not deleting tmp dir", tmpDir);
    }
  }
}

// dist/class-graph/utils.js
function convertClassGraphEdgesToRecord(edges) {
  const record = {};
  for (const [fromIdx, childrenMap] of edges) {
    const childrenRecord = {};
    for (const [toIdx, confidence] of childrenMap) {
      childrenRecord[toIdx] = confidence;
    }
    record[fromIdx] = childrenRecord;
  }
  return record;
}

// dist/class-graph/jvm/alucard-resolution-manager.js
var AlucardResolutionManager = class {
  alucardPath;
  timeoutInSeconds;
  constructor(alucardPath, timeoutInSeconds) {
    this.alucardPath = alucardPath;
    this.timeoutInSeconds = timeoutInSeconds;
  }
  async resolveDeclarations(graph, apps, deps) {
    await withTmpDirectory("alucard-resolution-manager", async (tmpDir) => {
      const packages = { ...apps, ...deps };
      const inputFileData = {
        packageIdToBin: Object.fromEntries(Object.entries(packages).filter(([_, packageInfo]) => packageInfo.bin?.length).map(([packageId, packageInfo]) => [packageId, packageInfo.bin ?? []]))
      };
      const inputFile = resolve(tmpDir, "input.json");
      await writeFile(inputFile, JSON.stringify(inputFileData));
      const execResult = await execNeverFail(cmdt`java -jar ${this.alucardPath} resolveNodes --batch-mode --input-file=${inputFile} --output-dir=${tmpDir} --timeout=${this.timeoutInSeconds}`);
      if (execResult.error)
        throw Error("alucard could not resolve nodes");
      const nodes = JSON.parse(await readFile5(resolve(tmpDir, "nodes.json"), "utf-8"));
      const fatJarExcludes = new Set(nodes.filter((node) => deps[node.packageId] && node.nodeType === "type").map((node) => node.fullyQualifiedName));
      graph.addNodes(nodes.filter((node) => !apps[node.nodeId] && node.nodeType === "type" && fatJarExcludes.has(node.fullyQualifiedName)));
    });
  }
  async resolveEdges(graph, appIndices, worklist, visited, mode) {
    await withTmpDirectory("alucard-resolver", async (tmpDir) => {
      const inputFileData = {
        nodes: graph.getNodes(),
        edges: convertClassGraphEdgesToRecord(graph.getEdges()),
        worklist,
        visited: Array.from(visited),
        appIndices
      };
      const inputFile = resolve(tmpDir, "input.json");
      await writeFile(inputFile, JSON.stringify(inputFileData));
      const execResult = await execNeverFail(cmdt`java -jar ${this.alucardPath} resolveEdges --batch-mode ${mode === "DIRECT_DEPENDENCIES" && "--entry-edges-only"} --input-file=${inputFile} --output-dir=${tmpDir} --timeout=${this.timeoutInSeconds}`);
      if (execResult.error)
        throw new Error("alucard could not resolve edges");
      for (const idx of JSON.parse(await readFile5(resolve(tmpDir, "visited.json"), "utf-8"))) {
        visited.add(idx);
      }
      const edgesRecord = JSON.parse(await readFile5(resolve(tmpDir, "edges.json"), "utf-8"));
      for (const [fromIdx, childrenRecord] of Object.entries(edgesRecord)) {
        for (const [toIdx, confidence] of Object.entries(childrenRecord)) {
          graph.addEdge(parseInt(fromIdx), parseInt(toIdx), confidence);
        }
      }
    });
  }
};

// dist/source-resolver-utils.js
import { join as join7 } from "node:path";
import { readFile as readFile6 } from "node:fs/promises";
async function createTreeSitterResolver(dirPath, wasmName, ResolverClass) {
  if (!dirPath)
    return void 0;
  const wasmPath = join7(dirPath, wasmName);
  const parser2 = new Parser().setLanguage(await Language.load(wasmPath));
  const nodeTypesJsonPath = join7(dirPath, "node-types.json");
  const nodeTypes = JSON.parse(await readFile6(nodeTypesJsonPath, "utf-8"));
  const subtypeMap = buildSubtypeMap(nodeTypes);
  return new ResolverClass(parser2, subtypeMap);
}
function buildSubtypeMap(nodeTypeInfo) {
  const immediateMap = /* @__PURE__ */ new Map();
  for (const node of nodeTypeInfo) {
    if (!immediateMap.has(node.type)) {
      immediateMap.set(node.type, /* @__PURE__ */ new Set());
    }
    const subtypes = immediateMap.get(node.type);
    subtypes.add(node.type);
    if (node.subtypes) {
      for (const subtypeNode of node.subtypes) {
        subtypes.add(subtypeNode.type);
      }
    }
  }
  const subtypeMap = /* @__PURE__ */ new Map();
  for (const [type, subtypes] of immediateMap.entries()) {
    const visited = /* @__PURE__ */ new Set();
    const worklist = [...subtypes];
    while (worklist.length > 0) {
      const current = worklist.pop();
      if (visited.has(current))
        continue;
      visited.add(current);
      worklist.push(...immediateMap.get(current) ?? []);
    }
    subtypeMap.set(type, visited);
  }
  return subtypeMap;
}

// dist/jvm-reachability-analyzer.js
async function createJvmResolverCallback(resources) {
  await Parser.init();
  const [javaSourceResolver, kotlinSourceResolver, scalaSourceResolver] = await Promise.all([
    createTreeSitterResolver(resources.treeSitterJava, "tree-sitter-java.wasm", JavaSourceResolver),
    createTreeSitterResolver(resources.treeSitterKotlin, "tree-sitter-kotlin.wasm", KotlinSourceResolver),
    createTreeSitterResolver(resources.treeSitterScala, "tree-sitter-scala.wasm", ScalaSourceResolver)
  ]);
  const propertiesSourceResolver = new PropertiesSourceResolver();
  const xmlSourceResolver = new XmlSourceResolver();
  const serviceSourceResolver = new ServiceSourceResolver();
  return (file) => {
    const filext = extname4(file);
    switch (filext) {
      case ".java":
        return javaSourceResolver;
      case ".kt":
        return kotlinSourceResolver;
      case ".scala":
        return scalaSourceResolver;
      case ".properties":
        return propertiesSourceResolver;
      case ".xml":
        return xmlSourceResolver;
    }
    if (file.includes("META-INF/services/")) {
      return serviceSourceResolver;
    }
  };
}
async function runJvmDirectDependencyAnalysis(options, resources) {
  const resolverCb = await createJvmResolverCallback(resources);
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new JvmResolutionContextProvider()),
    binResolutionManager: resources.alucard ? new AlucardResolutionManager(resources.alucard, options.timeoutInSeconds) : void 0,
    ...options
  });
  return await runner.runDirectDependencyAnalysis();
}
async function runJvmReachabilityAnalysis(options, resources) {
  const resolverCb = await createJvmResolverCallback(resources);
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new JvmResolutionContextProvider()),
    binResolutionManager: resources.alucard ? new AlucardResolutionManager(resources.alucard, options.timeoutInSeconds) : void 0,
    apps: options.apps,
    deps: options.deps,
    timeoutInSeconds: options.timeoutInSeconds
  });
  return await runner.runAnalysis(options.vulnerableClasses);
}

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/index.js
import process4 from "node:process";

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/dependencies.js
import require$$0$1, { format } from "util";
import { normalize as normalize$1, resolve as resolve2 } from "path";
import { readFileSync } from "fs";
import path$1 from "node:path";
import process$2 from "node:process";
import { fileURLToPath } from "node:url";
import fs$1 from "node:fs";
import require$$0$2 from "os";
import require$$0 from "url";
function camelCase$1(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i3 = leadingHyphens ? leadingHyphens[0].length : 0; i3 < str.length; i3++) {
      let chr = str.charAt(i3);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i3 !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize$1(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i3 = 0; i3 < str.length; i3++) {
    const chrLower = lowercase.charAt(i3);
    const chrString = str.charAt(i3);
    if (chrLower !== chrString && i3 > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i3)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === void 0)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i3 = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args2 = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i3++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args2[i3])
      args2[i3] = "";
    args2[i3] += c;
  }
  return args2;
}
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
var mixin;
var YargsParser = class {
  constructor(_mixin) {
    mixin = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: void 0,
      array: void 0,
      boolean: void 0,
      config: void 0,
      configObjects: void 0,
      configuration: void 0,
      coerce: void 0,
      count: void 0,
      default: void 0,
      envPrefix: void 0,
      narg: void 0,
      normalize: void 0,
      string: void 0,
      number: void 0,
      __: void 0,
      key: void 0
    }, options);
    const args2 = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults2 = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = /* @__PURE__ */ Object.create(null);
    const defaulted = /* @__PURE__ */ Object.create(null);
    const __ = opts.__ || mixin.format;
    const flags8 = {
      aliases: /* @__PURE__ */ Object.create(null),
      arrays: /* @__PURE__ */ Object.create(null),
      bools: /* @__PURE__ */ Object.create(null),
      strings: /* @__PURE__ */ Object.create(null),
      numbers: /* @__PURE__ */ Object.create(null),
      counts: /* @__PURE__ */ Object.create(null),
      normalize: /* @__PURE__ */ Object.create(null),
      configs: /* @__PURE__ */ Object.create(null),
      nargs: /* @__PURE__ */ Object.create(null),
      coercions: /* @__PURE__ */ Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags8[assignment][key] = true;
      }
      flags8.arrays[key] = true;
      flags8.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags8.bools[key] = true;
      flags8.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags8.strings[key] = true;
      flags8.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags8.numbers[key] = true;
      flags8.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags8.counts[key] = true;
      flags8.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags8.normalize[key] = true;
      flags8.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags8.nargs[key] = value;
          flags8.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags8.coercions[key] = value;
          flags8.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags8.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags8.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags8.arrays);
    Object.keys(defaults2).forEach(function(key) {
      (flags8.aliases[key] || []).forEach(function(alias) {
        defaults2[alias] = defaults2[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i3 = 0; i3 < args2.length; i3++) {
      const arg = args2[i3];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags8.arrays)) {
            i3 = eatArray(i3, m[1], args2, m[2]);
          } else if (checkAllAliases(m[1], flags8.nargs) !== false) {
            i3 = eatNargs(i3, m[1], args2, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags8.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags8.arrays)) {
            i3 = eatArray(i3, key, args2);
          } else if (checkAllAliases(key, flags8.nargs) !== false) {
            i3 = eatNargs(i3, key, args2);
          } else {
            next = args2[i3 + 1];
            if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags8.bools) && !checkAllAliases(key, flags8.counts)) {
              setArg(key, next);
              i3++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i3++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args2[i3 + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags8.bools) && !checkAllAliases(key, flags8.counts)) {
            setArg(key, next);
            i3++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j = 0; j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === "=") {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags8.arrays)) {
              i3 = eatArray(i3, key, args2, value);
            } else if (checkAllAliases(key, flags8.nargs) !== false) {
              i3 = eatNargs(i3, key, args2, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags8.bools) === false) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags8.arrays)) {
            i3 = eatArray(i3, key, args2);
          } else if (checkAllAliases(key, flags8.nargs) !== false) {
            i3 = eatNargs(i3, key, args2);
          } else {
            next = args2[i3 + 1];
            if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags8.bools) && !checkAllAliases(key, flags8.counts)) {
              setArg(key, next);
              i3++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i3++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags8.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args2.slice(i3 + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args2.slice(i3);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags8.aliases, defaults2, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags8.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase$1(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i3, key, args3, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags8.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i3;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args3.length - (i3 + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i3 + 1; ii < args3.length; ii++) {
          if (!args3[ii].match(/^-[^0-9]/) || args3[ii].match(negative) || isUnknownOptionAsArg(args3[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i3 + 1; ii < consumed + i3 + 1; ii++) {
        setArg(key, args3[ii]);
      }
      return i3 + consumed;
    }
    function eatArray(i3, key, args3, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args3[i3 + 1];
      const nargsCount = checkAllAliases(key, flags8.nargs);
      if (checkAllAliases(key, flags8.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults2[key] !== void 0) {
          const defVal = defaults2[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i3 + 1; ii < args3.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args3[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i3 = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i3;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase$1(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags8.aliases[key]) {
        flags8.aliases[key].forEach(function(x) {
          const keyProperties = x.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags8.aliases[splitKey[0]] || []).forEach(function(x) {
          let keyProperties = x.split(".");
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags8.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags8.normalize) && !checkAllAliases(key, flags8.arrays)) {
        const keys = [key].concat(flags8.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags8.aliases[key] && flags8.aliases[key].length)) {
        flags8.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags8.aliases[alias] && flags8.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags8.bools) || checkAllAliases(key, flags8.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v) {
        return maybeCoerceNumber(key, v);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags8.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags8.normalize) && checkAllAliases(key, flags8.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin.normalize(val2);
          });
        else
          value = mixin.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags8.strings) && !checkAllAliases(key, flags8.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags8.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = /* @__PURE__ */ Object.create(null);
      applyDefaultsAndAliases(configLookup, flags8.aliases, defaults2);
      Object.keys(flags8.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
            const resolveConfig = flags8.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function(key) {
        const value = config[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags8.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env2 = mixin.env();
      Object.keys(env2).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i3) {
            if (i3 === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase$1(key);
          });
          if ((configOnly && flags8.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env2[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = /* @__PURE__ */ new Set();
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags8.coercions);
          if (typeof coerce === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags8.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err2) {
              error = err2;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags8.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = void 0;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults3, canLog = false) {
      Object.keys(defaults3).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults3[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x) {
            if (hasKey(obj, x.split(".")))
              return;
            setKey(obj, x.split("."), defaults3[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== "object")
        return false;
      else
        return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === "object" && o[key2] === void 0) {
          o[key2] = {};
        }
        if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags8.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags8.nargs)) {
        duplicate = true;
        if (!isUndefined(o[key]) && flags8.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags8.nargs[key]) {
          o[key] = void 0;
        }
      }
      if (value === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === void 0 && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags8.counts) || checkAllAliases(key, flags8.bools))) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args3) {
      args3.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags8.aliases[key])
            return;
          flags8.aliases[key] = [].concat(aliases[key] || []);
          flags8.aliases[key].concat(key).forEach(function(x) {
            if (/-/.test(x) && configuration["camel-case-expansion"]) {
              const c = camelCase$1(x);
              if (c !== key && flags8.aliases[key].indexOf(c) === -1) {
                flags8.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags8.aliases[key].concat(key).forEach(function(x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
              const c = decamelize$1(x, "-");
              if (c !== key && flags8.aliases[key].indexOf(c) === -1) {
                flags8.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags8.aliases[key].forEach(function(x) {
            flags8.aliases[x] = [key].concat(flags8.aliases[key].filter(function(y) {
              return x !== y;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags8.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags8);
      const toCheck = [].concat(flagsKeys.map((k) => flags8[k]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags8.bools) && !checkAllAliases(key, flags8.counts) && `${key}` in defaults2) {
        return defaults2[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: void 0,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags8.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags8.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags8.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags8.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === void 0;
    }
    function checkConfiguration() {
      Object.keys(flags8.counts).find((key) => {
        if (checkAllAliases(key, flags8.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags8.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags8.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
};
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = /* @__PURE__ */ Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i3 = 0; i3 < aliasArrays.length; i3++) {
      for (let ii = i3 + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i3].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i3] = aliasArrays[i3].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i3, self2) {
      return self2.indexOf(v) === i3;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== void 0 && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}
var _a;
var _b;
var _c;
var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
var nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
var env$2 = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env$2;
  },
  format,
  normalize: normalize$1,
  resolve: resolve2,
  require: (path2) => {
    if (typeof __require !== "undefined") {
      return __require(path2);
    } else if (path2.match(/\.json$/)) {
      return JSON.parse(readFileSync(path2, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
var yargsParser = function Parser2(args2, opts) {
  const result = parser.parse(args2.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args2, opts) {
  return parser.parse(args2.slice(), opts);
};
yargsParser.camelCase = camelCase$1;
yargsParser.decamelize = decamelize$1;
yargsParser.looksLikeNumber = looksLikeNumber;
var isObject$3 = (value) => typeof value === "object" && value !== null;
var isObjectCustom$1 = (value) => isObject$3(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var mapObjectSkip$1 = Symbol("mapObjectSkip");
var _mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
  options = {
    deep: false,
    target: {},
    ...options
  };
  if (isSeen.has(object)) {
    return isSeen.get(object);
  }
  isSeen.set(object, options.target);
  const { target } = options;
  delete options.target;
  const mapArray = (array) => array.map((element) => isObjectCustom$1(element) ? _mapObject(element, mapper, options, isSeen) : element);
  if (Array.isArray(object)) {
    return mapArray(object);
  }
  for (const [key, value] of Object.entries(object)) {
    const mapResult = mapper(key, value, object);
    if (mapResult === mapObjectSkip$1) {
      continue;
    }
    let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
    if (newKey === "__proto__") {
      continue;
    }
    if (options.deep && shouldRecurse && isObjectCustom$1(newValue)) {
      newValue = Array.isArray(newValue) ? mapArray(newValue) : _mapObject(newValue, mapper, options, isSeen);
    }
    target[newKey] = newValue;
  }
  return target;
};
function mapObject$2(object, mapper, options) {
  if (!isObject$3(object)) {
    throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
  }
  return _mapObject(object, mapper, options);
}
var UPPERCASE = /[\p{Lu}]/u;
var LOWERCASE = /[\p{Ll}]/u;
var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
var IDENTIFIER$1 = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[_.\- ]+/;
var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER$1.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER$1.source, "gu");
var preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  let isLastLastCharPreserved = false;
  for (let index = 0; index < string.length; index++) {
    const character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, index) + "-" + string.slice(index);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      index++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2)) {
      string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (match) => toLowerCase(match));
};
var postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier2) => toUpperCase(identifier2));
};
function camelCase(input, options) {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = {
    pascalCase: false,
    preserveConsecutiveUppercase: false,
    ...options
  };
  if (Array.isArray(input)) {
    input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
  const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  if (input.length === 1) {
    if (SEPARATORS.test(input)) {
      return "";
    }
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
}
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _emitEvictions(cache2) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache2) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache2) {
    const item = cache2.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
    return this;
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i3 = items.length - 1; i3 >= 0; --i3) {
      const item = items[i3];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i3 = items.length - 1; i3 >= 0; --i3) {
      const item = items[i3];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};
var has$1 = (array, key) => array.some((element) => {
  if (typeof element === "string") {
    return element === key;
  }
  element.lastIndex = 0;
  return element.test(key);
});
var cache$2 = new QuickLRU({ maxSize: 1e5 });
var isObject$2 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var transform$1 = (input, options = {}) => {
  if (!isObject$2(input)) {
    return input;
  }
  const {
    exclude,
    pascalCase = false,
    stopPaths,
    deep = false,
    preserveConsecutiveUppercase: preserveConsecutiveUppercase2 = false
  } = options;
  const stopPathsSet = new Set(stopPaths);
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject$2(value)) {
      const path2 = parentPath === void 0 ? key : `${parentPath}.${key}`;
      if (!stopPathsSet.has(path2)) {
        value = mapObject$2(value, makeMapper(path2));
      }
    }
    if (!(exclude && has$1(exclude, key))) {
      const cacheKey = pascalCase ? `${key}_` : key;
      if (cache$2.has(cacheKey)) {
        key = cache$2.get(cacheKey);
      } else {
        const returnValue = camelCase(key, { pascalCase, locale: false, preserveConsecutiveUppercase: preserveConsecutiveUppercase2 });
        if (key.length < 100) {
          cache$2.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return mapObject$2(input, makeMapper(void 0));
};
function camelcaseKeys(input, options) {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => transform$1(input[key], options));
  }
  return transform$1(input, options);
}
function trimNewlines(string) {
  let start2 = 0;
  let end = string.length;
  while (start2 < end && (string[start2] === "\r" || string[start2] === "\n")) {
    start2++;
  }
  while (end > start2 && (string[end - 1] === "\r" || string[end - 1] === "\n")) {
    end--;
  }
  return start2 > 0 || end < string.length ? string.slice(start2, end) : string;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var minIndent = (string) => {
  const match = string.match(/^[ \t]*(?=\S)/gm);
  if (!match) {
    return 0;
  }
  return match.reduce((r3, a) => Math.min(r3, a.length), Infinity);
};
var minIndent$1 = getDefaultExportFromCjs(minIndent);
function stripIndent(string) {
  const indent = minIndent$1(string);
  if (indent === 0) {
    return string;
  }
  const regex = new RegExp(`^[ \\t]{${indent}}`, "gm");
  return string.replace(regex, "");
}
function indentString(string, count = 1, options = {}) {
  const {
    indent = " ",
    includeEmptyLines = false
  } = options;
  if (typeof string !== "string") {
    throw new TypeError(
      `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
    );
  }
  if (typeof count !== "number") {
    throw new TypeError(
      `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
    );
  }
  if (count < 0) {
    throw new RangeError(
      `Expected \`count\` to be at least 0, got \`${count}\``
    );
  }
  if (typeof indent !== "string") {
    throw new TypeError(
      `Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``
    );
  }
  if (count === 0) {
    return string;
  }
  const regex = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex, indent.repeat(count));
}
function redent(string, count = 0, options = {}) {
  return indentString(stripIndent(string), count, options);
}
var debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args2) => console.error("SEMVER", ...args2) : () => {
};
var debug_1 = debug$1;
var SEMVER_SPEC_VERSION = "2.0.0";
var MAX_LENGTH$1 = 256;
var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MAX_SAFE_COMPONENT_LENGTH = 16;
var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
var RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
var re$1 = { exports: {} };
(function(module3, exports) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports = module3.exports = {};
  const re2 = exports.re = [];
  const safeRe = exports.safeRe = [];
  const src = exports.src = [];
  const t5 = exports.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name2, index, value);
    t5[name2] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})\\.(${src[t5.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})\\.(${src[t5.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t5.NUMERICIDENTIFIER]}|${src[t5.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t5.NUMERICIDENTIFIERLOOSE]}|${src[t5.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t5.PRERELEASEIDENTIFIER]}(?:\\.${src[t5.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t5.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t5.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t5.BUILDIDENTIFIER]}(?:\\.${src[t5.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t5.MAINVERSION]}${src[t5.PRERELEASE]}?${src[t5.BUILD]}?`);
  createToken("FULL", `^${src[t5.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t5.MAINVERSIONLOOSE]}${src[t5.PRERELEASELOOSE]}?${src[t5.BUILD]}?`);
  createToken("LOOSE", `^${src[t5.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t5.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t5.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:\\.(${src[t5.XRANGEIDENTIFIER]})(?:${src[t5.PRERELEASE]})?${src[t5.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t5.XRANGEIDENTIFIERLOOSE]})(?:${src[t5.PRERELEASELOOSE]})?${src[t5.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t5.GTLT]}\\s*${src[t5.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t5.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t5.COERCEPLAIN] + `(?:${src[t5.PRERELEASE]})?(?:${src[t5.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t5.COERCE], true);
  createToken("COERCERTLFULL", src[t5.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t5.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t5.LONETILDE]}${src[t5.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t5.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t5.LONECARET]}${src[t5.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t5.GTLT]}\\s*(${src[t5.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t5.GTLT]}\\s*(${src[t5.LOOSEPLAIN]}|${src[t5.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t5.XRANGEPLAIN]})\\s+-\\s+(${src[t5.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t5.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t5.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$1, re$1.exports);
var reExports = re$1.exports;
var looseOption = Object.freeze({ loose: true });
var emptyOpts = Object.freeze({});
var parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
var numeric = /^[0-9]+$/;
var compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
var rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
var debug = debug_1;
var { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
var { safeRe: re, t: t4 } = reExports;
var parseOptions = parseOptions_1;
var { compareIdentifiers } = identifiers;
var SemVer$1 = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re[t4.LOOSE] : re[t4.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i3 = 0;
    do {
      const a = this.prerelease[i3];
      const b = other.prerelease[i3];
      debug("prerelease compare", i3, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i3);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i3 = 0;
    do {
      const a = this.build[i3];
      const b = other.build[i3];
      debug("prerelease compare", i3, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i3);
  }
  inc(release, identifier2, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier2, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier2, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier2, identifierBase);
        this.inc("pre", identifier2, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier2, identifierBase);
        }
        this.inc("pre", identifier2, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier2 && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            if (identifier2 === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier2) {
          let prerelease = [identifier2, base];
          if (identifierBase === false) {
            prerelease = [identifier2];
          }
          if (compareIdentifiers(this.prerelease[0], identifier2) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease;
            }
          } else {
            this.prerelease = prerelease;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver = SemVer$1;
var SemVer2 = semver;
var parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer2) {
    return version;
  }
  try {
    return new SemVer2(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
var parse$5 = parse_1;
var valid$1 = (version, options) => {
  const v = parse$5(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
var parse$4 = parse_1;
var clean = (version, options) => {
  const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean;
var require$$1$3 = [
  "0BSD",
  "AAL",
  "ADSL",
  "AFL-1.1",
  "AFL-1.2",
  "AFL-2.0",
  "AFL-2.1",
  "AFL-3.0",
  "AGPL-1.0-only",
  "AGPL-1.0-or-later",
  "AGPL-3.0-only",
  "AGPL-3.0-or-later",
  "AMDPLPA",
  "AML",
  "AMPAS",
  "ANTLR-PD",
  "ANTLR-PD-fallback",
  "APAFML",
  "APL-1.0",
  "APSL-1.0",
  "APSL-1.1",
  "APSL-1.2",
  "APSL-2.0",
  "ASWF-Digital-Assets-1.0",
  "ASWF-Digital-Assets-1.1",
  "Abstyles",
  "AdaCore-doc",
  "Adobe-2006",
  "Adobe-Glyph",
  "Adobe-Utopia",
  "Afmparse",
  "Aladdin",
  "Apache-1.0",
  "Apache-1.1",
  "Apache-2.0",
  "App-s2p",
  "Arphic-1999",
  "Artistic-1.0",
  "Artistic-1.0-Perl",
  "Artistic-1.0-cl8",
  "Artistic-2.0",
  "BSD-1-Clause",
  "BSD-2-Clause",
  "BSD-2-Clause-Patent",
  "BSD-2-Clause-Views",
  "BSD-3-Clause",
  "BSD-3-Clause-Attribution",
  "BSD-3-Clause-Clear",
  "BSD-3-Clause-HP",
  "BSD-3-Clause-LBNL",
  "BSD-3-Clause-Modification",
  "BSD-3-Clause-No-Military-License",
  "BSD-3-Clause-No-Nuclear-License",
  "BSD-3-Clause-No-Nuclear-License-2014",
  "BSD-3-Clause-No-Nuclear-Warranty",
  "BSD-3-Clause-Open-MPI",
  "BSD-3-Clause-Sun",
  "BSD-3-Clause-flex",
  "BSD-4-Clause",
  "BSD-4-Clause-Shortened",
  "BSD-4-Clause-UC",
  "BSD-4.3RENO",
  "BSD-4.3TAHOE",
  "BSD-Advertising-Acknowledgement",
  "BSD-Attribution-HPND-disclaimer",
  "BSD-Inferno-Nettverk",
  "BSD-Protection",
  "BSD-Source-Code",
  "BSD-Systemics",
  "BSL-1.0",
  "BUSL-1.1",
  "Baekmuk",
  "Bahyph",
  "Barr",
  "Beerware",
  "BitTorrent-1.0",
  "BitTorrent-1.1",
  "Bitstream-Charter",
  "Bitstream-Vera",
  "BlueOak-1.0.0",
  "Boehm-GC",
  "Borceux",
  "Brian-Gladman-3-Clause",
  "C-UDA-1.0",
  "CAL-1.0",
  "CAL-1.0-Combined-Work-Exception",
  "CATOSL-1.1",
  "CC-BY-1.0",
  "CC-BY-2.0",
  "CC-BY-2.5",
  "CC-BY-2.5-AU",
  "CC-BY-3.0",
  "CC-BY-3.0-AT",
  "CC-BY-3.0-DE",
  "CC-BY-3.0-IGO",
  "CC-BY-3.0-NL",
  "CC-BY-3.0-US",
  "CC-BY-4.0",
  "CC-BY-NC-1.0",
  "CC-BY-NC-2.0",
  "CC-BY-NC-2.5",
  "CC-BY-NC-3.0",
  "CC-BY-NC-3.0-DE",
  "CC-BY-NC-4.0",
  "CC-BY-NC-ND-1.0",
  "CC-BY-NC-ND-2.0",
  "CC-BY-NC-ND-2.5",
  "CC-BY-NC-ND-3.0",
  "CC-BY-NC-ND-3.0-DE",
  "CC-BY-NC-ND-3.0-IGO",
  "CC-BY-NC-ND-4.0",
  "CC-BY-NC-SA-1.0",
  "CC-BY-NC-SA-2.0",
  "CC-BY-NC-SA-2.0-DE",
  "CC-BY-NC-SA-2.0-FR",
  "CC-BY-NC-SA-2.0-UK",
  "CC-BY-NC-SA-2.5",
  "CC-BY-NC-SA-3.0",
  "CC-BY-NC-SA-3.0-DE",
  "CC-BY-NC-SA-3.0-IGO",
  "CC-BY-NC-SA-4.0",
  "CC-BY-ND-1.0",
  "CC-BY-ND-2.0",
  "CC-BY-ND-2.5",
  "CC-BY-ND-3.0",
  "CC-BY-ND-3.0-DE",
  "CC-BY-ND-4.0",
  "CC-BY-SA-1.0",
  "CC-BY-SA-2.0",
  "CC-BY-SA-2.0-UK",
  "CC-BY-SA-2.1-JP",
  "CC-BY-SA-2.5",
  "CC-BY-SA-3.0",
  "CC-BY-SA-3.0-AT",
  "CC-BY-SA-3.0-DE",
  "CC-BY-SA-3.0-IGO",
  "CC-BY-SA-4.0",
  "CC-PDDC",
  "CC0-1.0",
  "CDDL-1.0",
  "CDDL-1.1",
  "CDL-1.0",
  "CDLA-Permissive-1.0",
  "CDLA-Permissive-2.0",
  "CDLA-Sharing-1.0",
  "CECILL-1.0",
  "CECILL-1.1",
  "CECILL-2.0",
  "CECILL-2.1",
  "CECILL-B",
  "CECILL-C",
  "CERN-OHL-1.1",
  "CERN-OHL-1.2",
  "CERN-OHL-P-2.0",
  "CERN-OHL-S-2.0",
  "CERN-OHL-W-2.0",
  "CFITSIO",
  "CMU-Mach",
  "CNRI-Jython",
  "CNRI-Python",
  "CNRI-Python-GPL-Compatible",
  "COIL-1.0",
  "CPAL-1.0",
  "CPL-1.0",
  "CPOL-1.02",
  "CUA-OPL-1.0",
  "Caldera",
  "ClArtistic",
  "Clips",
  "Community-Spec-1.0",
  "Condor-1.1",
  "Cornell-Lossless-JPEG",
  "Cronyx",
  "Crossword",
  "CrystalStacker",
  "Cube",
  "D-FSL-1.0",
  "DL-DE-BY-2.0",
  "DL-DE-ZERO-2.0",
  "DOC",
  "DRL-1.0",
  "DSDP",
  "Dotseqn",
  "ECL-1.0",
  "ECL-2.0",
  "EFL-1.0",
  "EFL-2.0",
  "EPICS",
  "EPL-1.0",
  "EPL-2.0",
  "EUDatagrid",
  "EUPL-1.0",
  "EUPL-1.1",
  "EUPL-1.2",
  "Elastic-2.0",
  "Entessa",
  "ErlPL-1.1",
  "Eurosym",
  "FBM",
  "FDK-AAC",
  "FSFAP",
  "FSFUL",
  "FSFULLR",
  "FSFULLRWD",
  "FTL",
  "Fair",
  "Ferguson-Twofish",
  "Frameworx-1.0",
  "FreeBSD-DOC",
  "FreeImage",
  "Furuseth",
  "GD",
  "GFDL-1.1-invariants-only",
  "GFDL-1.1-invariants-or-later",
  "GFDL-1.1-no-invariants-only",
  "GFDL-1.1-no-invariants-or-later",
  "GFDL-1.1-only",
  "GFDL-1.1-or-later",
  "GFDL-1.2-invariants-only",
  "GFDL-1.2-invariants-or-later",
  "GFDL-1.2-no-invariants-only",
  "GFDL-1.2-no-invariants-or-later",
  "GFDL-1.2-only",
  "GFDL-1.2-or-later",
  "GFDL-1.3-invariants-only",
  "GFDL-1.3-invariants-or-later",
  "GFDL-1.3-no-invariants-only",
  "GFDL-1.3-no-invariants-or-later",
  "GFDL-1.3-only",
  "GFDL-1.3-or-later",
  "GL2PS",
  "GLWTPL",
  "GPL-1.0-only",
  "GPL-1.0-or-later",
  "GPL-2.0-only",
  "GPL-2.0-or-later",
  "GPL-3.0-only",
  "GPL-3.0-or-later",
  "Giftware",
  "Glide",
  "Glulxe",
  "Graphics-Gems",
  "HP-1986",
  "HP-1989",
  "HPND",
  "HPND-DEC",
  "HPND-Markus-Kuhn",
  "HPND-Pbmplus",
  "HPND-UC",
  "HPND-doc",
  "HPND-doc-sell",
  "HPND-export-US",
  "HPND-export-US-modify",
  "HPND-sell-regexpr",
  "HPND-sell-variant",
  "HPND-sell-variant-MIT-disclaimer",
  "HTMLTIDY",
  "HaskellReport",
  "Hippocratic-2.1",
  "IBM-pibs",
  "ICU",
  "IEC-Code-Components-EULA",
  "IJG",
  "IJG-short",
  "IPA",
  "IPL-1.0",
  "ISC",
  "ImageMagick",
  "Imlib2",
  "Info-ZIP",
  "Inner-Net-2.0",
  "Intel",
  "Intel-ACPI",
  "Interbase-1.0",
  "JPL-image",
  "JPNIC",
  "JSON",
  "Jam",
  "JasPer-2.0",
  "Kastrup",
  "Kazlib",
  "Knuth-CTAN",
  "LAL-1.2",
  "LAL-1.3",
  "LGPL-2.0-only",
  "LGPL-2.0-or-later",
  "LGPL-2.1-only",
  "LGPL-2.1-or-later",
  "LGPL-3.0-only",
  "LGPL-3.0-or-later",
  "LGPLLR",
  "LOOP",
  "LPL-1.0",
  "LPL-1.02",
  "LPPL-1.0",
  "LPPL-1.1",
  "LPPL-1.2",
  "LPPL-1.3a",
  "LPPL-1.3c",
  "LZMA-SDK-9.11-to-9.20",
  "LZMA-SDK-9.22",
  "Latex2e",
  "Latex2e-translated-notice",
  "Leptonica",
  "LiLiQ-P-1.1",
  "LiLiQ-R-1.1",
  "LiLiQ-Rplus-1.1",
  "Libpng",
  "Linux-OpenIB",
  "Linux-man-pages-1-para",
  "Linux-man-pages-copyleft",
  "Linux-man-pages-copyleft-2-para",
  "Linux-man-pages-copyleft-var",
  "Lucida-Bitmap-Fonts",
  "MIT",
  "MIT-0",
  "MIT-CMU",
  "MIT-Festival",
  "MIT-Modern-Variant",
  "MIT-Wu",
  "MIT-advertising",
  "MIT-enna",
  "MIT-feh",
  "MIT-open-group",
  "MIT-testregex",
  "MITNFA",
  "MMIXware",
  "MPEG-SSG",
  "MPL-1.0",
  "MPL-1.1",
  "MPL-2.0",
  "MPL-2.0-no-copyleft-exception",
  "MS-LPL",
  "MS-PL",
  "MS-RL",
  "MTLL",
  "MakeIndex",
  "Martin-Birgmeier",
  "McPhee-slideshow",
  "Minpack",
  "MirOS",
  "Motosoto",
  "MulanPSL-1.0",
  "MulanPSL-2.0",
  "Multics",
  "Mup",
  "NAIST-2003",
  "NASA-1.3",
  "NBPL-1.0",
  "NCGL-UK-2.0",
  "NCSA",
  "NGPL",
  "NICTA-1.0",
  "NIST-PD",
  "NIST-PD-fallback",
  "NIST-Software",
  "NLOD-1.0",
  "NLOD-2.0",
  "NLPL",
  "NOSL",
  "NPL-1.0",
  "NPL-1.1",
  "NPOSL-3.0",
  "NRL",
  "NTP",
  "NTP-0",
  "Naumen",
  "Net-SNMP",
  "NetCDF",
  "Newsletr",
  "Nokia",
  "Noweb",
  "O-UDA-1.0",
  "OCCT-PL",
  "OCLC-2.0",
  "ODC-By-1.0",
  "ODbL-1.0",
  "OFFIS",
  "OFL-1.0",
  "OFL-1.0-RFN",
  "OFL-1.0-no-RFN",
  "OFL-1.1",
  "OFL-1.1-RFN",
  "OFL-1.1-no-RFN",
  "OGC-1.0",
  "OGDL-Taiwan-1.0",
  "OGL-Canada-2.0",
  "OGL-UK-1.0",
  "OGL-UK-2.0",
  "OGL-UK-3.0",
  "OGTSL",
  "OLDAP-1.1",
  "OLDAP-1.2",
  "OLDAP-1.3",
  "OLDAP-1.4",
  "OLDAP-2.0",
  "OLDAP-2.0.1",
  "OLDAP-2.1",
  "OLDAP-2.2",
  "OLDAP-2.2.1",
  "OLDAP-2.2.2",
  "OLDAP-2.3",
  "OLDAP-2.4",
  "OLDAP-2.5",
  "OLDAP-2.6",
  "OLDAP-2.7",
  "OLDAP-2.8",
  "OLFL-1.3",
  "OML",
  "OPL-1.0",
  "OPL-UK-3.0",
  "OPUBL-1.0",
  "OSET-PL-2.1",
  "OSL-1.0",
  "OSL-1.1",
  "OSL-2.0",
  "OSL-2.1",
  "OSL-3.0",
  "OpenPBS-2.3",
  "OpenSSL",
  "PADL",
  "PDDL-1.0",
  "PHP-3.0",
  "PHP-3.01",
  "PSF-2.0",
  "Parity-6.0.0",
  "Parity-7.0.0",
  "Plexus",
  "PolyForm-Noncommercial-1.0.0",
  "PolyForm-Small-Business-1.0.0",
  "PostgreSQL",
  "Python-2.0",
  "Python-2.0.1",
  "QPL-1.0",
  "QPL-1.0-INRIA-2004",
  "Qhull",
  "RHeCos-1.1",
  "RPL-1.1",
  "RPL-1.5",
  "RPSL-1.0",
  "RSA-MD",
  "RSCPL",
  "Rdisc",
  "Ruby",
  "SAX-PD",
  "SCEA",
  "SGI-B-1.0",
  "SGI-B-1.1",
  "SGI-B-2.0",
  "SGI-OpenGL",
  "SGP4",
  "SHL-0.5",
  "SHL-0.51",
  "SISSL",
  "SISSL-1.2",
  "SL",
  "SMLNJ",
  "SMPPL",
  "SNIA",
  "SPL-1.0",
  "SSH-OpenSSH",
  "SSH-short",
  "SSPL-1.0",
  "SWL",
  "Saxpath",
  "SchemeReport",
  "Sendmail",
  "Sendmail-8.23",
  "SimPL-2.0",
  "Sleepycat",
  "Soundex",
  "Spencer-86",
  "Spencer-94",
  "Spencer-99",
  "SugarCRM-1.1.3",
  "SunPro",
  "Symlinks",
  "TAPR-OHL-1.0",
  "TCL",
  "TCP-wrappers",
  "TMate",
  "TORQUE-1.1",
  "TOSL",
  "TPDL",
  "TPL-1.0",
  "TTWL",
  "TTYP0",
  "TU-Berlin-1.0",
  "TU-Berlin-2.0",
  "TermReadKey",
  "UCAR",
  "UCL-1.0",
  "UPL-1.0",
  "URT-RLE",
  "Unicode-DFS-2015",
  "Unicode-DFS-2016",
  "Unicode-TOU",
  "UnixCrypt",
  "Unlicense",
  "VOSTROM",
  "VSL-1.0",
  "Vim",
  "W3C",
  "W3C-19980720",
  "W3C-20150513",
  "WTFPL",
  "Watcom-1.0",
  "Widget-Workshop",
  "Wsuipa",
  "X11",
  "X11-distribute-modifications-variant",
  "XFree86-1.1",
  "XSkat",
  "Xdebug-1.03",
  "Xerox",
  "Xfig",
  "Xnet",
  "YPL-1.0",
  "YPL-1.1",
  "ZPL-1.1",
  "ZPL-2.0",
  "ZPL-2.1",
  "Zed",
  "Zeeff",
  "Zend-2.0",
  "Zimbra-1.3",
  "Zimbra-1.4",
  "Zlib",
  "blessing",
  "bzip2-1.0.6",
  "check-cvs",
  "checkmk",
  "copyleft-next-0.3.0",
  "copyleft-next-0.3.1",
  "curl",
  "diffmark",
  "dtoa",
  "dvipdfm",
  "eGenix",
  "etalab-2.0",
  "fwlw",
  "gSOAP-1.3b",
  "gnuplot",
  "iMatix",
  "libpng-2.0",
  "libselinux-1.0",
  "libtiff",
  "libutil-David-Nugent",
  "lsof",
  "magaz",
  "metamail",
  "mpi-permissive",
  "mpich2",
  "mplus",
  "pnmstitch",
  "psfrag",
  "psutils",
  "python-ldap",
  "snprintf",
  "ssh-keyscan",
  "swrule",
  "ulem",
  "w3m",
  "xinetd",
  "xlock",
  "xpp",
  "zlib-acknowledgement"
];
var require$$1$2 = [
  "AGPL-1.0",
  "AGPL-3.0",
  "BSD-2-Clause-FreeBSD",
  "BSD-2-Clause-NetBSD",
  "GFDL-1.1",
  "GFDL-1.2",
  "GFDL-1.3",
  "GPL-1.0",
  "GPL-1.0+",
  "GPL-2.0",
  "GPL-2.0+",
  "GPL-2.0-with-GCC-exception",
  "GPL-2.0-with-autoconf-exception",
  "GPL-2.0-with-bison-exception",
  "GPL-2.0-with-classpath-exception",
  "GPL-2.0-with-font-exception",
  "GPL-3.0",
  "GPL-3.0+",
  "GPL-3.0-with-GCC-exception",
  "GPL-3.0-with-autoconf-exception",
  "LGPL-2.0",
  "LGPL-2.0+",
  "LGPL-2.1",
  "LGPL-2.1+",
  "LGPL-3.0",
  "LGPL-3.0+",
  "Nunit",
  "StandardML-NJ",
  "bzip2-1.0.5",
  "eCos-2.0",
  "wxWindows"
];
var require$$2 = [
  "389-exception",
  "Asterisk-exception",
  "Autoconf-exception-2.0",
  "Autoconf-exception-3.0",
  "Autoconf-exception-generic",
  "Autoconf-exception-generic-3.0",
  "Autoconf-exception-macro",
  "Bison-exception-2.2",
  "Bootloader-exception",
  "Classpath-exception-2.0",
  "CLISP-exception-2.0",
  "cryptsetup-OpenSSL-exception",
  "DigiRule-FOSS-exception",
  "eCos-exception-2.0",
  "Fawkes-Runtime-exception",
  "FLTK-exception",
  "Font-exception-2.0",
  "freertos-exception-2.0",
  "GCC-exception-2.0",
  "GCC-exception-2.0-note",
  "GCC-exception-3.1",
  "GNAT-exception",
  "GNU-compiler-exception",
  "gnu-javamail-exception",
  "GPL-3.0-interface-exception",
  "GPL-3.0-linking-exception",
  "GPL-3.0-linking-source-exception",
  "GPL-CC-1.0",
  "GStreamer-exception-2005",
  "GStreamer-exception-2008",
  "i2p-gpl-java-exception",
  "KiCad-libraries-exception",
  "LGPL-3.0-linking-exception",
  "libpri-OpenH323-exception",
  "Libtool-exception",
  "Linux-syscall-note",
  "LLGPL",
  "LLVM-exception",
  "LZMA-exception",
  "mif-exception",
  "OCaml-LGPL-linking-exception",
  "OCCT-exception-1.0",
  "OpenJDK-assembly-exception-1.0",
  "openvpn-openssl-exception",
  "PS-or-PDF-font-exception-20170817",
  "QPL-1.0-INRIA-2004-exception",
  "Qt-GPL-exception-1.0",
  "Qt-LGPL-exception-1.1",
  "Qwt-exception-1.0",
  "SANE-exception",
  "SHL-2.0",
  "SHL-2.1",
  "stunnel-exception",
  "SWI-exception",
  "Swift-exception",
  "Texinfo-exception",
  "u-boot-exception-2.0",
  "UBDL-exception",
  "Universal-FOSS-exception-1.0",
  "vsftpd-openssl-exception",
  "WxWindows-exception-3.1",
  "x11vnc-openssl-exception"
];
var licenses = [].concat(require$$1$3).concat(require$$1$2);
var exceptions = require$$2;
var scan$1 = function(source) {
  var index = 0;
  function hasMore() {
    return index < source.length;
  }
  function read(value) {
    if (value instanceof RegExp) {
      var chars = source.slice(index);
      var match = chars.match(value);
      if (match) {
        index += match[0].length;
        return match[0];
      }
    } else {
      if (source.indexOf(value, index) === index) {
        index += value.length;
        return value;
      }
    }
  }
  function skipWhitespace() {
    read(/[ ]*/);
  }
  function operator() {
    var string;
    var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
    for (var i3 = 0; i3 < possibilities.length; i3++) {
      string = read(possibilities[i3]);
      if (string) {
        break;
      }
    }
    if (string === "+" && index > 1 && source[index - 2] === " ") {
      throw new Error("Space before `+`");
    }
    return string && {
      type: "OPERATOR",
      string
    };
  }
  function idstring() {
    return read(/[A-Za-z0-9-.]+/);
  }
  function expectIdstring() {
    var string = idstring();
    if (!string) {
      throw new Error("Expected idstring at offset " + index);
    }
    return string;
  }
  function documentRef() {
    if (read("DocumentRef-")) {
      var string = expectIdstring();
      return { type: "DOCUMENTREF", string };
    }
  }
  function licenseRef() {
    if (read("LicenseRef-")) {
      var string = expectIdstring();
      return { type: "LICENSEREF", string };
    }
  }
  function identifier2() {
    var begin = index;
    var string = idstring();
    if (licenses.indexOf(string) !== -1) {
      return {
        type: "LICENSE",
        string
      };
    } else if (exceptions.indexOf(string) !== -1) {
      return {
        type: "EXCEPTION",
        string
      };
    }
    index = begin;
  }
  function parseToken() {
    return operator() || documentRef() || licenseRef() || identifier2();
  }
  var tokens = [];
  while (hasMore()) {
    skipWhitespace();
    if (!hasMore()) {
      break;
    }
    var token = parseToken();
    if (!token) {
      throw new Error("Unexpected `" + source[index] + "` at offset " + index);
    }
    tokens.push(token);
  }
  return tokens;
};
var parse$3 = function(tokens) {
  var index = 0;
  function hasMore() {
    return index < tokens.length;
  }
  function token() {
    return hasMore() ? tokens[index] : null;
  }
  function next() {
    if (!hasMore()) {
      throw new Error();
    }
    index++;
  }
  function parseOperator(operator) {
    var t5 = token();
    if (t5 && t5.type === "OPERATOR" && operator === t5.string) {
      next();
      return t5.string;
    }
  }
  function parseWith() {
    if (parseOperator("WITH")) {
      var t5 = token();
      if (t5 && t5.type === "EXCEPTION") {
        next();
        return t5.string;
      }
      throw new Error("Expected exception after `WITH`");
    }
  }
  function parseLicenseRef() {
    var begin = index;
    var string = "";
    var t5 = token();
    if (t5.type === "DOCUMENTREF") {
      next();
      string += "DocumentRef-" + t5.string + ":";
      if (!parseOperator(":")) {
        throw new Error("Expected `:` after `DocumentRef-...`");
      }
    }
    t5 = token();
    if (t5.type === "LICENSEREF") {
      next();
      string += "LicenseRef-" + t5.string;
      return { license: string };
    }
    index = begin;
  }
  function parseLicense() {
    var t5 = token();
    if (t5 && t5.type === "LICENSE") {
      next();
      var node2 = { license: t5.string };
      if (parseOperator("+")) {
        node2.plus = true;
      }
      var exception = parseWith();
      if (exception) {
        node2.exception = exception;
      }
      return node2;
    }
  }
  function parseParenthesizedExpression() {
    var left = parseOperator("(");
    if (!left) {
      return;
    }
    var expr = parseExpression();
    if (!parseOperator(")")) {
      throw new Error("Expected `)`");
    }
    return expr;
  }
  function parseAtom() {
    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
  }
  function makeBinaryOpParser(operator, nextParser) {
    return function parseBinaryOp() {
      var left = nextParser();
      if (!left) {
        return;
      }
      if (!parseOperator(operator)) {
        return left;
      }
      var right = parseBinaryOp();
      if (!right) {
        throw new Error("Expected expression");
      }
      return {
        left,
        conjunction: operator.toLowerCase(),
        right
      };
    };
  }
  var parseAnd = makeBinaryOpParser("AND", parseAtom);
  var parseExpression = makeBinaryOpParser("OR", parseAnd);
  var node = parseExpression();
  if (!node || hasMore()) {
    throw new Error("Syntax error");
  }
  return node;
};
var scan = scan$1;
var parse$2 = parse$3;
var spdxExpressionParse = function(source) {
  return parse$2(scan(source));
};
var parse$1 = spdxExpressionParse;
var spdxLicenseIds = require$$1$3;
function valid(string) {
  try {
    parse$1(string);
    return true;
  } catch (error) {
    return false;
  }
}
function sortTranspositions(a, b) {
  var length = b[0].length - a[0].length;
  if (length !== 0) return length;
  return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
}
var transpositions = [
  ["APGL", "AGPL"],
  ["Gpl", "GPL"],
  ["GLP", "GPL"],
  ["APL", "Apache"],
  ["ISD", "ISC"],
  ["GLP", "GPL"],
  ["IST", "ISC"],
  ["Claude", "Clause"],
  [" or later", "+"],
  [" International", ""],
  ["GNU", "GPL"],
  ["GUN", "GPL"],
  ["+", ""],
  ["GNU GPL", "GPL"],
  ["GNU LGPL", "LGPL"],
  ["GNU/GPL", "GPL"],
  ["GNU GLP", "GPL"],
  ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
  ["GNU Lesser General Public License", "LGPL"],
  ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
  ["GNU Lesser General Public License", "LGPL-2.1"],
  ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
  ["Lesser General Public License", "LGPL"],
  ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
  ["Lesser General Public License", "LGPL-2.1"],
  ["GNU General Public License", "GPL"],
  ["Gnu public license", "GPL"],
  ["GNU Public License", "GPL"],
  ["GNU GENERAL PUBLIC LICENSE", "GPL"],
  ["MTI", "MIT"],
  ["Mozilla Public License", "MPL"],
  ["Universal Permissive License", "UPL"],
  ["WTH", "WTF"],
  ["WTFGPL", "WTFPL"],
  ["-License", ""]
].sort(sortTranspositions);
var TRANSPOSED = 0;
var CORRECT = 1;
var transforms = [
  function(argument) {
    return argument.toUpperCase();
  },
  function(argument) {
    return argument.trim();
  },
  function(argument) {
    return argument.replace(/\./g, "");
  },
  function(argument) {
    return argument.replace(/\s+/g, "");
  },
  function(argument) {
    return argument.replace(/\s+/g, "-");
  },
  function(argument) {
    return argument.replace("v", "-");
  },
  function(argument) {
    return argument.replace(/,?\s*(\d)/, "-$1");
  },
  function(argument) {
    return argument.replace(/,?\s*(\d)/, "-$1.0");
  },
  function(argument) {
    return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
  },
  function(argument) {
    return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
  },
  function(argument) {
    return argument[0].toUpperCase() + argument.slice(1);
  },
  function(argument) {
    return argument.replace("/", "-");
  },
  function(argument) {
    return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
  },
  function(argument) {
    if (argument.indexOf("3.0") !== -1) {
      return argument + "-or-later";
    } else {
      return argument + "-only";
    }
  },
  function(argument) {
    return argument + "only";
  },
  function(argument) {
    return argument.replace(/(\d)$/, "-$1.0");
  },
  function(argument) {
    return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
  },
  function(argument) {
    return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
  },
  function(argument) {
    return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
  },
  function(argument) {
    return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
  },
  function(argument) {
    return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
  },
  function(argument) {
    return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
  },
  function(argument) {
    return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
  },
  function(argument) {
    return "CC-" + argument;
  },
  function(argument) {
    return "CC-" + argument + "-4.0";
  },
  function(argument) {
    return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
  },
  function(argument) {
    return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
  }
];
var licensesWithVersions = spdxLicenseIds.map(function(id) {
  var match = /^(.*)-\d+\.\d+$/.exec(id);
  return match ? [match[0], match[1]] : [id, null];
}).reduce(function(objectMap, item) {
  var key = item[1];
  objectMap[key] = objectMap[key] || [];
  objectMap[key].push(item[0]);
  return objectMap;
}, {});
var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
  return [key, licensesWithVersions[key]];
}).filter(function identifySoleVersions(item) {
  return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
}).map(function createLastResorts(item) {
  return [item[0], item[1][0]];
});
licensesWithVersions = void 0;
var lastResorts = [
  ["UNLI", "Unlicense"],
  ["WTF", "WTFPL"],
  ["2 CLAUSE", "BSD-2-Clause"],
  ["2-CLAUSE", "BSD-2-Clause"],
  ["3 CLAUSE", "BSD-3-Clause"],
  ["3-CLAUSE", "BSD-3-Clause"],
  ["AFFERO", "AGPL-3.0-or-later"],
  ["AGPL", "AGPL-3.0-or-later"],
  ["APACHE", "Apache-2.0"],
  ["ARTISTIC", "Artistic-2.0"],
  ["Affero", "AGPL-3.0-or-later"],
  ["BEER", "Beerware"],
  ["BOOST", "BSL-1.0"],
  ["BSD", "BSD-2-Clause"],
  ["CDDL", "CDDL-1.1"],
  ["ECLIPSE", "EPL-1.0"],
  ["FUCK", "WTFPL"],
  ["GNU", "GPL-3.0-or-later"],
  ["LGPL", "LGPL-3.0-or-later"],
  ["GPLV1", "GPL-1.0-only"],
  ["GPL-1", "GPL-1.0-only"],
  ["GPLV2", "GPL-2.0-only"],
  ["GPL-2", "GPL-2.0-only"],
  ["GPL", "GPL-3.0-or-later"],
  ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
  ["MIT", "MIT"],
  ["MPL", "MPL-2.0"],
  ["X11", "X11"],
  ["ZLIB", "Zlib"]
].concat(licensesWithOneVersion).sort(sortTranspositions);
var SUBSTRING = 0;
var IDENTIFIER = 1;
var validTransformation = function(identifier2) {
  for (var i3 = 0; i3 < transforms.length; i3++) {
    var transformed = transforms[i3](identifier2).trim();
    if (transformed !== identifier2 && valid(transformed)) {
      return transformed;
    }
  }
  return null;
};
var validLastResort = function(identifier2) {
  var upperCased = identifier2.toUpperCase();
  for (var i3 = 0; i3 < lastResorts.length; i3++) {
    var lastResort = lastResorts[i3];
    if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
      return lastResort[IDENTIFIER];
    }
  }
  return null;
};
var anyCorrection = function(identifier2, check) {
  for (var i3 = 0; i3 < transpositions.length; i3++) {
    var transposition = transpositions[i3];
    var transposed = transposition[TRANSPOSED];
    if (identifier2.indexOf(transposed) > -1) {
      var corrected = identifier2.replace(
        transposed,
        transposition[CORRECT]
      );
      var checked = check(corrected);
      if (checked !== null) {
        return checked;
      }
    }
  }
  return null;
};
var spdxCorrect = function(identifier2, options) {
  options = options || {};
  var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
  function postprocess(value) {
    return upgrade ? upgradeGPLs(value) : value;
  }
  var validArugment = typeof identifier2 === "string" && identifier2.trim().length !== 0;
  if (!validArugment) {
    throw Error("Invalid argument. Expected non-empty string.");
  }
  identifier2 = identifier2.trim();
  if (valid(identifier2)) {
    return postprocess(identifier2);
  }
  var noPlus = identifier2.replace(/\+$/, "").trim();
  if (valid(noPlus)) {
    return postprocess(noPlus);
  }
  var transformed = validTransformation(identifier2);
  if (transformed !== null) {
    return postprocess(transformed);
  }
  transformed = anyCorrection(identifier2, function(argument) {
    if (valid(argument)) {
      return argument;
    }
    return validTransformation(argument);
  });
  if (transformed !== null) {
    return postprocess(transformed);
  }
  transformed = validLastResort(identifier2);
  if (transformed !== null) {
    return postprocess(transformed);
  }
  transformed = anyCorrection(identifier2, validLastResort);
  if (transformed !== null) {
    return postprocess(transformed);
  }
  return null;
};
function upgradeGPLs(value) {
  if ([
    "GPL-1.0",
    "LGPL-1.0",
    "AGPL-1.0",
    "GPL-2.0",
    "LGPL-2.0",
    "AGPL-2.0",
    "LGPL-2.1"
  ].indexOf(value) !== -1) {
    return value + "-only";
  } else if ([
    "GPL-1.0+",
    "GPL-2.0+",
    "GPL-3.0+",
    "LGPL-2.0+",
    "LGPL-2.1+",
    "LGPL-3.0+",
    "AGPL-1.0+",
    "AGPL-3.0+"
  ].indexOf(value) !== -1) {
    return value.replace(/\+$/, "-or-later");
  } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
    return value + "-or-later";
  } else {
    return value;
  }
}
var parse = spdxExpressionParse;
var correct = spdxCorrect;
var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
function startsWith(prefix, string) {
  return string.slice(0, prefix.length) === prefix;
}
function usesLicenseRef(ast) {
  if (ast.hasOwnProperty("license")) {
    var license = ast.license;
    return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
  } else {
    return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
  }
}
var validateNpmPackageLicense = function(argument) {
  var ast;
  try {
    ast = parse(argument);
  } catch (e) {
    var match;
    if (argument === "UNLICENSED" || argument === "UNLICENCED") {
      return {
        validForOldPackages: true,
        validForNewPackages: true,
        unlicensed: true
      };
    } else if (match = fileReferenceRE.exec(argument)) {
      return {
        validForOldPackages: true,
        validForNewPackages: true,
        inFile: match[1]
      };
    } else {
      var result = {
        validForOldPackages: false,
        validForNewPackages: false,
        warnings: [genericWarning]
      };
      if (argument.trim().length !== 0) {
        var corrected = correct(argument);
        if (corrected) {
          result.warnings.push(
            'license is similar to the valid expression "' + corrected + '"'
          );
        }
      }
      return result;
    }
  }
  if (usesLicenseRef(ast)) {
    return {
      validForNewPackages: false,
      validForOldPackages: false,
      spdx: true,
      warnings: [genericWarning]
    };
  } else {
    return {
      validForNewPackages: true,
      validForOldPackages: true,
      spdx: true
    };
  }
};
var commonjs = {};
Object.defineProperty(commonjs, "__esModule", { value: true });
commonjs.LRUCache = void 0;
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var isPosInt = (n3) => n3 && n3 === Math.floor(n3) && n3 > 0 && isFinite(n3);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  static #constructing = false;
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max2, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max2, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  push(n3) {
    this.heap[this.length++] = n3;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache$1 = class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    this.#max = max2;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max2).fill(void 0);
    this.#valList = new Array(max2).fill(void 0);
    this.#next = new UintArray(max2);
    this.#prev = new UintArray(max2);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max2);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start2 = perf.now()) => {
      starts[index] = ttl !== 0 ? start2 : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t5 = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t5.unref) {
          t5.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start2 = starts[index];
        if (!ttl || !start2)
          return;
        status.ttl = ttl;
        status.start = start2;
        status.now = cachedNow || getNow();
        const age = status.now - start2;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n3 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n3;
        const t5 = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t5.unref) {
          t5.unref();
        }
      }
      return n3;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start2 = starts[index];
      if (!ttl || !start2) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start2;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t5 = ttls[index];
      return !!t5 && !!s && (cachedNow || getNow()) - s > t5;
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i3 = this.#tail; true; ) {
        if (!this.#isValidIndex(i3)) {
          break;
        }
        if (allowStale || !this.#isStale(i3)) {
          yield i3;
        }
        if (i3 === this.#head) {
          break;
        } else {
          i3 = this.#prev[i3];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i3 = this.#head; true; ) {
        if (!this.#isValidIndex(i3)) {
          break;
        }
        if (allowStale || !this.#isStale(i3)) {
          yield i3;
        }
        if (i3 === this.#tail) {
          break;
        } else {
          i3 = this.#next[i3];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i3 of this.#indexes()) {
      if (this.#valList[i3] !== void 0 && this.#keyList[i3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield [this.#keyList[i3], this.#valList[i3]];
      }
    }
  }
  *rentries() {
    for (const i3 of this.#rindexes()) {
      if (this.#valList[i3] !== void 0 && this.#keyList[i3] !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield [this.#keyList[i3], this.#valList[i3]];
      }
    }
  }
  *keys() {
    for (const i3 of this.#indexes()) {
      const k = this.#keyList[i3];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i3 of this.#rindexes()) {
      const k = this.#keyList[i3];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i3 of this.#indexes()) {
      const v = this.#valList[i3];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield this.#valList[i3];
      }
    }
  }
  *rvalues() {
    for (const i3 of this.#rindexes()) {
      const v = this.#valList[i3];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i3])) {
        yield this.#valList[i3];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i3 of this.#indexes()) {
      const v = this.#valList[i3];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i3], this)) {
        return this.get(this.#keyList[i3], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i3 of this.#indexes()) {
      const v = this.#valList[i3];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i3], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i3 of this.#rindexes()) {
      const v = this.#valList[i3];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i3], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i3 of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i3)) {
        this.delete(this.#keyList[i3]);
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i3 = this.#keyMap.get(key);
    if (i3 === void 0)
      return void 0;
    const v = this.#valList[i3];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i3];
      const start2 = this.#starts[i3];
      if (ttl && start2) {
        const remain = ttl - (perf.now() - start2);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i3];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i3 of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i3];
      const v = this.#valList[i3];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i3];
        const age = perf.now() - this.#starts[i3];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i3];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start: start2, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start2);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n3) {
    this.#prev[n3] = p;
    this.#next[p] = n3;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};
commonjs.LRUCache = LRUCache$1;
var maybeJoin = (...args2) => args2.every((arg) => arg) ? args2.join("") : "";
var maybeEncode = (arg) => arg ? encodeURIComponent(arg) : "";
var formatHashFragment = (f) => f.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
var defaults = {
  sshtemplate: ({ domain: domain2, user, project, committish }) => `git@${domain2}:${user}/${project}.git${maybeJoin("#", committish)}`,
  sshurltemplate: ({ domain: domain2, user, project, committish }) => `git+ssh://git@${domain2}/${user}/${project}.git${maybeJoin("#", committish)}`,
  edittemplate: ({ domain: domain2, user, project, committish, editpath, path: path2 }) => `https://${domain2}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path2)}`,
  browsetemplate: ({ domain: domain2, user, project, committish, treepath }) => `https://${domain2}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
  browsetreetemplate: ({ domain: domain2, user, project, committish, treepath, path: path2, fragment, hashformat }) => `https://${domain2}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path2}${maybeJoin("#", hashformat(fragment || ""))}`,
  browseblobtemplate: ({ domain: domain2, user, project, committish, blobpath, path: path2, fragment, hashformat }) => `https://${domain2}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path2}${maybeJoin("#", hashformat(fragment || ""))}`,
  docstemplate: ({ domain: domain2, user, project, treepath, committish }) => `https://${domain2}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
  httpstemplate: ({ auth, domain: domain2, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain2}/${user}/${project}.git${maybeJoin("#", committish)}`,
  filetemplate: ({ domain: domain2, user, project, committish, path: path2 }) => `https://${domain2}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path2}`,
  shortcuttemplate: ({ type, user, project, committish }) => `${type}:${user}/${project}${maybeJoin("#", committish)}`,
  pathtemplate: ({ user, project, committish }) => `${user}/${project}${maybeJoin("#", committish)}`,
  bugstemplate: ({ domain: domain2, user, project }) => `https://${domain2}/${user}/${project}/issues`,
  hashformat: formatHashFragment
};
var hosts$1 = {};
hosts$1.github = {
  protocols: ["git:", "http:", "git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "github.com",
  treepath: "tree",
  blobpath: "blob",
  editpath: "edit",
  filetemplate: ({ auth, user, project, committish, path: path2 }) => `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path2}`,
  gittemplate: ({ auth, domain: domain2, user, project, committish }) => `git://${maybeJoin(auth, "@")}${domain2}/${user}/${project}.git${maybeJoin("#", committish)}`,
  tarballtemplate: ({ domain: domain2, user, project, committish }) => `https://codeload.${domain2}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
  extract: (url2) => {
    let [, user, project, type, committish] = url2.pathname.split("/", 5);
    if (type && type !== "tree") {
      return;
    }
    if (!type) {
      committish = url2.hash.slice(1);
    }
    if (project && project.endsWith(".git")) {
      project = project.slice(0, -4);
    }
    if (!user || !project) {
      return;
    }
    return { user, project, committish };
  }
};
hosts$1.bitbucket = {
  protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "bitbucket.org",
  treepath: "src",
  blobpath: "src",
  editpath: "?mode=edit",
  edittemplate: ({ domain: domain2, user, project, committish, treepath, path: path2, editpath }) => `https://${domain2}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path2, editpath)}`,
  tarballtemplate: ({ domain: domain2, user, project, committish }) => `https://${domain2}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
  extract: (url2) => {
    let [, user, project, aux] = url2.pathname.split("/", 4);
    if (["get"].includes(aux)) {
      return;
    }
    if (project && project.endsWith(".git")) {
      project = project.slice(0, -4);
    }
    if (!user || !project) {
      return;
    }
    return { user, project, committish: url2.hash.slice(1) };
  }
};
hosts$1.gitlab = {
  protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "gitlab.com",
  treepath: "tree",
  blobpath: "tree",
  editpath: "-/edit",
  httpstemplate: ({ auth, domain: domain2, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain2}/${user}/${project}.git${maybeJoin("#", committish)}`,
  tarballtemplate: ({ domain: domain2, user, project, committish }) => `https://${domain2}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
  extract: (url2) => {
    const path2 = url2.pathname.slice(1);
    if (path2.includes("/-/") || path2.includes("/archive.tar.gz")) {
      return;
    }
    const segments = path2.split("/");
    let project = segments.pop();
    if (project.endsWith(".git")) {
      project = project.slice(0, -4);
    }
    const user = segments.join("/");
    if (!user || !project) {
      return;
    }
    return { user, project, committish: url2.hash.slice(1) };
  }
};
hosts$1.gist = {
  protocols: ["git:", "git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "gist.github.com",
  editpath: "edit",
  sshtemplate: ({ domain: domain2, project, committish }) => `git@${domain2}:${project}.git${maybeJoin("#", committish)}`,
  sshurltemplate: ({ domain: domain2, project, committish }) => `git+ssh://git@${domain2}/${project}.git${maybeJoin("#", committish)}`,
  edittemplate: ({ domain: domain2, user, project, committish, editpath }) => `https://${domain2}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
  browsetemplate: ({ domain: domain2, project, committish }) => `https://${domain2}/${project}${maybeJoin("/", maybeEncode(committish))}`,
  browsetreetemplate: ({ domain: domain2, project, committish, path: path2, hashformat }) => `https://${domain2}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path2))}`,
  browseblobtemplate: ({ domain: domain2, project, committish, path: path2, hashformat }) => `https://${domain2}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path2))}`,
  docstemplate: ({ domain: domain2, project, committish }) => `https://${domain2}/${project}${maybeJoin("/", maybeEncode(committish))}`,
  httpstemplate: ({ domain: domain2, project, committish }) => `git+https://${domain2}/${project}.git${maybeJoin("#", committish)}`,
  filetemplate: ({ user, project, committish, path: path2 }) => `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path2}`,
  shortcuttemplate: ({ type, project, committish }) => `${type}:${project}${maybeJoin("#", committish)}`,
  pathtemplate: ({ project, committish }) => `${project}${maybeJoin("#", committish)}`,
  bugstemplate: ({ domain: domain2, project }) => `https://${domain2}/${project}`,
  gittemplate: ({ domain: domain2, project, committish }) => `git://${domain2}/${project}.git${maybeJoin("#", committish)}`,
  tarballtemplate: ({ project, committish }) => `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
  extract: (url2) => {
    let [, user, project, aux] = url2.pathname.split("/", 4);
    if (aux === "raw") {
      return;
    }
    if (!project) {
      if (!user) {
        return;
      }
      project = user;
      user = null;
    }
    if (project.endsWith(".git")) {
      project = project.slice(0, -4);
    }
    return { user, project, committish: url2.hash.slice(1) };
  },
  hashformat: function(fragment) {
    return fragment && "file-" + formatHashFragment(fragment);
  }
};
hosts$1.sourcehut = {
  protocols: ["git+ssh:", "https:"],
  domain: "git.sr.ht",
  treepath: "tree",
  blobpath: "tree",
  filetemplate: ({ domain: domain2, user, project, committish, path: path2 }) => `https://${domain2}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path2}`,
  httpstemplate: ({ domain: domain2, user, project, committish }) => `https://${domain2}/${user}/${project}.git${maybeJoin("#", committish)}`,
  tarballtemplate: ({ domain: domain2, user, project, committish }) => `https://${domain2}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
  bugstemplate: ({ user, project }) => null,
  extract: (url2) => {
    let [, user, project, aux] = url2.pathname.split("/", 4);
    if (["archive"].includes(aux)) {
      return;
    }
    if (project && project.endsWith(".git")) {
      project = project.slice(0, -4);
    }
    if (!user || !project) {
      return;
    }
    return { user, project, committish: url2.hash.slice(1) };
  }
};
for (const [name2, host] of Object.entries(hosts$1)) {
  hosts$1[name2] = Object.assign({}, defaults, host);
}
var hosts_1 = hosts$1;
var url$2 = require$$0;
var lastIndexOfBefore = (str, char, beforeChar) => {
  const startPosition = str.indexOf(beforeChar);
  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
};
var safeUrl = (u) => {
  try {
    return new url$2.URL(u);
  } catch {
  }
};
var correctProtocol = (arg, protocols) => {
  const firstColon = arg.indexOf(":");
  const proto = arg.slice(0, firstColon + 1);
  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
    return arg;
  }
  const firstAt = arg.indexOf("@");
  if (firstAt > -1) {
    if (firstAt > firstColon) {
      return `git+ssh://${arg}`;
    } else {
      return arg;
    }
  }
  const doubleSlash = arg.indexOf("//");
  if (doubleSlash === firstColon + 1) {
    return arg;
  }
  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
};
var correctUrl = (giturl) => {
  const firstAt = lastIndexOfBefore(giturl, "@", "#");
  const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
  if (lastColonBeforeHash > firstAt) {
    giturl = giturl.slice(0, lastColonBeforeHash) + "/" + giturl.slice(lastColonBeforeHash + 1);
  }
  if (lastIndexOfBefore(giturl, ":", "#") === -1 && giturl.indexOf("//") === -1) {
    giturl = `git+ssh://${giturl}`;
  }
  return giturl;
};
var parseUrl$2 = (giturl, protocols) => {
  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
};
var parseUrl$1 = parseUrl$2;
var isGitHubShorthand = (arg) => {
  const firstHash = arg.indexOf("#");
  const firstSlash = arg.indexOf("/");
  const secondSlash = arg.indexOf("/", firstSlash + 1);
  const firstColon = arg.indexOf(":");
  const firstSpace = /\s/.exec(arg);
  const firstAt = arg.indexOf("@");
  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
  const hasSlash = firstSlash > 0;
  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
  const doesNotStartWithDot = !arg.startsWith(".");
  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
};
var fromUrl$1 = (giturl, opts, { gitHosts, protocols }) => {
  if (!giturl) {
    return;
  }
  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;
  const parsed = parseUrl$1(correctedUrl, protocols);
  if (!parsed) {
    return;
  }
  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
  const gitHostName = gitHostShortcut || gitHostDomain;
  if (!gitHostName) {
    return;
  }
  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
  let auth = null;
  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {
    auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
  }
  let committish = null;
  let user = null;
  let project = null;
  let defaultRepresentation = null;
  try {
    if (gitHostShortcut) {
      let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
      const firstAt = pathname.indexOf("@");
      if (firstAt > -1) {
        pathname = pathname.slice(firstAt + 1);
      }
      const lastSlash = pathname.lastIndexOf("/");
      if (lastSlash > -1) {
        user = decodeURIComponent(pathname.slice(0, lastSlash));
        if (!user) {
          user = null;
        }
        project = decodeURIComponent(pathname.slice(lastSlash + 1));
      } else {
        project = decodeURIComponent(pathname);
      }
      if (project.endsWith(".git")) {
        project = project.slice(0, -4);
      }
      if (parsed.hash) {
        committish = decodeURIComponent(parsed.hash.slice(1));
      }
      defaultRepresentation = "shortcut";
    } else {
      if (!gitHostInfo.protocols.includes(parsed.protocol)) {
        return;
      }
      const segments = gitHostInfo.extract(parsed);
      if (!segments) {
        return;
      }
      user = segments.user && decodeURIComponent(segments.user);
      project = decodeURIComponent(segments.project);
      committish = decodeURIComponent(segments.committish);
      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
    }
  } catch (err2) {
    if (err2 instanceof URIError) {
      return;
    } else {
      throw err2;
    }
  }
  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts];
};
var { LRUCache: LRUCache2 } = commonjs;
var hosts = hosts_1;
var fromUrl = fromUrl$1;
var parseUrl = parseUrl$2;
var cache$1 = new LRUCache2({ max: 1e3 });
var GitHost = class _GitHost {
  constructor(type, user, auth, project, committish, defaultRepresentation, opts = {}) {
    Object.assign(this, _GitHost.#gitHosts[type], {
      type,
      user,
      auth,
      project,
      committish,
      default: defaultRepresentation,
      opts
    });
  }
  static #gitHosts = { byShortcut: {}, byDomain: {} };
  static #protocols = {
    "git+ssh:": { name: "sshurl" },
    "ssh:": { name: "sshurl" },
    "git+https:": { name: "https", auth: true },
    "git:": { auth: true },
    "http:": { auth: true },
    "https:": { auth: true },
    "git+http:": { auth: true }
  };
  static addHost(name2, host) {
    _GitHost.#gitHosts[name2] = host;
    _GitHost.#gitHosts.byDomain[host.domain] = name2;
    _GitHost.#gitHosts.byShortcut[`${name2}:`] = name2;
    _GitHost.#protocols[`${name2}:`] = { name: name2 };
  }
  static fromUrl(giturl, opts) {
    if (typeof giturl !== "string") {
      return;
    }
    const key = giturl + JSON.stringify(opts || {});
    if (!cache$1.has(key)) {
      const hostArgs = fromUrl(giturl, opts, {
        gitHosts: _GitHost.#gitHosts,
        protocols: _GitHost.#protocols
      });
      cache$1.set(key, hostArgs ? new _GitHost(...hostArgs) : void 0);
    }
    return cache$1.get(key);
  }
  static parseUrl(url2) {
    return parseUrl(url2);
  }
  #fill(template, opts) {
    if (typeof template !== "function") {
      return null;
    }
    const options = { ...this, ...this.opts, ...opts };
    if (!options.path) {
      options.path = "";
    }
    if (options.path.startsWith("/")) {
      options.path = options.path.slice(1);
    }
    if (options.noCommittish) {
      options.committish = null;
    }
    const result = template(options);
    return options.noGitPlus && result.startsWith("git+") ? result.slice(4) : result;
  }
  hash() {
    return this.committish ? `#${this.committish}` : "";
  }
  ssh(opts) {
    return this.#fill(this.sshtemplate, opts);
  }
  sshurl(opts) {
    return this.#fill(this.sshurltemplate, opts);
  }
  browse(path2, ...args2) {
    if (typeof path2 !== "string") {
      return this.#fill(this.browsetemplate, path2);
    }
    if (typeof args2[0] !== "string") {
      return this.#fill(this.browsetreetemplate, { ...args2[0], path: path2 });
    }
    return this.#fill(this.browsetreetemplate, { ...args2[1], fragment: args2[0], path: path2 });
  }
  browseFile(path2, ...args2) {
    if (typeof args2[0] !== "string") {
      return this.#fill(this.browseblobtemplate, { ...args2[0], path: path2 });
    }
    return this.#fill(this.browseblobtemplate, { ...args2[1], fragment: args2[0], path: path2 });
  }
  docs(opts) {
    return this.#fill(this.docstemplate, opts);
  }
  bugs(opts) {
    return this.#fill(this.bugstemplate, opts);
  }
  https(opts) {
    return this.#fill(this.httpstemplate, opts);
  }
  git(opts) {
    return this.#fill(this.gittemplate, opts);
  }
  shortcut(opts) {
    return this.#fill(this.shortcuttemplate, opts);
  }
  path(opts) {
    return this.#fill(this.pathtemplate, opts);
  }
  tarball(opts) {
    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false });
  }
  file(path2, opts) {
    return this.#fill(this.filetemplate, { ...opts, path: path2 });
  }
  edit(path2, opts) {
    return this.#fill(this.edittemplate, { ...opts, path: path2 });
  }
  getDefaultRepresentation() {
    return this.default;
  }
  toString(opts) {
    if (this.default && typeof this[this.default] === "function") {
      return this[this.default](opts);
    }
    return this.sshurl(opts);
  }
};
for (const [name2, host] of Object.entries(hosts)) {
  GitHost.addHost(name2, host);
}
var lib$3 = GitHost;
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i3 = 0; i3 < a.length; i3 += 1) {
    arr[i3] = a[i3];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i3 = offset || 0, j = 0; i3 < arrLike.length; i3 += 1, j += 1) {
    arr[j] = arrLike[i3];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i3 = 0; i3 < arr.length; i3 += 1) {
    str += arr[i3];
    if (i3 + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args2 = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args2, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args2, arguments)
    );
  };
  var boundLength = max(0, target.length - args2.length);
  var boundArgs = [];
  for (var i3 = 0; i3 < boundLength; i3++) {
    boundArgs[i3] = "$" + i3;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind2 = functionBind;
var hasown = bind2.call(call, $hasOwn);
var assert3 = true;
var async_hooks = ">= 8";
var buffer_ieee754 = ">= 0.5 && < 0.9.7";
var buffer = true;
var child_process = true;
var cluster = ">= 0.5";
var console$1 = true;
var constants = true;
var crypto = true;
var _debug_agent = ">= 1 && < 8";
var _debugger = "< 8";
var dgram = true;
var diagnostics_channel = [
  ">= 14.17 && < 15",
  ">= 15.1"
];
var dns = true;
var domain = ">= 0.7.12";
var events = true;
var freelist = "< 6";
var fs2 = true;
var _http_agent = ">= 0.11.1";
var _http_client = ">= 0.11.1";
var _http_common = ">= 0.11.1";
var _http_incoming = ">= 0.11.1";
var _http_outgoing = ">= 0.11.1";
var _http_server = ">= 0.11.1";
var http = true;
var http2 = ">= 8.8";
var https = true;
var inspector = ">= 8";
var _linklist = "< 8";
var module2 = true;
var net = true;
var os$2 = true;
var path = true;
var perf_hooks = ">= 8.5";
var process$1 = ">= 1";
var punycode = ">= 0.5";
var querystring = true;
var readline = true;
var repl = true;
var smalloc = ">= 0.11.5 && < 3";
var _stream_duplex = ">= 0.9.4";
var _stream_transform = ">= 0.9.4";
var _stream_wrap = ">= 1.4.1";
var _stream_passthrough = ">= 0.9.4";
var _stream_readable = ">= 0.9.4";
var _stream_writable = ">= 0.9.4";
var stream = true;
var string_decoder = true;
var sys = [
  ">= 0.4 && < 0.7",
  ">= 0.8"
];
var timers = true;
var _tls_common = ">= 0.11.13";
var _tls_legacy = ">= 0.11.3 && < 10";
var _tls_wrap = ">= 0.11.3";
var tls = true;
var trace_events = ">= 10";
var tty = true;
var url$1 = true;
var util$1 = true;
var v8 = ">= 1";
var vm = true;
var wasi = [
  ">= 13.4 && < 13.5",
  ">= 18.17 && < 19",
  ">= 20"
];
var worker_threads = ">= 11.7";
var zlib = ">= 0.5";
var require$$1$1 = {
  assert: assert3,
  "node:assert": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "assert/strict": ">= 15",
  "node:assert/strict": ">= 16",
  async_hooks,
  "node:async_hooks": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  buffer_ieee754,
  buffer,
  "node:buffer": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  child_process,
  "node:child_process": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  cluster,
  "node:cluster": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  console: console$1,
  "node:console": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  constants,
  "node:constants": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  crypto,
  "node:crypto": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _debug_agent,
  _debugger,
  dgram,
  "node:dgram": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  diagnostics_channel,
  "node:diagnostics_channel": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  dns,
  "node:dns": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "dns/promises": ">= 15",
  "node:dns/promises": ">= 16",
  domain,
  "node:domain": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  events,
  "node:events": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  freelist,
  fs: fs2,
  "node:fs": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "fs/promises": [
    ">= 10 && < 10.1",
    ">= 14"
  ],
  "node:fs/promises": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_agent,
  "node:_http_agent": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_client,
  "node:_http_client": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_common,
  "node:_http_common": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_incoming,
  "node:_http_incoming": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_outgoing,
  "node:_http_outgoing": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _http_server,
  "node:_http_server": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  http,
  "node:http": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  http2,
  "node:http2": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  https,
  "node:https": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  inspector,
  "node:inspector": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "inspector/promises": [
    ">= 19"
  ],
  "node:inspector/promises": [
    ">= 19"
  ],
  _linklist,
  module: module2,
  "node:module": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  net,
  "node:net": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "node-inspect/lib/_inspect": ">= 7.6 && < 12",
  "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
  "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
  os: os$2,
  "node:os": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  path,
  "node:path": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "path/posix": ">= 15.3",
  "node:path/posix": ">= 16",
  "path/win32": ">= 15.3",
  "node:path/win32": ">= 16",
  perf_hooks,
  "node:perf_hooks": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  process: process$1,
  "node:process": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  punycode,
  "node:punycode": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  querystring,
  "node:querystring": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  readline,
  "node:readline": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "readline/promises": ">= 17",
  "node:readline/promises": ">= 17",
  repl,
  "node:repl": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  smalloc,
  _stream_duplex,
  "node:_stream_duplex": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _stream_transform,
  "node:_stream_transform": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _stream_wrap,
  "node:_stream_wrap": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _stream_passthrough,
  "node:_stream_passthrough": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _stream_readable,
  "node:_stream_readable": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _stream_writable,
  "node:_stream_writable": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  stream,
  "node:stream": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "stream/consumers": ">= 16.7",
  "node:stream/consumers": ">= 16.7",
  "stream/promises": ">= 15",
  "node:stream/promises": ">= 16",
  "stream/web": ">= 16.5",
  "node:stream/web": ">= 16.5",
  string_decoder,
  "node:string_decoder": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  sys,
  "node:sys": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "test/reporters": ">= 19.9 && < 20.2",
  "node:test/reporters": [
    ">= 18.17 && < 19",
    ">= 19.9",
    ">= 20"
  ],
  "node:test": [
    ">= 16.17 && < 17",
    ">= 18"
  ],
  timers,
  "node:timers": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "timers/promises": ">= 15",
  "node:timers/promises": ">= 16",
  _tls_common,
  "node:_tls_common": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  _tls_legacy,
  _tls_wrap,
  "node:_tls_wrap": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  tls,
  "node:tls": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  trace_events,
  "node:trace_events": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  tty,
  "node:tty": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  url: url$1,
  "node:url": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  util: util$1,
  "node:util": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  "util/types": ">= 15.3",
  "node:util/types": ">= 16",
  "v8/tools/arguments": ">= 10 && < 12",
  "v8/tools/codemap": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  "v8/tools/consarray": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  "v8/tools/csvparser": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  "v8/tools/logreader": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  "v8/tools/profile_view": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  "v8/tools/splaytree": [
    ">= 4.4 && < 5",
    ">= 5.2 && < 12"
  ],
  v8,
  "node:v8": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  vm,
  "node:vm": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  wasi,
  "node:wasi": [
    ">= 18.17 && < 19",
    ">= 20"
  ],
  worker_threads,
  "node:worker_threads": [
    ">= 14.18 && < 15",
    ">= 16"
  ],
  zlib,
  "node:zlib": [
    ">= 14.18 && < 15",
    ">= 16"
  ]
};
var hasOwn = hasown;
function specifierIncluded(current, specifier) {
  var nodeParts = current.split(".");
  var parts2 = specifier.split(" ");
  var op = parts2.length > 1 ? parts2[0] : "=";
  var versionParts = (parts2.length > 1 ? parts2[1] : parts2[0]).split(".");
  for (var i3 = 0; i3 < 3; ++i3) {
    var cur = parseInt(nodeParts[i3] || 0, 10);
    var ver = parseInt(versionParts[i3] || 0, 10);
    if (cur === ver) {
      continue;
    }
    if (op === "<") {
      return cur < ver;
    }
    if (op === ">=") {
      return cur >= ver;
    }
    return false;
  }
  return op === ">=";
}
function matchesRange(current, range) {
  var specifiers = range.split(/ ?&& ?/);
  if (specifiers.length === 0) {
    return false;
  }
  for (var i3 = 0; i3 < specifiers.length; ++i3) {
    if (!specifierIncluded(current, specifiers[i3])) {
      return false;
    }
  }
  return true;
}
function versionIncluded(nodeVersion2, specifierValue) {
  if (typeof specifierValue === "boolean") {
    return specifierValue;
  }
  var current = typeof nodeVersion2 === "undefined" ? process.versions && process.versions.node : nodeVersion2;
  if (typeof current !== "string") {
    throw new TypeError(typeof nodeVersion2 === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
  }
  if (specifierValue && typeof specifierValue === "object") {
    for (var i3 = 0; i3 < specifierValue.length; ++i3) {
      if (matchesRange(current, specifierValue[i3])) {
        return true;
      }
    }
    return false;
  }
  return matchesRange(current, specifierValue);
}
var data = require$$1$1;
var isCoreModule = function isCore(x, nodeVersion2) {
  return hasOwn(data, x) && versionIncluded(nodeVersion2, data[x]);
};
var extract_description = extractDescription$1;
function extractDescription$1(d) {
  if (!d) {
    return;
  }
  if (d === "ERROR: No README data found!") {
    return;
  }
  d = d.trim().split("\n");
  let s = 0;
  while (d[s] && d[s].trim().match(/^(#|$)/)) {
    s++;
  }
  const l = d.length;
  let e = s + 1;
  while (e < l && d[e].trim()) {
    e++;
  }
  return d.slice(s, e).join(" ").trim();
}
var topLevel = {
  dependancies: "dependencies",
  dependecies: "dependencies",
  depdenencies: "dependencies",
  devEependencies: "devDependencies",
  depends: "dependencies",
  "dev-dependencies": "devDependencies",
  devDependences: "devDependencies",
  devDepenencies: "devDependencies",
  devdependencies: "devDependencies",
  repostitory: "repository",
  repo: "repository",
  prefereGlobal: "preferGlobal",
  hompage: "homepage",
  hampage: "homepage",
  autohr: "author",
  autor: "author",
  contributers: "contributors",
  publicationConfig: "publishConfig",
  script: "scripts"
};
var bugs = {
  web: "url",
  name: "url"
};
var script = {
  server: "start",
  tests: "test"
};
var require$$7 = {
  topLevel,
  bugs,
  script
};
var isValidSemver = valid_1;
var cleanSemver = clean_1;
var validateLicense = validateNpmPackageLicense;
var hostedGitInfo = lib$3;
var isBuiltinModule = isCoreModule;
var depTypes = ["dependencies", "devDependencies", "optionalDependencies"];
var extractDescription = extract_description;
var url = require$$0;
var typos = require$$7;
var isEmail = (str) => str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
var fixer$1 = {
  warn: function() {
  },
  fixRepositoryField: function(data2) {
    if (data2.repositories) {
      this.warn("repositories");
      data2.repository = data2.repositories[0];
    }
    if (!data2.repository) {
      return this.warn("missingRepository");
    }
    if (typeof data2.repository === "string") {
      data2.repository = {
        type: "git",
        url: data2.repository
      };
    }
    var r3 = data2.repository.url || "";
    if (r3) {
      var hosted = hostedGitInfo.fromUrl(r3);
      if (hosted) {
        r3 = data2.repository.url = hosted.getDefaultRepresentation() === "shortcut" ? hosted.https() : hosted.toString();
      }
    }
    if (r3.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) {
      this.warn("brokenGitUrl", r3);
    }
  },
  fixTypos: function(data2) {
    Object.keys(typos.topLevel).forEach(function(d) {
      if (Object.prototype.hasOwnProperty.call(data2, d)) {
        this.warn("typo", d, typos.topLevel[d]);
      }
    }, this);
  },
  fixScriptsField: function(data2) {
    if (!data2.scripts) {
      return;
    }
    if (typeof data2.scripts !== "object") {
      this.warn("nonObjectScripts");
      delete data2.scripts;
      return;
    }
    Object.keys(data2.scripts).forEach(function(k) {
      if (typeof data2.scripts[k] !== "string") {
        this.warn("nonStringScript");
        delete data2.scripts[k];
      } else if (typos.script[k] && !data2.scripts[typos.script[k]]) {
        this.warn("typo", k, typos.script[k], "scripts");
      }
    }, this);
  },
  fixFilesField: function(data2) {
    var files = data2.files;
    if (files && !Array.isArray(files)) {
      this.warn("nonArrayFiles");
      delete data2.files;
    } else if (data2.files) {
      data2.files = data2.files.filter(function(file) {
        if (!file || typeof file !== "string") {
          this.warn("invalidFilename", file);
          return false;
        } else {
          return true;
        }
      }, this);
    }
  },
  fixBinField: function(data2) {
    if (!data2.bin) {
      return;
    }
    if (typeof data2.bin === "string") {
      var b = {};
      var match;
      if (match = data2.name.match(/^@[^/]+[/](.*)$/)) {
        b[match[1]] = data2.bin;
      } else {
        b[data2.name] = data2.bin;
      }
      data2.bin = b;
    }
  },
  fixManField: function(data2) {
    if (!data2.man) {
      return;
    }
    if (typeof data2.man === "string") {
      data2.man = [data2.man];
    }
  },
  fixBundleDependenciesField: function(data2) {
    var bdd = "bundledDependencies";
    var bd = "bundleDependencies";
    if (data2[bdd] && !data2[bd]) {
      data2[bd] = data2[bdd];
      delete data2[bdd];
    }
    if (data2[bd] && !Array.isArray(data2[bd])) {
      this.warn("nonArrayBundleDependencies");
      delete data2[bd];
    } else if (data2[bd]) {
      data2[bd] = data2[bd].filter(function(filtered) {
        if (!filtered || typeof filtered !== "string") {
          this.warn("nonStringBundleDependency", filtered);
          return false;
        } else {
          if (!data2.dependencies) {
            data2.dependencies = {};
          }
          if (!Object.prototype.hasOwnProperty.call(data2.dependencies, filtered)) {
            this.warn("nonDependencyBundleDependency", filtered);
            data2.dependencies[filtered] = "*";
          }
          return true;
        }
      }, this);
    }
  },
  fixDependencies: function(data2, strict) {
    objectifyDeps(data2, this.warn);
    addOptionalDepsToDeps(data2, this.warn);
    this.fixBundleDependenciesField(data2);
    ["dependencies", "devDependencies"].forEach(function(deps) {
      if (!(deps in data2)) {
        return;
      }
      if (!data2[deps] || typeof data2[deps] !== "object") {
        this.warn("nonObjectDependencies", deps);
        delete data2[deps];
        return;
      }
      Object.keys(data2[deps]).forEach(function(d) {
        var r3 = data2[deps][d];
        if (typeof r3 !== "string") {
          this.warn("nonStringDependency", d, JSON.stringify(r3));
          delete data2[deps][d];
        }
        var hosted = hostedGitInfo.fromUrl(data2[deps][d]);
        if (hosted) {
          data2[deps][d] = hosted.toString();
        }
      }, this);
    }, this);
  },
  fixModulesField: function(data2) {
    if (data2.modules) {
      this.warn("deprecatedModules");
      delete data2.modules;
    }
  },
  fixKeywordsField: function(data2) {
    if (typeof data2.keywords === "string") {
      data2.keywords = data2.keywords.split(/,\s+/);
    }
    if (data2.keywords && !Array.isArray(data2.keywords)) {
      delete data2.keywords;
      this.warn("nonArrayKeywords");
    } else if (data2.keywords) {
      data2.keywords = data2.keywords.filter(function(kw) {
        if (typeof kw !== "string" || !kw) {
          this.warn("nonStringKeyword");
          return false;
        } else {
          return true;
        }
      }, this);
    }
  },
  fixVersionField: function(data2, strict) {
    var loose = !strict;
    if (!data2.version) {
      data2.version = "";
      return true;
    }
    if (!isValidSemver(data2.version, loose)) {
      throw new Error('Invalid version: "' + data2.version + '"');
    }
    data2.version = cleanSemver(data2.version, loose);
    return true;
  },
  fixPeople: function(data2) {
    modifyPeople(data2, unParsePerson);
    modifyPeople(data2, parsePerson);
  },
  fixNameField: function(data2, options) {
    if (typeof options === "boolean") {
      options = { strict: options };
    } else if (typeof options === "undefined") {
      options = {};
    }
    var strict = options.strict;
    if (!data2.name && !strict) {
      data2.name = "";
      return;
    }
    if (typeof data2.name !== "string") {
      throw new Error("name field must be a string.");
    }
    if (!strict) {
      data2.name = data2.name.trim();
    }
    ensureValidName(data2.name, strict, options.allowLegacyCase);
    if (isBuiltinModule(data2.name)) {
      this.warn("conflictingName", data2.name);
    }
  },
  fixDescriptionField: function(data2) {
    if (data2.description && typeof data2.description !== "string") {
      this.warn("nonStringDescription");
      delete data2.description;
    }
    if (data2.readme && !data2.description) {
      data2.description = extractDescription(data2.readme);
    }
    if (data2.description === void 0) {
      delete data2.description;
    }
    if (!data2.description) {
      this.warn("missingDescription");
    }
  },
  fixReadmeField: function(data2) {
    if (!data2.readme) {
      this.warn("missingReadme");
      data2.readme = "ERROR: No README data found!";
    }
  },
  fixBugsField: function(data2) {
    if (!data2.bugs && data2.repository && data2.repository.url) {
      var hosted = hostedGitInfo.fromUrl(data2.repository.url);
      if (hosted && hosted.bugs()) {
        data2.bugs = { url: hosted.bugs() };
      }
    } else if (data2.bugs) {
      if (typeof data2.bugs === "string") {
        if (isEmail(data2.bugs)) {
          data2.bugs = { email: data2.bugs };
        } else if (url.parse(data2.bugs).protocol) {
          data2.bugs = { url: data2.bugs };
        } else {
          this.warn("nonEmailUrlBugsString");
        }
      } else {
        bugsTypos(data2.bugs, this.warn);
        var oldBugs = data2.bugs;
        data2.bugs = {};
        if (oldBugs.url) {
          if (typeof oldBugs.url === "string" && url.parse(oldBugs.url).protocol) {
            data2.bugs.url = oldBugs.url;
          } else {
            this.warn("nonUrlBugsUrlField");
          }
        }
        if (oldBugs.email) {
          if (typeof oldBugs.email === "string" && isEmail(oldBugs.email)) {
            data2.bugs.email = oldBugs.email;
          } else {
            this.warn("nonEmailBugsEmailField");
          }
        }
      }
      if (!data2.bugs.email && !data2.bugs.url) {
        delete data2.bugs;
        this.warn("emptyNormalizedBugs");
      }
    }
  },
  fixHomepageField: function(data2) {
    if (!data2.homepage && data2.repository && data2.repository.url) {
      var hosted = hostedGitInfo.fromUrl(data2.repository.url);
      if (hosted && hosted.docs()) {
        data2.homepage = hosted.docs();
      }
    }
    if (!data2.homepage) {
      return;
    }
    if (typeof data2.homepage !== "string") {
      this.warn("nonUrlHomepage");
      return delete data2.homepage;
    }
    if (!url.parse(data2.homepage).protocol) {
      data2.homepage = "http://" + data2.homepage;
    }
  },
  fixLicenseField: function(data2) {
    const license = data2.license || data2.licence;
    if (!license) {
      return this.warn("missingLicense");
    }
    if (typeof license !== "string" || license.length < 1 || license.trim() === "") {
      return this.warn("invalidLicense");
    }
    if (!validateLicense(license).validForNewPackages) {
      return this.warn("invalidLicense");
    }
  }
};
function isValidScopedPackageName(spec) {
  if (spec.charAt(0) !== "@") {
    return false;
  }
  var rest = spec.slice(1).split("/");
  if (rest.length !== 2) {
    return false;
  }
  return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
}
function isCorrectlyEncodedName(spec) {
  return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
}
function ensureValidName(name2, strict, allowLegacyCase) {
  if (name2.charAt(0) === "." || !(isValidScopedPackageName(name2) || isCorrectlyEncodedName(name2)) || strict && !allowLegacyCase && name2 !== name2.toLowerCase() || name2.toLowerCase() === "node_modules" || name2.toLowerCase() === "favicon.ico") {
    throw new Error("Invalid name: " + JSON.stringify(name2));
  }
}
function modifyPeople(data2, fn) {
  if (data2.author) {
    data2.author = fn(data2.author);
  }
  ["maintainers", "contributors"].forEach(function(set) {
    if (!Array.isArray(data2[set])) {
      return;
    }
    data2[set] = data2[set].map(fn);
  });
  return data2;
}
function unParsePerson(person) {
  if (typeof person === "string") {
    return person;
  }
  var name2 = person.name || "";
  var u = person.url || person.web;
  var wrappedUrl = u ? " (" + u + ")" : "";
  var e = person.email || person.mail;
  var wrappedEmail = e ? " <" + e + ">" : "";
  return name2 + wrappedEmail + wrappedUrl;
}
function parsePerson(person) {
  if (typeof person !== "string") {
    return person;
  }
  var matchedName = person.match(/^([^(<]+)/);
  var matchedUrl = person.match(/\(([^()]+)\)/);
  var matchedEmail = person.match(/<([^<>]+)>/);
  var obj = {};
  if (matchedName && matchedName[0].trim()) {
    obj.name = matchedName[0].trim();
  }
  if (matchedEmail) {
    obj.email = matchedEmail[1];
  }
  if (matchedUrl) {
    obj.url = matchedUrl[1];
  }
  return obj;
}
function addOptionalDepsToDeps(data2, warn) {
  var o = data2.optionalDependencies;
  if (!o) {
    return;
  }
  var d = data2.dependencies || {};
  Object.keys(o).forEach(function(k) {
    d[k] = o[k];
  });
  data2.dependencies = d;
}
function depObjectify(deps, type, warn) {
  if (!deps) {
    return {};
  }
  if (typeof deps === "string") {
    deps = deps.trim().split(/[\n\r\s\t ,]+/);
  }
  if (!Array.isArray(deps)) {
    return deps;
  }
  warn("deprecatedArrayDependencies", type);
  var o = {};
  deps.filter(function(d) {
    return typeof d === "string";
  }).forEach(function(d) {
    d = d.trim().split(/(:?[@\s><=])/);
    var dn = d.shift();
    var dv = d.join("");
    dv = dv.trim();
    dv = dv.replace(/^@/, "");
    o[dn] = dv;
  });
  return o;
}
function objectifyDeps(data2, warn) {
  depTypes.forEach(function(type) {
    if (!data2[type]) {
      return;
    }
    data2[type] = depObjectify(data2[type], type, warn);
  });
}
function bugsTypos(bugs2, warn) {
  if (!bugs2) {
    return;
  }
  Object.keys(bugs2).forEach(function(k) {
    if (typos.bugs[k]) {
      warn("typo", k, typos.bugs[k], "bugs");
      bugs2[typos.bugs[k]] = bugs2[k];
      delete bugs2[k];
    }
  });
}
var repositories = "'repositories' (plural) Not supported. Please pick one as the 'repository' field";
var missingRepository = "No repository field.";
var brokenGitUrl = "Probably broken git url: %s";
var nonObjectScripts = "scripts must be an object";
var nonStringScript = "script values must be string commands";
var nonArrayFiles = "Invalid 'files' member";
var invalidFilename = "Invalid filename in 'files' list: %s";
var nonArrayBundleDependencies = "Invalid 'bundleDependencies' list. Must be array of package names";
var nonStringBundleDependency = "Invalid bundleDependencies member: %s";
var nonDependencyBundleDependency = "Non-dependency in bundleDependencies: %s";
var nonObjectDependencies = "%s field must be an object";
var nonStringDependency = "Invalid dependency: %s %s";
var deprecatedArrayDependencies = "specifying %s as array is deprecated";
var deprecatedModules = "modules field is deprecated";
var nonArrayKeywords = "keywords should be an array of strings";
var nonStringKeyword = "keywords should be an array of strings";
var conflictingName = "%s is also the name of a node core module.";
var nonStringDescription = "'description' field should be a string";
var missingDescription = "No description";
var missingReadme = "No README data";
var missingLicense = "No license field.";
var nonEmailUrlBugsString = "Bug string field must be url, email, or {email,url}";
var nonUrlBugsUrlField = "bugs.url field must be a string url. Deleted.";
var nonEmailBugsEmailField = "bugs.email field must be a string email. Deleted.";
var emptyNormalizedBugs = "Normalized value of bugs field is an empty object. Deleted.";
var nonUrlHomepage = "homepage field must be a string url. Deleted.";
var invalidLicense = "license should be a valid SPDX license expression";
var typo = "%s should probably be %s.";
var require$$1 = {
  repositories,
  missingRepository,
  brokenGitUrl,
  nonObjectScripts,
  nonStringScript,
  nonArrayFiles,
  invalidFilename,
  nonArrayBundleDependencies,
  nonStringBundleDependency,
  nonDependencyBundleDependency,
  nonObjectDependencies,
  nonStringDependency,
  deprecatedArrayDependencies,
  deprecatedModules,
  nonArrayKeywords,
  nonStringKeyword,
  conflictingName,
  nonStringDescription,
  missingDescription,
  missingReadme,
  missingLicense,
  nonEmailUrlBugsString,
  nonUrlBugsUrlField,
  nonEmailBugsEmailField,
  emptyNormalizedBugs,
  nonUrlHomepage,
  invalidLicense,
  typo
};
var util = require$$0$1;
var messages = require$$1;
var make_warning = function() {
  var args2 = Array.prototype.slice.call(arguments, 0);
  var warningName = args2.shift();
  if (warningName === "typo") {
    return makeTypoWarning.apply(null, args2);
  } else {
    var msgTemplate = messages[warningName] ? messages[warningName] : warningName + ": '%s'";
    args2.unshift(msgTemplate);
    return util.format.apply(null, args2);
  }
};
function makeTypoWarning(providedName, probableName, field) {
  if (field) {
    providedName = field + "['" + providedName + "']";
    probableName = field + "['" + probableName + "']";
  }
  return util.format(messages.typo, providedName, probableName);
}
var normalize_1 = normalize;
var fixer = fixer$1;
normalize.fixer = fixer;
var makeWarning = make_warning;
var fieldsToFix = [
  "name",
  "version",
  "description",
  "repository",
  "modules",
  "scripts",
  "files",
  "bin",
  "man",
  "bugs",
  "keywords",
  "readme",
  "homepage",
  "license"
];
var otherThingsToFix = ["dependencies", "people", "typos"];
var thingsToFix = fieldsToFix.map(function(fieldName) {
  return ucFirst(fieldName) + "Field";
});
thingsToFix = thingsToFix.concat(otherThingsToFix);
function normalize(data2, warn, strict) {
  if (warn === true) {
    warn = null;
    strict = true;
  }
  if (!strict) {
    strict = false;
  }
  if (!warn || data2.private) {
    warn = function(msg) {
    };
  }
  if (data2.scripts && data2.scripts.install === "node-gyp rebuild" && !data2.scripts.preinstall) {
    data2.gypfile = true;
  }
  fixer.warn = function() {
    warn(makeWarning.apply(null, arguments));
  };
  thingsToFix.forEach(function(thingName) {
    fixer["fix" + ucFirst(thingName)](data2, strict);
  });
  data2._id = data2.name + "@" + data2.version;
}
function ucFirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var normalizePackageData = getDefaultExportFromCjs(normalize_1);
var toPath$1 = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
function findUpSync(name2, {
  cwd = process$2.cwd(),
  type = "file",
  stopAt
} = {}) {
  let directory = path$1.resolve(toPath$1(cwd) ?? "");
  const { root } = path$1.parse(directory);
  stopAt = path$1.resolve(directory, toPath$1(stopAt) ?? root);
  while (directory && directory !== stopAt && directory !== root) {
    const filePath = path$1.isAbsolute(name2) ? name2 : path$1.join(directory, name2);
    try {
      const stats = fs$1.statSync(filePath, { throwIfNoEntry: false });
      if (type === "file" && stats?.isFile() || type === "directory" && stats?.isDirectory()) {
        return filePath;
      }
    } catch {
    }
    directory = path$1.dirname(directory);
  }
}
var lib$2 = {};
var lib$1 = {};
var jsTokens = {};
Object.defineProperty(jsTokens, "__esModule", {
  value: true
});
jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
jsTokens.matchToToken = function(match) {
  var token = { type: "invalid", value: match[0], closed: void 0 };
  if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);
  else if (match[5]) token.type = "comment";
  else if (match[6]) token.type = "comment", token.closed = !!match[7];
  else if (match[8]) token.type = "regex";
  else if (match[9]) token.type = "number";
  else if (match[10]) token.type = "name";
  else if (match[11]) token.type = "punctuator";
  else if (match[12]) token.type = "whitespace";
  return token;
};
var lib = {};
var identifier = {};
Object.defineProperty(identifier, "__esModule", {
  value: true
});
identifier.isIdentifierChar = isIdentifierChar;
identifier.isIdentifierName = isIdentifierName;
identifier.isIdentifierStart = isIdentifierStart;
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function isInAstralSet(code, set) {
  let pos = 65536;
  for (let i3 = 0, length = set.length; i3 < length; i3 += 2) {
    pos += set[i3];
    if (pos > code) return false;
    pos += set[i3 + 1];
    if (pos >= code) return true;
  }
  return false;
}
function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name2) {
  let isFirst = true;
  for (let i3 = 0; i3 < name2.length; i3++) {
    let cp = name2.charCodeAt(i3);
    if ((cp & 64512) === 55296 && i3 + 1 < name2.length) {
      const trail = name2.charCodeAt(++i3);
      if ((trail & 64512) === 56320) {
        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
      }
    }
    if (isFirst) {
      isFirst = false;
      if (!isIdentifierStart(cp)) {
        return false;
      }
    } else if (!isIdentifierChar(cp)) {
      return false;
    }
  }
  return !isFirst;
}
var keyword = {};
Object.defineProperty(keyword, "__esModule", {
  value: true
});
keyword.isKeyword = isKeyword;
keyword.isReservedWord = isReservedWord;
keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
keyword.isStrictBindReservedWord = isStrictBindReservedWord;
keyword.isStrictReservedWord = isStrictReservedWord;
var reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
  return keywords.has(word);
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  });
  var _identifier = identifier;
  var _keyword = keyword;
})(lib);
var chalk$1 = { exports: {} };
var matchOperatorsRe$1 = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp$1 = function(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  return str.replace(matchOperatorsRe$1, "\\$&");
};
var ansiStyles$1 = { exports: {} };
var conversions$2 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var cssKeywords = colorName;
var reverseKeywords = {};
for (key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}
var key;
var convert$1 = conversions$2.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    channels = convert$1[model].channels;
    labels = convert$1[model].labels;
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
}
var channels;
var labels;
var model;
convert$1.rgb.hsl = function(rgb) {
  var r3 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r3, g, b);
  var max2 = Math.max(r3, g, b);
  var delta = max2 - min;
  var h;
  var s;
  var l;
  if (max2 === min) {
    h = 0;
  } else if (r3 === max2) {
    h = (g - b) / delta;
  } else if (g === max2) {
    h = 2 + (b - r3) / delta;
  } else if (b === max2) {
    h = 4 + (r3 - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max2) / 2;
  if (max2 === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max2 + min);
  } else {
    s = delta / (2 - max2 - min);
  }
  return [h, s * 100, l * 100];
};
convert$1.rgb.hsv = function(rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r3 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r3, g, b);
  var diff = v - Math.min(r3, g, b);
  var diffc = function(c) {
    return (v - c) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r3);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r3 === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [
    h * 360,
    s * 100,
    v * 100
  ];
};
convert$1.rgb.hwb = function(rgb) {
  var r3 = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert$1.rgb.hsl(rgb)[0];
  var w = 1 / 255 * Math.min(r3, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r3, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert$1.rgb.cmyk = function(rgb) {
  var r3 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r3, 1 - g, 1 - b);
  c = (1 - r3 - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}
convert$1.rgb.keyword = function(rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword2 in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword2)) {
      var value = cssKeywords[keyword2];
      var distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword2;
      }
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function(keyword2) {
  return cssKeywords[keyword2];
};
convert$1.rgb.xyz = function(rgb) {
  var r3 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r3 * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r3 * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r3 * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert$1.rgb.lab = function(rgb) {
  var xyz = convert$1.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.hsl.rgb = function(hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t22;
  var t32;
  var rgb;
  var val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t22 = l * (1 + s);
  } else {
    t22 = l + s - l * s;
  }
  t1 = 2 * l - t22;
  rgb = [0, 0, 0];
  for (var i3 = 0; i3 < 3; i3++) {
    t32 = h + 1 / 3 * -(i3 - 1);
    if (t32 < 0) {
      t32++;
    }
    if (t32 > 1) {
      t32--;
    }
    if (6 * t32 < 1) {
      val = t1 + (t22 - t1) * 6 * t32;
    } else if (2 * t32 < 1) {
      val = t22;
    } else if (3 * t32 < 2) {
      val = t1 + (t22 - t1) * (2 / 3 - t32) * 6;
    } else {
      val = t1;
    }
    rgb[i3] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function(hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};
convert$1.hsv.rgb = function(hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t5 = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t5, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t5];
    case 3:
      return [p, q, v];
    case 4:
      return [t5, p, v];
    case 5:
      return [v, p, q];
  }
};
convert$1.hsv.hsl = function(hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
};
convert$1.hwb.rgb = function(hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i3;
  var v;
  var f;
  var n3;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i3 = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i3;
  if ((i3 & 1) !== 0) {
    f = 1 - f;
  }
  n3 = wh + f * (v - wh);
  var r3;
  var g;
  var b;
  switch (i3) {
    default:
    case 6:
    case 0:
      r3 = v;
      g = n3;
      b = wh;
      break;
    case 1:
      r3 = n3;
      g = v;
      b = wh;
      break;
    case 2:
      r3 = wh;
      g = v;
      b = n3;
      break;
    case 3:
      r3 = wh;
      g = n3;
      b = v;
      break;
    case 4:
      r3 = n3;
      g = wh;
      b = v;
      break;
    case 5:
      r3 = v;
      g = wh;
      b = n3;
      break;
  }
  return [r3 * 255, g * 255, b * 255];
};
convert$1.cmyk.rgb = function(cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r3;
  var g;
  var b;
  r3 = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r3 * 255, g * 255, b * 255];
};
convert$1.xyz.rgb = function(xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r3;
  var g;
  var b;
  r3 = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.204 + z * 1.057;
  r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : r3 * 12.92;
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r3 = Math.min(Math.max(0, r3), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r3 * 255, g * 255, b * 255];
};
convert$1.xyz.lab = function(xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.lab.xyz = function(lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert$1.lab.lch = function(lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c;
  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};
convert$1.lch.lab = function(lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var a;
  var b;
  var hr;
  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};
convert$1.rgb.ansi16 = function(args2) {
  var r3 = args2[0];
  var g = args2[1];
  var b = args2[2];
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args2)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r3 / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function(args2) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args2), args2[2]);
};
convert$1.rgb.ansi256 = function(args2) {
  var r3 = args2[0];
  var g = args2[1];
  var b = args2[2];
  if (r3 === g && g === b) {
    if (r3 < 8) {
      return 16;
    }
    if (r3 > 248) {
      return 231;
    }
    return Math.round((r3 - 8) / 247 * 24) + 232;
  }
  var ansi = 16 + 36 * Math.round(r3 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert$1.ansi16.rgb = function(args2) {
  var color = args2 % 10;
  if (color === 0 || color === 7) {
    if (args2 > 50) {
      color += 3.5;
    }
    color = color / 10.5 * 255;
    return [color, color, color];
  }
  var mult = (~~(args2 > 50) + 1) * 0.5;
  var r3 = (color & 1) * mult * 255;
  var g = (color >> 1 & 1) * mult * 255;
  var b = (color >> 2 & 1) * mult * 255;
  return [r3, g, b];
};
convert$1.ansi256.rgb = function(args2) {
  if (args2 >= 232) {
    var c = (args2 - 232) * 10 + 8;
    return [c, c, c];
  }
  args2 -= 16;
  var rem;
  var r3 = Math.floor(args2 / 36) / 5 * 255;
  var g = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
  var b = rem % 6 / 5 * 255;
  return [r3, g, b];
};
convert$1.rgb.hex = function(args2) {
  var integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.hex.rgb = function(args2) {
  var match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  var colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString.split("").map(function(char) {
      return char + char;
    }).join("");
  }
  var integer = parseInt(colorString, 16);
  var r3 = integer >> 16 & 255;
  var g = integer >> 8 & 255;
  var b = integer & 255;
  return [r3, g, b];
};
convert$1.rgb.hcg = function(rgb) {
  var r3 = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max2 = Math.max(Math.max(r3, g), b);
  var min = Math.min(Math.min(r3, g), b);
  var chroma = max2 - min;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max2 === r3) {
    hue = (g - b) / chroma % 6;
  } else if (max2 === g) {
    hue = 2 + (b - r3) / chroma;
  } else {
    hue = 4 + (r3 - g) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function(hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;
  if (l < 0.5) {
    c = 2 * s * l;
  } else {
    c = 2 * s * (1 - l);
  }
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$1.hsv.hcg = function(hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$1.hcg.rgb = function(hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  var pure = [0, 0, 0];
  var hi = h % 1 * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255
  ];
};
convert$1.hcg.hsv = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  var f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert$1.hcg.hsl = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1 - c) + 0.5 * c;
  var s = 0;
  if (l > 0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert$1.hcg.hwb = function(hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert$1.hwb.hcg = function(hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$1.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$1.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$1.gray.rgb = function(args2) {
  return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
};
convert$1.gray.hsl = convert$1.gray.hsv = function(args2) {
  return [0, 0, args2[0]];
};
convert$1.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function(gray) {
  var val = Math.round(gray[0] / 100 * 255) & 255;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.rgb.gray = function(rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
var conversionsExports = conversions$2.exports;
var conversions$1 = conversionsExports;
function buildGraph() {
  var graph = {};
  var models2 = Object.keys(conversions$1);
  for (var len = models2.length, i3 = 0; i3 < len; i3++) {
    graph[models2[i3]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions$1[current]);
    for (var len = adjacents.length, i3 = 0; i3 < len; i3++) {
      var adjacent = adjacents[i3];
      var node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function(args2) {
    return to(from(args2));
  };
}
function wrapConversion(toModel, graph) {
  var path2 = [graph[toModel].parent, toModel];
  var fn = conversions$1[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path2.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path2;
  return fn;
}
var route$1 = function(fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models2 = Object.keys(graph);
  for (var len = models2.length, i3 = 0; i3 < len; i3++) {
    var toModel = models2[i3];
    var node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions = conversionsExports;
var route = route$1;
var convert = {};
var models = Object.keys(conversions);
function wrapRaw(fn) {
  var wrappedFn = function(args2) {
    if (args2 === void 0 || args2 === null) {
      return args2;
    }
    if (arguments.length > 1) {
      args2 = Array.prototype.slice.call(arguments);
    }
    return fn(args2);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  var wrappedFn = function(args2) {
    if (args2 === void 0 || args2 === null) {
      return args2;
    }
    if (arguments.length > 1) {
      args2 = Array.prototype.slice.call(arguments);
    }
    var result = fn(args2);
    if (typeof result === "object") {
      for (var len = result.length, i3 = 0; i3 < len; i3++) {
        result[i3] = Math.round(result[i3]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(function(fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function(toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
ansiStyles$1.exports;
(function(module3) {
  const colorConvert$1 = colorConvert;
  const wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${code + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n3) => n3;
    const rgb2rgb = (r3, g, b) => [r3, g, b];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== "object") {
        continue;
      }
      const suite = colorConvert$1[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module3, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var ansiStylesExports$1 = ansiStyles$1.exports;
var hasFlag$3 = (flag, argv) => {
  argv = argv || process.argv;
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const pos = argv.indexOf(prefix + flag);
  const terminatorPos = argv.indexOf("--");
  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};
var os$1 = require$$0$2;
var hasFlag$2 = hasFlag$3;
var env$1 = process.env;
var forceColor$1;
if (hasFlag$2("no-color") || hasFlag$2("no-colors") || hasFlag$2("color=false")) {
  forceColor$1 = false;
} else if (hasFlag$2("color") || hasFlag$2("colors") || hasFlag$2("color=true") || hasFlag$2("color=always")) {
  forceColor$1 = true;
}
if ("FORCE_COLOR" in env$1) {
  forceColor$1 = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;
}
function translateLevel$1(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function supportsColor$1(stream2) {
  if (forceColor$1 === false) {
    return 0;
  }
  if (hasFlag$2("color=16m") || hasFlag$2("color=full") || hasFlag$2("color=truecolor")) {
    return 3;
  }
  if (hasFlag$2("color=256")) {
    return 2;
  }
  if (stream2 && !stream2.isTTY && forceColor$1 !== true) {
    return 0;
  }
  const min = forceColor$1 ? 1 : 0;
  if (process.platform === "win32") {
    const osRelease = os$1.release().split(".");
    if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env$1) {
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env$1) || env$1.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env$1) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env$1.COLORTERM === "truecolor") {
    return 3;
  }
  if ("TERM_PROGRAM" in env$1) {
    const version = parseInt((env$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env$1.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env$1.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env$1) {
    return 1;
  }
  if (env$1.TERM === "dumb") {
    return min;
  }
  return min;
}
function getSupportLevel$1(stream2) {
  const level = supportsColor$1(stream2);
  return translateLevel$1(level);
}
var supportsColor_1$1 = {
  supportsColor: getSupportLevel$1,
  stdout: getSupportLevel$1(process.stdout),
  stderr: getSupportLevel$1(process.stderr)
};
var TEMPLATE_REGEX$1 = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
var STYLE_REGEX$1 = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
var STRING_REGEX$1 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
var ESCAPE_REGEX$1 = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
var ESCAPES$1 = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape$1(c) {
  if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }
  return ESCAPES$1.get(c) || c;
}
function parseArguments$1(name2, args2) {
  const results = [];
  const chunks = args2.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk));
    } else if (matches = chunk.match(STRING_REGEX$1)) {
      results.push(matches[2].replace(ESCAPE_REGEX$1, (m, escape, chr) => escape ? unescape$1(escape) : chr));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
  }
  return results;
}
function parseStyle$1(style) {
  STYLE_REGEX$1.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX$1.exec(style)) !== null) {
    const name2 = matches[1];
    if (matches[2]) {
      const args2 = parseArguments$1(name2, matches[2]);
      results.push([name2].concat(args2));
    } else {
      results.push([name2]);
    }
  }
  return results;
}
function buildStyle$1(chalk2, styles) {
  const enabled = {};
  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk2;
  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName]);
      } else {
        current = current[styleName];
      }
    }
  }
  return current;
}
var templates$1 = (chalk2, tmp) => {
  const styles = [];
  const chunks = [];
  let chunk = [];
  tmp.replace(TEMPLATE_REGEX$1, (m, escapeChar, inverse, style, close, chr) => {
    if (escapeChar) {
      chunk.push(unescape$1(escapeChar));
    } else if (style) {
      const str = chunk.join("");
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle$1(chalk2, styles)(str));
      styles.push({ inverse, styles: parseStyle$1(style) });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle$1(chalk2, styles)(chunk.join("")));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(""));
  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMsg);
  }
  return chunks.join("");
};
(function(module3) {
  const escapeStringRegexp2 = escapeStringRegexp$1;
  const ansiStyles2 = ansiStylesExports$1;
  const stdoutColor = supportsColor_1$1.stdout;
  const template = templates$1;
  const isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  const skipModels = /* @__PURE__ */ new Set(["gray"]);
  const styles = /* @__PURE__ */ Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = function() {
        const args2 = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk2.template].concat(args2));
      };
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = Chalk;
      return chalk2.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles2.blue.open = "\x1B[94m";
  }
  for (const key of Object.keys(ansiStyles2)) {
    ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles2[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles2[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.color.close), "g");
  for (const model of Object.keys(ansiStyles2.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.color.close,
            closeRe: ansiStyles2.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles2.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.bgColor.close,
            closeRe: ansiStyles2.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args2 = arguments;
    const argsLen = args2.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args2[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles2.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles2.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles2.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk2, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args2 = [].slice.call(arguments, 2);
    const parts2 = [strings.raw[0]];
    for (let i3 = 1; i3 < strings.length; i3++) {
      parts2.push(String(args2[i3 - 1]).replace(/[{}\\]/g, "\\$&"));
      parts2.push(String(strings.raw[i3]));
    }
    return template(chalk2, parts2.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module3.exports = Chalk();
  module3.exports.supportsColor = stdoutColor;
  module3.exports.default = module3.exports;
})(chalk$1);
var chalkExports$1 = chalk$1.exports;
Object.defineProperty(lib$1, "__esModule", {
  value: true
});
lib$1.default = highlight;
lib$1.shouldHighlight = shouldHighlight;
var _jsTokens = jsTokens;
var _helperValidatorIdentifier = lib;
var _chalk$1 = _interopRequireWildcard$1(chalkExports$1, true);
function _getRequireWildcardCache$1(e) {
  if ("function" != typeof WeakMap) return null;
  var r3 = /* @__PURE__ */ new WeakMap(), t5 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$1 = function(e2) {
    return e2 ? t5 : r3;
  })(e);
}
function _interopRequireWildcard$1(e, r3) {
  if (!r3 && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
  var t5 = _getRequireWildcardCache$1(r3);
  if (t5 && t5.has(e)) return t5.get(e);
  var n3 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i3 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i3 && (i3.get || i3.set) ? Object.defineProperty(n3, u, i3) : n3[u] = e[u];
  }
  return n3.default = e, t5 && t5.set(e, n3), n3;
}
var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function getDefs$1(chalk2) {
  return {
    keyword: chalk2.cyan,
    capitalized: chalk2.yellow,
    jsxIdentifier: chalk2.yellow,
    punctuator: chalk2.yellow,
    number: chalk2.magenta,
    string: chalk2.green,
    regex: chalk2.magenta,
    comment: chalk2.grey,
    invalid: chalk2.white.bgRed.bold
  };
}
var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
var BRACKET = /^[()[\]{}]$/;
var tokenize;
{
  const JSX_TAG = /^[a-z][\w-]*$/i;
  const getTokenType = function(token, offset, text) {
    if (token.type === "name") {
      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
        return "keyword";
      }
      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
        return "jsxIdentifier";
      }
      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }
    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }
    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }
    return token.type;
  };
  tokenize = function* (text) {
    let match;
    while (match = _jsTokens.default.exec(text)) {
      const token = _jsTokens.matchToToken(match);
      yield {
        type: getTokenType(token, match.index, text),
        value: token.value
      };
    }
  };
}
function highlightTokens(defs, text) {
  let highlighted = "";
  for (const {
    type,
    value
  } of tokenize(text)) {
    const colorize = defs[type];
    if (colorize) {
      highlighted += value.split(NEWLINE$1).map((str) => colorize(str)).join("\n");
    } else {
      highlighted += value;
    }
  }
  return highlighted;
}
function shouldHighlight(options) {
  return _chalk$1.default.level > 0 || options.forceColor;
}
var chalkWithForcedColor$1 = void 0;
function getChalk$1(forceColor2) {
  if (forceColor2) {
    var _chalkWithForcedColor;
    (_chalkWithForcedColor = chalkWithForcedColor$1) != null ? _chalkWithForcedColor : chalkWithForcedColor$1 = new _chalk$1.default.constructor({
      enabled: true,
      level: 1
    });
    return chalkWithForcedColor$1;
  }
  return _chalk$1.default;
}
{
  lib$1.getChalk = (options) => getChalk$1(options.forceColor);
}
function highlight(code, options = {}) {
  if (code !== "" && shouldHighlight(options)) {
    const defs = getDefs$1(getChalk$1(options.forceColor));
    return highlightTokens(defs, code);
  } else {
    return code;
  }
}
var chalk = { exports: {} };
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  return str.replace(matchOperatorsRe, "\\$&");
};
var ansiStyles = { exports: {} };
ansiStyles.exports;
(function(module3) {
  const colorConvert$1 = colorConvert;
  const wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${code + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n3) => n3;
    const rgb2rgb = (r3, g, b) => [r3, g, b];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== "object") {
        continue;
      }
      const suite = colorConvert$1[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module3, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles);
var ansiStylesExports = ansiStyles.exports;
var hasFlag$1 = (flag, argv) => {
  argv = argv || process.argv;
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const pos = argv.indexOf(prefix + flag);
  const terminatorPos = argv.indexOf("--");
  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};
var os = require$$0$2;
var hasFlag = hasFlag$1;
var env = process.env;
var forceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
  forceColor = false;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  forceColor = true;
}
if ("FORCE_COLOR" in env) {
  forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function supportsColor(stream2) {
  if (forceColor === false) {
    return 0;
  }
  if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
    return 3;
  }
  if (hasFlag("color=256")) {
    return 2;
  }
  if (stream2 && !stream2.isTTY && forceColor !== true) {
    return 0;
  }
  const min = forceColor ? 1 : 0;
  if (process.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  if (env.TERM === "dumb") {
    return min;
  }
  return min;
}
function getSupportLevel(stream2) {
  const level = supportsColor(stream2);
  return translateLevel(level);
}
var supportsColor_1 = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr)
};
var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
var ESCAPES = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape(c) {
  if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }
  return ESCAPES.get(c) || c;
}
function parseArguments(name2, args2) {
  const results = [];
  const chunks = args2.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk));
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
  }
  return results;
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name2 = matches[1];
    if (matches[2]) {
      const args2 = parseArguments(name2, matches[2]);
      results.push([name2].concat(args2));
    } else {
      results.push([name2]);
    }
  }
  return results;
}
function buildStyle(chalk2, styles) {
  const enabled = {};
  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk2;
  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName]);
      } else {
        current = current[styleName];
      }
    }
  }
  return current;
}
var templates = (chalk2, tmp) => {
  const styles = [];
  const chunks = [];
  let chunk = [];
  tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
    if (escapeChar) {
      chunk.push(unescape(escapeChar));
    } else if (style) {
      const str = chunk.join("");
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk2, styles)(str));
      styles.push({ inverse, styles: parseStyle(style) });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(""));
  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMsg);
  }
  return chunks.join("");
};
(function(module3) {
  const escapeStringRegexp$12 = escapeStringRegexp;
  const ansiStyles2 = ansiStylesExports;
  const stdoutColor = supportsColor_1.stdout;
  const template = templates;
  const isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  const skipModels = /* @__PURE__ */ new Set(["gray"]);
  const styles = /* @__PURE__ */ Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = function() {
        const args2 = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk2.template].concat(args2));
      };
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = Chalk;
      return chalk2.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles2.blue.open = "\x1B[94m";
  }
  for (const key of Object.keys(ansiStyles2)) {
    ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp$12(ansiStyles2[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles2[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp$12(ansiStyles2.color.close), "g");
  for (const model of Object.keys(ansiStyles2.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.color.close,
            closeRe: ansiStyles2.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp$12(ansiStyles2.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles2.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles2.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles2.bgColor.close,
            closeRe: ansiStyles2.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args2 = arguments;
    const argsLen = args2.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args2[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles2.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles2.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles2.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk2, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args2 = [].slice.call(arguments, 2);
    const parts2 = [strings.raw[0]];
    for (let i3 = 1; i3 < strings.length; i3++) {
      parts2.push(String(args2[i3 - 1]).replace(/[{}\\]/g, "\\$&"));
      parts2.push(String(strings.raw[i3]));
    }
    return template(chalk2, parts2.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module3.exports = Chalk();
  module3.exports.supportsColor = stdoutColor;
  module3.exports.default = module3.exports;
})(chalk);
var chalkExports = chalk.exports;
Object.defineProperty(lib$2, "__esModule", {
  value: true
});
var codeFrameColumns_1 = lib$2.codeFrameColumns = codeFrameColumns;
lib$2.default = _default;
var _highlight = lib$1;
var _chalk = _interopRequireWildcard(chalkExports, true);
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r3 = /* @__PURE__ */ new WeakMap(), t5 = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(e2) {
    return e2 ? t5 : r3;
  })(e);
}
function _interopRequireWildcard(e, r3) {
  if (!r3 && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
  var t5 = _getRequireWildcardCache(r3);
  if (t5 && t5.has(e)) return t5.get(e);
  var n3 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i3 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i3 && (i3.get || i3.set) ? Object.defineProperty(n3, u, i3) : n3[u] = e[u];
  }
  return n3.default = e, t5 && t5.set(e, n3), n3;
}
var chalkWithForcedColor = void 0;
function getChalk(forceColor2) {
  if (forceColor2) {
    var _chalkWithForcedColor;
    (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({
      enabled: true,
      level: 1
    });
    return chalkWithForcedColor;
  }
  return _chalk.default;
}
var deprecationWarningShown = false;
function getDefs(chalk2) {
  return {
    gutter: chalk2.grey,
    marker: chalk2.red.bold,
    message: chalk2.red.bold
  };
}
var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(loc, source, opts) {
  const startLoc = Object.assign({
    column: 0,
    line: -1
  }, loc.start);
  const endLoc = Object.assign({}, startLoc, loc.end);
  const {
    linesAbove = 2,
    linesBelow = 3
  } = opts || {};
  const startLine = startLoc.line;
  const startColumn = startLoc.column;
  const endLine = endLoc.line;
  const endColumn = endLoc.column;
  let start2 = Math.max(startLine - (linesAbove + 1), 0);
  let end = Math.min(source.length, endLine + linesBelow);
  if (startLine === -1) {
    start2 = 0;
  }
  if (endLine === -1) {
    end = source.length;
  }
  const lineDiff = endLine - startLine;
  const markerLines = {};
  if (lineDiff) {
    for (let i3 = 0; i3 <= lineDiff; i3++) {
      const lineNumber = i3 + startLine;
      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i3 === 0) {
        const sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
      } else if (i3 === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        const sourceLength = source[lineNumber - i3].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }
  return {
    start: start2,
    end,
    markerLines
  };
}
function codeFrameColumns(rawLines, loc, opts = {}) {
  const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
  const chalk2 = getChalk(opts.forceColor);
  const defs = getDefs(chalk2);
  const maybeHighlight = (chalkFn, string) => {
    return highlighted ? chalkFn(string) : string;
  };
  const lines = rawLines.split(NEWLINE);
  const {
    start: start2,
    end,
    markerLines
  } = getMarkerLines(loc, lines, opts);
  const hasColumns = loc.start && typeof loc.start.column === "number";
  const numberMaxWidth = String(end).length;
  const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
  let frame = highlightedLines.split(NEWLINE, end).slice(start2, end).map((line, index) => {
    const number = start2 + 1 + index;
    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
    const gutter = ` ${paddedNumber} |`;
    const hasMarker = markerLines[number];
    const lastMarkerLine = !markerLines[number + 1];
    if (hasMarker) {
      let markerLine = "";
      if (Array.isArray(hasMarker)) {
        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        const numberOfMarkers = hasMarker[1] || 1;
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
        if (lastMarkerLine && opts.message) {
          markerLine += " " + maybeHighlight(defs.message, opts.message);
        }
      }
      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
    } else {
      return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
    }
  }).join("\n");
  if (opts.message && !hasColumns) {
    frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
  }
  if (highlighted) {
    return chalk2.reset(frame);
  } else {
    return frame;
  }
}
function _default(rawLines, lineNumber, colNumber, opts = {}) {
  if (!deprecationWarningShown) {
    deprecationWarningShown = true;
    const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning) {
      process.emitWarning(message, "DeprecationWarning");
    } else {
      const deprecationError = new Error(message);
      deprecationError.name = "DeprecationWarning";
      console.warn(new Error(message));
    }
  }
  colNumber = Math.max(colNumber, 0);
  const location = {
    start: {
      column: colNumber,
      line: lineNumber
    }
  };
  return codeFrameColumns(rawLines, location, opts);
}
var safeLastIndexOf = (string, searchString, index) => index < 0 ? -1 : string.lastIndexOf(searchString, index);
function getPosition(text, textIndex) {
  const lineBreakBefore = safeLastIndexOf(text, "\n", textIndex - 1);
  const column = textIndex - lineBreakBefore - 1;
  let line = 0;
  for (let index = lineBreakBefore; index >= 0; index = safeLastIndexOf(text, "\n", index - 1)) {
    line++;
  }
  return { line, column };
}
function indexToLineColumn(text, textIndex, { oneBased = false } = {}) {
  if (textIndex < 0 || textIndex >= text.length && text.length > 0) {
    throw new RangeError("Index out of bounds");
  }
  const position = getPosition(text, textIndex);
  return oneBased ? { line: position.line + 1, column: position.column + 1 } : position;
}
var getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`;
var JSONError = class _JSONError extends Error {
  name = "JSONError";
  fileName;
  codeFrame;
  rawCodeFrame;
  #message;
  constructor(message) {
    super();
    this.#message = message;
    Error.captureStackTrace?.(this, _JSONError);
  }
  get message() {
    const { fileName, codeFrame } = this;
    return `${this.#message}${fileName ? ` in ${fileName}` : ""}${codeFrame ? `

${codeFrame}
` : ""}`;
  }
  set message(message) {
    this.#message = message;
  }
};
var generateCodeFrame = (string, location, highlightCode = true) => codeFrameColumns_1(string, { start: location }, { highlightCode });
var getErrorLocation = (string, message) => {
  const match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
  if (!match) {
    return;
  }
  let { index, line, column } = match.groups;
  if (line && column) {
    return { line: Number(line), column: Number(column) };
  }
  index = Number(index);
  if (index === string.length) {
    const { line: line2, column: column2 } = indexToLineColumn(string, string.length - 1, { oneBased: true });
    return { line: line2, column: column2 + 1 };
  }
  return indexToLineColumn(string, index, { oneBased: true });
};
var addCodePointToUnexpectedToken = (message) => message.replace(
  /(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/,
  (_, _quote, token) => `"${token}"(${getCodePoint(token)})`
);
function parseJson(string, reviver, fileName) {
  if (typeof reviver === "string") {
    fileName = reviver;
    reviver = void 0;
  }
  let message;
  try {
    return JSON.parse(string, reviver);
  } catch (error) {
    message = error.message;
  }
  let location;
  if (string) {
    location = getErrorLocation(string, message);
    message = addCodePointToUnexpectedToken(message);
  } else {
    message += " while parsing empty string";
  }
  const jsonError = new JSONError(message);
  jsonError.fileName = fileName;
  if (location) {
    jsonError.codeFrame = generateCodeFrame(string, location);
    jsonError.rawCodeFrame = generateCodeFrame(
      string,
      location,
      /* highlightCode */
      false
    );
  }
  throw jsonError;
}
function toPath(urlOrPath) {
  return urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
}
var getPackagePath = (cwd) => path$1.resolve(toPath(cwd) ?? ".", "package.json");
var _readPackage = (file, normalize2) => {
  const json = typeof file === "string" ? parseJson(file) : file;
  if (normalize2) {
    normalizePackageData(json);
  }
  return json;
};
function readPackageSync({ cwd, normalize: normalize2 = true } = {}) {
  const packageFile = fs$1.readFileSync(getPackagePath(cwd), "utf8");
  return _readPackage(packageFile, normalize2);
}
function readPackageUpSync(options) {
  const filePath = findUpSync("package.json", options);
  if (!filePath) {
    return;
  }
  return {
    packageJson: readPackageSync({ ...options, cwd: path$1.dirname(filePath) }),
    path: filePath
  };
}
var handlePreserveConsecutiveUppercase = (decamelized, separator) => {
  decamelized = decamelized.replace(
    /((?<![\p{Uppercase_Letter}\d])[\p{Uppercase_Letter}\d](?![\p{Uppercase_Letter}\d]))/gu,
    ($0) => $0.toLowerCase()
  );
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    (_, $1, $2) => $1 + separator + $2.toLowerCase()
  );
};
function decamelize(text, {
  separator = "_",
  preserveConsecutiveUppercase: preserveConsecutiveUppercase2 = false
} = {}) {
  if (!(typeof text === "string" && typeof separator === "string")) {
    throw new TypeError(
      "The `text` and `separator` arguments should be of type `string`"
    );
  }
  if (text.length < 2) {
    return preserveConsecutiveUppercase2 ? text : text.toLowerCase();
  }
  const replacement = `$1${separator}$2`;
  const decamelized = text.replace(
    new RegExp("([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})", "gu"),
    replacement
  );
  if (preserveConsecutiveUppercase2) {
    return handlePreserveConsecutiveUppercase(decamelized, separator);
  }
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    replacement
  ).toLowerCase();
}
var minimistOptions = { exports: {} };
var toString$1 = Object.prototype.toString;
var isPlainObj = function(x) {
  var prototype;
  return toString$1.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};
var arrify$1 = function(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
};
var toString = Object.prototype.toString;
var kindOf$1 = function kindOf(val) {
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  var type = typeof val;
  if (type === "boolean") return "boolean";
  if (type === "string") return "string";
  if (type === "number") return "number";
  if (type === "symbol") return "symbol";
  if (type === "function") {
    return isGeneratorFn(val) ? "generatorfunction" : "function";
  }
  if (isArray(val)) return "array";
  if (isBuffer(val)) return "buffer";
  if (isArguments(val)) return "arguments";
  if (isDate(val)) return "date";
  if (isError(val)) return "error";
  if (isRegexp(val)) return "regexp";
  switch (ctorName(val)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    // Set, Map, WeakSet, WeakMap
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    // 8-bit typed arrays
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    // 16-bit typed arrays
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    // 32-bit typed arrays
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (isGeneratorObj(val)) {
    return "generator";
  }
  type = toString.call(val);
  switch (type) {
    case "[object Object]":
      return "object";
    // iterators
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function isGeneratorFn(name2, val) {
  return ctorName(name2) === "GeneratorFunction";
}
function isGeneratorObj(val) {
  return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function isArguments(val) {
  try {
    if (typeof val.length === "number" && typeof val.callee === "function") {
      return true;
    }
  } catch (err2) {
    if (err2.message.indexOf("callee") !== -1) {
      return true;
    }
  }
  return false;
}
function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === "function") {
    return val.constructor.isBuffer(val);
  }
  return false;
}
var isPlainObject = isPlainObj;
var arrify = arrify$1;
var kindOf2 = kindOf$1;
var push = (obj, prop, value) => {
  if (!obj[prop]) {
    obj[prop] = [];
  }
  obj[prop].push(value);
};
var insert = (obj, prop, key, value) => {
  if (!obj[prop]) {
    obj[prop] = {};
  }
  obj[prop][key] = value;
};
var prettyPrint = (output) => {
  return Array.isArray(output) ? `[${output.map(prettyPrint).join(", ")}]` : kindOf2(output) === "string" ? JSON.stringify(output) : output;
};
var resolveType = (value) => {
  if (Array.isArray(value) && value.length > 0) {
    const [element] = value;
    return `${kindOf2(element)}-array`;
  }
  return kindOf2(value);
};
var normalizeExpectedType = (type, defaultValue) => {
  const inferredType = type === "array" ? "string-array" : type;
  if (arrayTypes.includes(inferredType) && Array.isArray(defaultValue) && defaultValue.length === 0) {
    return "array";
  }
  return inferredType;
};
var passthroughOptions = ["stopEarly", "unknown", "--"];
var primitiveTypes = ["string", "boolean", "number"];
var arrayTypes = primitiveTypes.map((t5) => `${t5}-array`);
var availableTypes = [...primitiveTypes, "array", ...arrayTypes];
var buildOptions = (options) => {
  options = options || {};
  const result = {};
  passthroughOptions.forEach((key) => {
    if (options[key]) {
      result[key] = options[key];
    }
  });
  Object.keys(options).forEach((key) => {
    let value = options[key];
    if (key === "arguments") {
      key = "_";
    }
    if (typeof value === "string") {
      value = { type: value };
    }
    if (isPlainObject(value)) {
      const props = value;
      const { type } = props;
      if (type) {
        if (!availableTypes.includes(type)) {
          throw new TypeError(`Expected type of "${key}" to be one of ${prettyPrint(availableTypes)}, got ${prettyPrint(type)}`);
        }
        if (arrayTypes.includes(type)) {
          const [elementType] = type.split("-");
          push(result, "array", { key, [elementType]: true });
        } else {
          push(result, type, key);
        }
      }
      if ({}.hasOwnProperty.call(props, "default")) {
        const { default: defaultValue } = props;
        const defaultType = resolveType(defaultValue);
        const expectedType = normalizeExpectedType(type, defaultValue);
        if (expectedType && expectedType !== defaultType) {
          throw new TypeError(`Expected "${key}" default value to be of type "${expectedType}", got ${prettyPrint(defaultType)}`);
        }
        insert(result, "default", key, defaultValue);
      }
      arrify(props.alias).forEach((alias) => {
        insert(result, "alias", alias, key);
      });
    }
  });
  return result;
};
minimistOptions.exports = buildOptions;
minimistOptions.exports.default = buildOptions;
var minimistOptionsExports = minimistOptions.exports;
var constructParserOptions = /* @__PURE__ */ getDefaultExportFromCjs(minimistOptionsExports);
var mapObj = { exports: {} };
var isObject$1 = (value) => typeof value === "object" && value !== null;
var mapObjectSkip = Symbol("skip");
var isObjectCustom = (value) => isObject$1(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
  options = {
    deep: false,
    target: {},
    ...options
  };
  if (isSeen.has(object)) {
    return isSeen.get(object);
  }
  isSeen.set(object, options.target);
  const { target } = options;
  delete options.target;
  const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
  if (Array.isArray(object)) {
    return mapArray(object);
  }
  for (const [key, value] of Object.entries(object)) {
    const mapResult = mapper(key, value, object);
    if (mapResult === mapObjectSkip) {
      continue;
    }
    let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
    if (newKey === "__proto__") {
      continue;
    }
    if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
      newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
    }
    target[newKey] = newValue;
  }
  return target;
};
mapObj.exports = (object, mapper, options) => {
  if (!isObject$1(object)) {
    throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
  }
  return mapObject(object, mapper, options);
};
mapObj.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj.exports;
var mapObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(mapObjExports);
var has = (array, key) => array.some((element) => {
  if (typeof element === "string") {
    return element === key;
  }
  element.lastIndex = 0;
  return element.test(key);
});
var cache = new QuickLRU({ maxSize: 1e5 });
var isObject = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var transform = (input, options = {}) => {
  if (!isObject(input)) {
    return input;
  }
  const {
    separator = "_",
    exclude,
    deep = false
  } = options;
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject(value)) {
      value = mapObject$1(value, makeMapper());
    }
    if (!(exclude && has(exclude, key))) {
      const cacheKey = `${separator}${key}`;
      if (cache.has(cacheKey)) {
        key = cache.get(cacheKey);
      } else {
        const returnValue = decamelize(key, { separator });
        if (key.length < 100) {
          cache.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return mapObject$1(input, makeMapper());
};
function decamelizeKeys(input, options) {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => transform(input[key], options));
  }
  return transform(input, options);
}

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/options.js
import process2 from "node:process";
import { dirname } from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/utils.js
var decamelizeFlagKey = (flagKey) => `--${decamelize(flagKey, { separator: "-" })}`;
var joinFlagKeys = (flagKeys, prefix = "--") => `\`${prefix}${flagKeys.join(`\`, \`${prefix}`)}\``;

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/options.js
var validateOptions = (options) => {
  const invalidOptionFilters = {
    flags: {
      keyContainsDashes: {
        filter: ([flagKey]) => flagKey.includes("-") && flagKey !== "--",
        message: (flagKeys) => `Flag keys may not contain '-'. Invalid flags: ${joinFlagKeys(flagKeys, "")}`
      },
      aliasIsSet: {
        filter: ([, flag]) => Object.hasOwn(flag, "alias"),
        message: (flagKeys) => `The option \`alias\` has been renamed to \`shortFlag\`. The following flags need to be updated: ${joinFlagKeys(flagKeys)}`
      },
      choicesNotAnArray: {
        filter: ([, flag]) => Object.hasOwn(flag, "choices") && !Array.isArray(flag.choices),
        message: (flagKeys) => `The option \`choices\` must be an array. Invalid flags: ${joinFlagKeys(flagKeys)}`
      },
      choicesNotMatchFlagType: {
        filter: ([, flag]) => flag.type && Array.isArray(flag.choices) && flag.choices.some((choice) => typeof choice !== flag.type),
        message(flagKeys) {
          const flagKeysAndTypes = flagKeys.map((flagKey) => `(\`${decamelizeFlagKey(flagKey)}\`, type: '${options.flags[flagKey].type}')`);
          return `Each value of the option \`choices\` must be of the same type as its flag. Invalid flags: ${flagKeysAndTypes.join(", ")}`;
        }
      },
      defaultNotInChoices: {
        filter: ([, flag]) => flag.default && Array.isArray(flag.choices) && ![flag.default].flat().every((value) => flag.choices.includes(value)),
        message: (flagKeys) => `Each value of the option \`default\` must exist within the option \`choices\`. Invalid flags: ${joinFlagKeys(flagKeys)}`
      }
    }
  };
  const errorMessages = [];
  for (const [optionKey, filters] of Object.entries(invalidOptionFilters)) {
    const optionEntries = Object.entries(options[optionKey]);
    for (const { filter, message } of Object.values(filters)) {
      const invalidOptions = optionEntries.filter((option) => filter(option));
      const invalidOptionKeys = invalidOptions.map(([key]) => key);
      if (invalidOptions.length > 0) {
        errorMessages.push(message(invalidOptionKeys));
      }
    }
  }
  if (errorMessages.length > 0) {
    throw new Error(errorMessages.join("\n"));
  }
};
var buildOptions2 = (helpText, options) => {
  if (typeof helpText !== "string") {
    options = helpText;
    helpText = "";
  }
  if (!options.importMeta?.url) {
    throw new TypeError("The `importMeta` option is required. Its value must be `import.meta`.");
  }
  const foundPackage = readPackageUpSync({
    cwd: dirname(fileURLToPath2(options.importMeta.url)),
    normalize: false
  });
  const parsedOptions = {
    pkg: foundPackage ? foundPackage.packageJson : {},
    argv: process2.argv.slice(2),
    flags: {},
    inferType: false,
    input: "string",
    help: helpText,
    autoHelp: true,
    autoVersion: true,
    booleanDefault: false,
    allowUnknownFlags: true,
    allowParentFlags: true,
    helpIndent: 2,
    ...options
  };
  validateOptions(parsedOptions);
  return parsedOptions;
};

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/parser.js
var buildParserFlags = ({ flags: flags8, booleanDefault }) => {
  const parserFlags = {};
  for (const [flagKey, flagValue] of Object.entries(flags8)) {
    const flag = { ...flagValue };
    if (flag.shortFlag) {
      flag.alias = flag.shortFlag;
      delete flag.shortFlag;
    }
    if (booleanDefault !== void 0 && flag.type === "boolean" && !Object.hasOwn(flag, "default")) {
      flag.default = flag.isMultiple ? [booleanDefault] : booleanDefault;
    }
    if (flag.isMultiple) {
      flag.type = flag.type ? `${flag.type}-array` : "array";
      flag.default = flag.default ?? [];
      delete flag.isMultiple;
    }
    if (Array.isArray(flag.aliases)) {
      if (flag.alias) {
        flag.aliases.push(flag.alias);
      }
      flag.alias = flag.aliases;
      delete flag.aliases;
    }
    parserFlags[flagKey] = flag;
  }
  return parserFlags;
};
var buildParserOptions = (options) => {
  let parserOptions = buildParserFlags(options);
  parserOptions.arguments = options.input;
  parserOptions = decamelizeKeys(parserOptions, { separator: "-", exclude: ["stopEarly", "--"] });
  if (options.inferType) {
    delete parserOptions.arguments;
  }
  if (!options.allowUnknownFlags) {
    if (options.autoHelp && !parserOptions.help) {
      parserOptions.help = { type: "boolean" };
    }
    if (options.autoVersion && !parserOptions.version) {
      parserOptions.version = { type: "boolean" };
    }
  }
  parserOptions = constructParserOptions(parserOptions);
  parserOptions.configuration = {
    ...parserOptions.configuration,
    "greedy-arrays": false
  };
  if (parserOptions["--"]) {
    parserOptions.configuration["populate--"] = true;
  }
  if (!options.allowUnknownFlags) {
    parserOptions.configuration["unknown-options-as-args"] = true;
  }
  return parserOptions;
};

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/validate.js
import process3 from "node:process";
var validateFlags = (flags8, options) => {
  for (const [flagKey, flagValue] of Object.entries(options.flags)) {
    if (flagKey !== "--" && !flagValue.isMultiple && Array.isArray(flags8[flagKey])) {
      throw new Error(`The flag --${flagKey} can only be set once.`);
    }
  }
};
var validateChoicesByFlag = (flagKey, flagValue, receivedInput) => {
  const { choices, isRequired } = flagValue;
  if (!choices) {
    return;
  }
  const valueMustBeOneOf = `Value must be one of: [\`${choices.join("`, `")}\`]`;
  if (!receivedInput) {
    if (isRequired) {
      return `Flag \`${decamelizeFlagKey(flagKey)}\` has no value. ${valueMustBeOneOf}`;
    }
    return;
  }
  if (Array.isArray(receivedInput)) {
    const unknownValues = receivedInput.filter((index) => !choices.includes(index));
    if (unknownValues.length > 0) {
      const valuesText = unknownValues.length > 1 ? "values" : "value";
      return `Unknown ${valuesText} for flag \`${decamelizeFlagKey(flagKey)}\`: \`${unknownValues.join("`, `")}\`. ${valueMustBeOneOf}`;
    }
  } else if (!choices.includes(receivedInput)) {
    return `Unknown value for flag \`${decamelizeFlagKey(flagKey)}\`: \`${receivedInput}\`. ${valueMustBeOneOf}`;
  }
};
var validateChoices = (flags8, receivedFlags) => {
  const errors = [];
  for (const [flagKey, flagValue] of Object.entries(flags8)) {
    const receivedInput = receivedFlags[flagKey];
    const errorMessage = validateChoicesByFlag(flagKey, flagValue, receivedInput);
    if (errorMessage) {
      errors.push(errorMessage);
    }
  }
  if (errors.length > 0) {
    throw new Error(`${errors.join("\n")}`);
  }
};
var validate = (flags8, options) => {
  validateFlags(flags8, options);
  validateChoices(options.flags, flags8);
};
var reportUnknownFlags = (unknownFlags) => {
  console.error([
    `Unknown flag${unknownFlags.length > 1 ? "s" : ""}`,
    ...unknownFlags
  ].join("\n"));
};
var checkUnknownFlags = (input) => {
  const unknownFlags = input.filter((item) => typeof item === "string" && item.startsWith("-"));
  if (unknownFlags.length > 0) {
    reportUnknownFlags(unknownFlags);
    process3.exit(2);
  }
};
var isFlagMissing = (flagName, definedFlags, receivedFlags, input) => {
  const flag = definedFlags[flagName];
  let isFlagRequired = true;
  if (typeof flag.isRequired === "function") {
    isFlagRequired = flag.isRequired(receivedFlags, input);
    if (typeof isFlagRequired !== "boolean") {
      throw new TypeError(`Return value for isRequired callback should be of type boolean, but ${typeof isFlagRequired} was returned.`);
    }
  }
  if (receivedFlags[flagName] === void 0) {
    return isFlagRequired;
  }
  return flag.isMultiple && receivedFlags[flagName].length === 0 && isFlagRequired;
};
var reportMissingRequiredFlags = (missingRequiredFlags) => {
  console.error(`Missing required flag${missingRequiredFlags.length > 1 ? "s" : ""}`);
  for (const flag of missingRequiredFlags) {
    console.error(`	${decamelizeFlagKey(flag.key)}${flag.shortFlag ? `, -${flag.shortFlag}` : ""}`);
  }
};
var checkMissingRequiredFlags = (flags8, receivedFlags, input) => {
  const missingRequiredFlags = [];
  if (flags8 === void 0) {
    return [];
  }
  for (const flagName of Object.keys(flags8)) {
    if (flags8[flagName].isRequired && isFlagMissing(flagName, flags8, receivedFlags, input)) {
      missingRequiredFlags.push({ key: flagName, ...flags8[flagName] });
    }
  }
  if (missingRequiredFlags.length > 0) {
    reportMissingRequiredFlags(missingRequiredFlags);
    process3.exit(2);
  }
};

// node_modules/.pnpm/meow@13.2.0/node_modules/meow/build/index.js
var buildResult = (options, parserOptions) => {
  const { pkg: package_ } = options;
  const argv = yargsParser(options.argv, parserOptions);
  let help = "";
  if (options.help) {
    help = trimNewlines((options.help || "").replace(/\t+\n*$/, ""));
    if (help.includes("\n")) {
      help = redent(help, options.helpIndent);
    }
    help = `
${help}`;
  }
  normalizePackageData(package_);
  let { description } = options;
  if (!description && description !== false) {
    ({ description } = package_);
  }
  description &&= help ? redent(`
${description}
`, options.helpIndent) : `
${description}`;
  help = `${description || ""}${help}
`;
  const showHelp = (code) => {
    console.log(help);
    process4.exit(typeof code === "number" ? code : 2);
  };
  const showVersion = () => {
    console.log(typeof options.version === "string" ? options.version : package_.version);
    process4.exit(0);
  };
  if (argv._.length === 0 && options.argv.length === 1) {
    if (argv.version === true && options.autoVersion) {
      showVersion();
    } else if (argv.help === true && options.autoHelp) {
      showHelp(0);
    }
  }
  const input = argv._;
  delete argv._;
  if (!options.allowUnknownFlags) {
    checkUnknownFlags(input);
  }
  const flags8 = camelcaseKeys(argv, { exclude: ["--", /^\w$/] });
  const unnormalizedFlags = { ...flags8 };
  validate(flags8, options);
  for (const flagValue of Object.values(options.flags)) {
    if (Array.isArray(flagValue.aliases)) {
      for (const alias of flagValue.aliases) {
        delete flags8[alias];
      }
    }
    delete flags8[flagValue.shortFlag];
  }
  checkMissingRequiredFlags(options.flags, flags8, input);
  return {
    input,
    flags: flags8,
    unnormalizedFlags,
    pkg: package_,
    help,
    showHelp,
    showVersion
  };
};
var meow = (helpText, options = {}) => {
  const parsedOptions = buildOptions2(helpText, options);
  const parserOptions = buildParserOptions(parsedOptions);
  const result = buildResult(parsedOptions, parserOptions);
  process4.title = result.pkg.bin ? Object.keys(result.pkg.bin).at(0) : result.pkg.name;
  return result;
};

// dist/commands/jvm-reachability-analysis.js
var flags2 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  alucard: { type: "string" },
  treeSitterJava: { type: "string" },
  treeSitterKotlin: { type: "string" },
  treeSitterScala: { type: "string" }
};
var runJvmReachabilityAnalysisCmd = {
  description: "Run JVM reachability analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runJvmReachabilityAnalysis [options]

    Options
      --input-file, -i        Input file for data and vulnerabilities (required)
      --output-file, -o       Output file for the results (required)
      --alucard               Path to alucard jar
      --tree-sitter-java      Path to tree-sitter-java dir
      --tree-sitter-kotlin    Path to tree-sitter-kotlin dir
      --tree-sitter-scala     Path to tree-sitter-scala dir

    Examples
      $ ${parentName} runJvmReachabilityAnalysis -i input.json -o output.json --alucard alucard.jar
    `, {
      importMeta,
      argv,
      flags: flags2
    });
    const { inputFile, outputFile, alucard, treeSitterJava, treeSitterKotlin, treeSitterScala } = cli.flags;
    const resources = { alucard, treeSitterJava, treeSitterKotlin, treeSitterScala };
    const analysisOptions = JSON.parse(await readFile7(inputFile, "utf-8"));
    const result = await runJvmReachabilityAnalysis(analysisOptions, resources);
    await writeFile2(outputFile, JSON.stringify({ result }));
  }
};

// dist/commands/jvm-direct-dependency-analysis.js
import { readFile as readFile8, writeFile as writeFile3 } from "node:fs/promises";
var flags3 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  alucard: { type: "string" },
  treeSitterJava: { type: "string" },
  treeSitterKotlin: { type: "string" },
  treeSitterScala: { type: "string" }
};
var runJvmDirectDependencyAnalysisCmd = {
  description: "Run JVM direct dependency analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runJvmDirectDependencyAnalysis [options]

    Options
      --input-file, -i        Input file for data and vulnerabilities (required)
      --output-file, -o       Output file for the results (required)
      --alucard               Path to alucard jar
      --tree-sitter-java      Path to tree-sitter-java dir
      --tree-sitter-kotlin    Path to tree-sitter-kotlin dir
      --tree-sitter-scala     Path to tree-sitter-scala dir

    Examples
      $ ${parentName} runJvmDirectDependencyAnalysis -i input.json -o output.json --alucard alucard.jar
    `, {
      importMeta,
      argv,
      flags: flags3
    });
    const { inputFile, outputFile, alucard, treeSitterJava, treeSitterKotlin, treeSitterScala } = cli.flags;
    if (!inputFile || !outputFile) {
      console.error("Error: --input-file and --output-file are required");
      process.exit(1);
    }
    const resources = { alucard, treeSitterJava, treeSitterKotlin, treeSitterScala };
    const analysisOptions = JSON.parse(await readFile8(inputFile, "utf-8"));
    const result = await runJvmDirectDependencyAnalysis(analysisOptions, resources);
    await writeFile3(outputFile, JSON.stringify({ result }));
  }
};

// dist/commands/dotnet-direct-dependency-analysis.js
import { readFile as readFile10, writeFile as writeFile5 } from "node:fs/promises";

// dist/dotnet-reachability-analyzer.js
import { extname as extname5 } from "node:path";

// dist/class-graph/dotnet/c-sharp-source-resolver.js
var CSharpSourceResolver = class extends AbstractTreeSitterSourceResolver {
  constructor(parser2, subtypeMap) {
    super(parser2, subtypeMap);
  }
  async parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph) {
    if (ecosystemSpecificPackageInfo.type !== "DOTNET")
      return;
    function getFullyQualifiedName(context) {
      const namespaceName = context.namespaceParts.join(".");
      const className = context.classParts.join("+") || "Program";
      return namespaceName ? `${namespaceName}.${className}` : className;
    }
    const contextStack = [
      {
        namespaceParts: [],
        classParts: [],
        importsMap: /* @__PURE__ */ new Map(),
        parentImportsMap: /* @__PURE__ */ new Map(),
        depth: -1,
        maybeReferences: [],
        externAliases: ["global"]
      }
    ];
    const cursor = tree.walk();
    this.record(packageId, container, file, getFullyQualifiedName(contextStack[0]), cursor, graph);
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext4(oldContext, cursor, this.subtypeMap);
      switch (cursor.nodeType) {
        case "compilation_unit":
        case "class_declaration":
        case "interface_declaration":
        case "enum_declaration":
        case "struct_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          break;
        }
        case "file_scoped_namespace_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          contextStack[contextStack.length - 1] = newContext;
          break;
        }
        case "namespace_declaration": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph);
          if (!cursorHasChildOfType(cursor, "body", this.subtypeMap)) {
            contextStack[contextStack.length - 1] = newContext;
          }
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
    tree.delete();
  }
  async parseEdges(requestedNode, tree, resolutionContext, graph) {
    if (resolutionContext.type !== "DOTNET")
      return;
    for (const nodeId of this.containerToFileToNodeIds.get(requestedNode.container)?.get(requestedNode.file) ?? []) {
      const idx = resolutionContext.nodeIdToIndex.get(nodeId);
      if (idx === void 0 || resolutionContext.visited.has(idx) || resolutionContext.nodes[idx].resolutionType !== "src") {
        continue;
      }
      resolutionContext.visited.add(idx);
      const resolveNode = resolutionContext.nodes[idx];
      this.getEdgesForNode(tree, resolveNode, resolutionContext, graph);
    }
  }
  getEdgesForNode(tree, fromNode, dotnetResolutionContext, graph) {
    const fromIdx = dotnetResolutionContext.nodeIdToIndex.get(fromNode.nodeId);
    if (fromIdx === void 0)
      return;
    function addReference(fromIdx2, toIdx, confidence) {
      graph.addEdge(fromIdx2, toIdx, confidence);
    }
    const [fqnOfEnclosingClass] = fromNode.fullyQualifiedName.split("+");
    for (const toIdx of dotnetResolutionContext.nestedClassMap.get(fqnOfEnclosingClass) ?? []) {
      if (fromIdx !== toIdx) {
        addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
      }
    }
    const packageName = fqnOfEnclosingClass.split(".").slice(0, -1).join(".");
    const packageImportsMap = new Map(Array.from(dotnetResolutionContext.childMap.get(packageName) ?? []).map((child) => [
      child,
      [`${packageName}.${child}`]
    ]));
    let initialContext = {
      namespaceParts: [],
      classParts: [],
      importsMap: packageImportsMap,
      parentImportsMap: packageImportsMap,
      depth: -1,
      maybeReferences: [],
      externAliases: ["global"]
    };
    const updateInitialContextCB = (cursor2) => {
      initialContext = getUpdatedContext4(initialContext, cursor2, this.subtypeMap, dotnetResolutionContext.childMap);
    };
    const treeIndex = this.nodeIdToTreeIndes.get(fromNode.nodeId);
    if (treeIndex === void 0)
      return void 0;
    const cursor = walkTreeToIndex(tree, treeIndex, updateInitialContextCB);
    if (!cursor)
      return void 0;
    const contextStack = [initialContext];
    let done = false;
    let start2 = true;
    let startedBefore = false;
    while (!done) {
      let addReferencesToName2 = function(fromIdx2, fqnOrSimpleName) {
        function tryAdd(fqn) {
          let added = false;
          for (const toIdx of dotnetResolutionContext.reflectionMap.get(fqn) ?? []) {
            addReference(fromIdx2, toIdx, REFLECTION_CONFIDENCE);
            added = true;
          }
          for (const toIdx of dotnetResolutionContext.fqnMap.get(fqn) ?? []) {
            addReference(fromIdx2, toIdx, TYPE_REFERENCE_CONFIDENCE);
            added = true;
          }
          return added;
        }
        if (!fqnOrSimpleName)
          return;
        for (const resolvedFqn of resolveImport(fqnOrSimpleName, currentContext.importsMap)) {
          if (!tryAdd(resolvedFqn)) {
            const fqnParts = resolvedFqn.split(".");
            if (fqnParts.length > 1) {
              const parentFqn = fqnParts.slice(0, -1).join(".");
              tryAdd(parentFqn);
            }
          }
        }
      };
      var addReferencesToName = addReferencesToName2;
      start2 &&= !startedBefore;
      startedBefore = true;
      const currentContext = contextStack[contextStack.length - 1];
      for (const fqn of currentContext.maybeReferences) {
        for (const toIdx of dotnetResolutionContext.fqnMap.get(fqn) ?? []) {
          addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
        }
      }
      switch (cursor.nodeType) {
        case "identifier": {
          addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "qualified_identifier": {
          addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "qualified_name": {
          addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "alias_qualified_name": {
          addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "invocation_expression": {
          if (cursorGoToChildOfFieldName(cursor, "function")) {
            addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "member_access_expression": {
          if (cursorGoToChildOfFieldName(cursor, "expression")) {
            addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "object_creation_expression":
        case "cast_expression": {
          if (cursorGoToChildOfFieldName(cursor, "type")) {
            addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "is_expression": {
          if (cursorGoToChildOfFieldName(cursor, "right")) {
            addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "attribute": {
          if (cursorGoToChildOfFieldName(cursor, "name")) {
            addReferencesToName2(fromIdx, sanitizeName4(cursor, currentContext.externAliases));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "string_literal": {
          for (const toIdx of dotnetResolutionContext.reflectionMap.get(parseCSharpString(cursor.nodeText)) ?? []) {
            addReference(fromIdx, toIdx, REFLECTION_CONFIDENCE);
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
        case "using_directive": {
          contextStack[contextStack.length - 1] = getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap);
          break;
        }
        case "compilation_unit":
        case "class_declaration":
        case "interface_declaration":
        case "enum_declaration":
        case "struct_declaration": {
          if (start2) {
            if (cursor.gotoFirstChild()) {
              contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            } else {
              done = true;
            }
            continue;
          }
          break;
        }
        case "file_scoped_namespace_declaration": {
          if (start2) {
            contextStack[contextStack.length - 1] = getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap);
          } else {
            if (cursor.gotoParent()) {
              contextStack.pop();
              continue;
            }
            done = true;
          }
          break;
        }
        case "namespace_declaration": {
          const hasBody = cursorChildForFieldNameText(cursor, "body");
          if (start2) {
            if (hasBody) {
              if (cursor.gotoFirstChild()) {
                contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
                continue;
              }
            } else {
              contextStack[contextStack.length - 1] = getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap);
            }
          } else {
            if (!hasBody) {
              contextStack.pop();
              if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
                done = true;
                break;
              }
            }
          }
          break;
        }
        default: {
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext4(currentContext, cursor, this.subtypeMap, dotnetResolutionContext.childMap));
            continue;
          }
          break;
        }
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
          done = true;
          break;
        }
      }
    }
  }
};
function getUpdatedContext4(oldContext, cursor, subtypeMap, childMap) {
  const newContext = { ...oldContext, depth: cursor.currentDepth };
  if (cursor.currentDepth > oldContext.depth) {
    newContext.parentImportsMap = oldContext.importsMap;
  }
  function processUsingDirective(cursor2) {
    const alias = cursorChildForFieldNameText(cursor2, "name");
    newContext.importsMap = copyImportsMap(newContext.importsMap);
    if (alias) {
      if (cursorGoToChildOfType(cursor2, "type", subtypeMap)) {
        const sanitizedName = sanitizeName4(cursor2, newContext.externAliases);
        const resolvedName = resolveImport(sanitizedName, newContext.parentImportsMap);
        newContext.importsMap.set(alias, resolvedName);
        cursor2.gotoParent();
      }
    } else {
      if (cursor2.gotoFirstChild()) {
        do {
          switch (cursor2.nodeType) {
            case "identifier":
            case "generic_name":
            case "qualified_name":
            case "alias_qualified_name": {
              const sanitizedName = sanitizeName4(cursor2, newContext.externAliases);
              for (const resolvedName of resolveImport(sanitizedName, newContext.parentImportsMap)) {
                childMap?.get(resolvedName)?.forEach((child) => {
                  if (!newContext.importsMap.has(child)) {
                    newContext.importsMap.set(child, []);
                  }
                  newContext.importsMap.get(child).push(`${resolvedName}.${child}`);
                });
                newContext.maybeReferences = newContext.maybeReferences.concat(resolvedName);
              }
              break;
            }
          }
        } while (cursor2.gotoNextSibling());
        cursor2.gotoParent();
      }
    }
  }
  switch (cursor.nodeType) {
    case "class_declaration":
    case "interface_declaration":
    case "struct_declaration":
    case "enum_declaration": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      let arity2 = 0;
      if (cursorGoToChildOfType(cursor, "type_parameter_list", subtypeMap)) {
        if (cursorGoToChildOfType(cursor, "type_parameter", subtypeMap)) {
          ++arity2;
          while (cursorGoToSiblingOfType(cursor, "type_parameter", subtypeMap)) {
            ++arity2;
          }
          cursor.gotoParent();
        }
        cursor.gotoParent();
      }
      if (name2) {
        newContext.classParts = newContext.classParts.concat(arity2 ? `${name2}\`${arity2}` : name2);
      }
      break;
    }
    case "namespace_declaration":
    case "file_scoped_namespace_declaration": {
      const name2 = cursorChildForFieldNameText(cursor, "name");
      if (name2) {
        newContext.namespaceParts = newContext.namespaceParts.concat(name2);
        newContext.classParts = [];
      }
      break;
    }
    case "extern_alias_directive": {
      const alias = cursorChildForFieldNameText(cursor, "name");
      if (alias) {
        newContext.externAliases = newContext.externAliases.concat(alias);
      }
      break;
    }
    case "using_directive": {
      processUsingDirective(cursor);
      break;
    }
  }
  return newContext;
}
function sanitizeName4(cursor, externAliases) {
  switch (cursor.nodeType) {
    case "identifier": {
      return cursor.nodeText;
    }
    case "qualified_identifier":
    case "qualified_name": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName4(cursor, externAliases));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "generic_name": {
      return cursorChildForTypeText(cursor, "identifier", void 0) ?? cursor.nodeText;
    }
    case "alias_qualified_name": {
      const alias = cursorChildForFieldNameText(cursor, "alias");
      if (cursorGoToChildOfFieldName(cursor, "name")) {
        const name2 = sanitizeName4(cursor, externAliases);
        cursor.gotoParent();
        if (alias && name2) {
          return externAliases.includes(alias) ? name2 : `${alias}.${name2}`;
        }
      }
      return cursor.nodeText;
    }
    case "nullable_type":
    case "array_type":
    case "pointer_type":
    case "scoped_type":
    case "ref_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const baseType = sanitizeName4(cursor, externAliases);
        cursor.gotoParent();
        return baseType;
      }
      return cursor.nodeText;
    }
    case "type": {
      if (cursor.gotoFirstChild()) {
        const result = sanitizeName4(cursor, externAliases);
        cursor.gotoParent();
        return result;
      }
      return cursor.nodeText;
    }
    default:
      return cursor.nodeText;
  }
}
function parseCSharpString(input) {
  if (input.startsWith('"""') && input.endsWith('"""')) {
    return input.slice(3, -3);
  }
  if (input.startsWith('$"""') && input.endsWith('"""')) {
    return input.slice(4, -3);
  }
  if (input.startsWith('@"') && input.endsWith('"')) {
    return input.slice(2, -1).replace(/""/g, '"');
  }
  if ((input.startsWith('$@"') || input.startsWith('@$"')) && input.endsWith('"')) {
    return input.slice(3, -1).replace(/""/g, '"');
  }
  if (input.startsWith('$"') && input.endsWith('"')) {
    return input.slice(2, -1);
  }
  if (input.startsWith('"') && input.endsWith('"')) {
    return input.slice(1, -1);
  }
  return input;
}

// dist/class-graph/dotnet/dotnet-resolution-context-provider.js
var DotnetResolutionContextProvider = class {
  getResolutionContext(nodes, visited) {
    const nodeIdToIndex = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < nodes.length; ++i3) {
      nodeIdToIndex.set(nodes[i3].nodeId, i3);
    }
    const fqnMap = /* @__PURE__ */ new Map();
    const reflectionMap = /* @__PURE__ */ new Map();
    const nestedClassMap = /* @__PURE__ */ new Map();
    const childMap = /* @__PURE__ */ new Map();
    nodes.forEach((node, idx) => {
      const fqn = node.fullyQualifiedName;
      if (node.nodeType === "type") {
        const prettyFqn = node.fullyQualifiedName.split("+").filter(Boolean).join(".").replace(/`\d+/g, "");
        if (!fqnMap.has(prettyFqn)) {
          fqnMap.set(prettyFqn, []);
        }
        fqnMap.get(prettyFqn).push(idx);
        const [fqnOfEnclosingClass] = fqn.split("+");
        if (!nestedClassMap.has(fqnOfEnclosingClass)) {
          nestedClassMap.set(fqnOfEnclosingClass, []);
        }
        nestedClassMap.get(fqnOfEnclosingClass).push(idx);
        const parts2 = fqn.split(/[.+]/).filter(Boolean);
        for (let i3 = 1; i3 < parts2.length; i3++) {
          const parent = parts2.slice(0, i3).join(".");
          const child = parts2[i3];
          if (!childMap.has(parent)) {
            childMap.set(parent, []);
          }
          childMap.get(parent).push(child);
        }
      }
      if (!reflectionMap.has(fqn)) {
        reflectionMap.set(fqn, []);
      }
      reflectionMap.get(fqn).push(idx);
    });
    visited ??= /* @__PURE__ */ new Set();
    return {
      type: "DOTNET",
      nodes,
      visited,
      nodeIdToIndex,
      fqnMap,
      reflectionMap,
      nestedClassMap,
      childMap
    };
  }
};

// dist/class-graph/dotnet/cocoa-resolution-manager.js
import { readFile as readFile9, writeFile as writeFile4 } from "node:fs/promises";
import { resolve as resolve3 } from "node:path";
var CocoaResolutionManager = class {
  cocoaPath;
  timeoutInSeconds;
  constructor(cocoaPath, timeoutInSeconds) {
    this.cocoaPath = cocoaPath;
    this.timeoutInSeconds = timeoutInSeconds;
  }
  async resolveDeclarations(graph, apps, deps) {
    await withTmpDirectory("cocoa-resolution-manager", async (tmpDir) => {
      const packages = { ...apps, ...deps };
      const inputFileData = {
        packageIdToBin: Object.fromEntries(Object.entries(packages).filter(([_, packageInfo]) => packageInfo.bin?.length).map(([packageId, packageInfo]) => [packageId, packageInfo.bin ?? []]))
      };
      const inputFile = resolve3(tmpDir, "input.json");
      await writeFile4(inputFile, JSON.stringify(inputFileData));
      const cmd = cmdt`dotnet ${this.cocoaPath} resolveNodes --batch-mode --input-file=${inputFile} --output-dir=${tmpDir} --timeout=${this.timeoutInSeconds}`;
      const execResult = await execNeverFail(cmd, ".");
      if (execResult.error)
        throw new Error("cocoa could not resolve class graph nodes");
      const nodes = JSON.parse(await readFile9(resolve3(tmpDir, "nodes.json"), "utf-8"));
      graph.addNodes(nodes);
    });
  }
  async resolveEdges(graph, appIndices, worklist, visited, mode) {
    await withTmpDirectory("cocoa-resolution-manager", async (tmpDir) => {
      const inputFileData = {
        nodes: graph.getNodes(),
        edges: convertClassGraphEdgesToRecord(graph.getEdges()),
        worklist,
        visited: Array.from(visited),
        appIndices
      };
      const inputFile = resolve3(tmpDir, "input.json");
      await writeFile4(inputFile, JSON.stringify(inputFileData));
      const cmd = cmdt`dotnet ${this.cocoaPath} resolveEdges --batch-mode ${mode === "DIRECT_DEPENDENCIES" && "--entry-edges-only"} --input-file=${inputFile} --output-dir=${tmpDir} --timeout=${this.timeoutInSeconds}`;
      const execResult = await execNeverFail(cmd, ".");
      if (execResult.error)
        throw new Error("cocoa could not resolve class graph edges");
      for (const idx of JSON.parse(await readFile9(resolve3(tmpDir, "visited.json"), "utf-8"))) {
        visited.add(idx);
      }
      const edgesRecord = JSON.parse(await readFile9(resolve3(tmpDir, "edges.json"), "utf-8"));
      for (const [fromIdx, childrenRecord] of Object.entries(edgesRecord)) {
        for (const [toIdx, confidence] of Object.entries(childrenRecord)) {
          graph.addEdge(parseInt(fromIdx), parseInt(toIdx), confidence);
        }
      }
    });
  }
};

// dist/dotnet-reachability-analyzer.js
async function createDotnetResolverCallback(resources) {
  await Parser.init();
  const cSharpNodeResolver = await createTreeSitterResolver(resources.treeSitterCSharp, "tree-sitter-c_sharp.wasm", CSharpSourceResolver);
  return (file) => {
    const filext = extname5(file);
    switch (filext) {
      case ".cs":
        return cSharpNodeResolver;
      case ".fs":
        return null;
      case ".vb":
        return null;
    }
    return void 0;
  };
}
async function runDotnetDirectDependencyAnalysis(options, resources) {
  const resolverCb = await createDotnetResolverCallback(resources);
  const srcExcludeDirs = ["bin", "obj"];
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new DotnetResolutionContextProvider(), srcExcludeDirs),
    binResolutionManager: resources.cocoa ? new CocoaResolutionManager(resources.cocoa, options.timeoutInSeconds) : void 0,
    ...options
  });
  return await runner.runDirectDependencyAnalysis();
}
async function runDotnetReachabilityAnalysis(options, resources) {
  const resolverCb = await createDotnetResolverCallback(resources);
  const srcExcludeDirs = ["bin", "obj"];
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new DotnetResolutionContextProvider(), srcExcludeDirs),
    binResolutionManager: resources.cocoa ? new CocoaResolutionManager(resources.cocoa, options.timeoutInSeconds) : void 0,
    apps: options.apps,
    deps: options.deps,
    timeoutInSeconds: options.timeoutInSeconds
  });
  return await runner.runAnalysis(options.vulnerableClasses);
}

// dist/commands/dotnet-direct-dependency-analysis.js
var flags4 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  cocoa: { type: "string" },
  treeSitterCSharp: { type: "string" }
};
var runDotnetDirectDependencyAnalysisCmd = {
  description: "Run .NET direct dependency analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runDotnetDirectDependencyAnalysis [options]

    Options
      --input-file, -i        Input file for data and vulnerabilities (required)
      --output-file, -o       Output file for the results (required)
      --cocoa                 Path to cocoa dll (required)
      --tree-sitter-c-sharp   Path to tree-sitter-c-sharp dir

    Examples
      $ ${parentName} runDotnetDirectDependencyAnalysis -i input.json -o output.json --cocoa cocoa.dll
    `, {
      importMeta,
      argv,
      flags: flags4
    });
    const { inputFile, outputFile, cocoa, treeSitterCSharp } = cli.flags;
    const resources = { cocoa, treeSitterCSharp };
    const analysisOptions = JSON.parse(await readFile10(inputFile, "utf-8"));
    const result = await runDotnetDirectDependencyAnalysis(analysisOptions, resources);
    await writeFile5(outputFile, JSON.stringify({ result }));
  }
};

// dist/commands/dotnet-reachability-analysis.js
import { readFile as readFile11, writeFile as writeFile6 } from "node:fs/promises";
var flags5 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  cocoa: { type: "string" },
  treeSitterCSharp: { type: "string" }
};
var runDotnetReachabilityAnalysisCmd = {
  description: "Run .NET reachability analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runDotnetReachabilityAnalysis [options]

    Options
      --input-file, -i        Input file for data and vulnerabilities (required)
      --output-file, -o       Output file for the results (required)
      --cocoa                 Path to cocoa dll (required)
      --tree-sitter-c-sharp   Path to tree-sitter-c-sharp dir

    Examples
      $ ${parentName} runDotnetReachabilityAnalysis -i input.json -o output.json --cocoa cocoa.dll
    `, {
      importMeta,
      argv,
      flags: flags5
    });
    const { inputFile, outputFile, cocoa, treeSitterCSharp } = cli.flags;
    const resources = { cocoa, treeSitterCSharp };
    const analysisOptions = JSON.parse(await readFile11(inputFile, "utf-8"));
    const result = await runDotnetReachabilityAnalysis(analysisOptions, resources);
    await writeFile6(outputFile, JSON.stringify({ result }));
  }
};

// dist/commands/rust-direct-dependency-analysis.js
import { readFile as readFile12, writeFile as writeFile7 } from "node:fs/promises";

// dist/rust-reachability-analyzer.js
import { extname as extname7 } from "node:path";

// dist/class-graph/rust/module-utils.js
import { basename as basename5, dirname as dirname2, extname as extname6, sep } from "node:path";
function getFileModule(file, srcDir = "src") {
  if (!file)
    return "";
  const fileName = basename5(file, extname6(file));
  const dirName = dirname2(file);
  const relativePath = dirName.startsWith(srcDir) ? dirName.slice(srcDir.length + 1) : dirName;
  const dirSegments = relativePath === "" || relativePath === "." ? [] : relativePath.split(sep).filter(Boolean);
  const isLibOrMain = fileName === "lib" || fileName === "main";
  const isMod = fileName === "mod";
  if (isLibOrMain) {
    return "";
  } else if (isMod) {
    return dirSegments.join("::");
  } else {
    return [...dirSegments, fileName].join("::");
  }
}
function resolveModule(from, to, crates) {
  if (startsWithCrate(to, crates))
    return to;
  function resolveSegments(from2, to2) {
    const result = [...from2];
    for (const segment of to2) {
      if (segment === "") {
        return [];
      } else if (segment === "crate") {
        return [];
      } else if (segment === "super") {
        result.pop();
      } else if (segment === "self") {
      } else {
        result.push(segment);
      }
    }
    return result;
  }
  const fromSegments = from ? from.split("::").filter(Boolean) : [];
  const toSegments = to.split("::").filter(Boolean);
  return resolveSegments(fromSegments, toSegments).join("::");
}
function startsWithCrate(path2, crates) {
  if (!crates || !path2)
    return false;
  const maybeCrate = path2.split("::")[0];
  return maybeCrate ? crates.has(maybeCrate) : false;
}

// dist/class-graph/rust/rust-source-resolver.js
var RustSourceResolver = class extends AbstractTreeSitterSourceResolver {
  constructor(parser2, subtypeMap) {
    super(parser2, subtypeMap);
  }
  async parseDeclarationNodes(packageId, container, file, tree, ecosystemSpecificPackageInfo, graph) {
    if (ecosystemSpecificPackageInfo.type !== "RUST")
      return;
    const crate = ecosystemSpecificPackageInfo.crate;
    const fileModule = resolveModule(crate, getFileModule(file));
    const crateProps = { crate, fileModule };
    function getFullyQualifiedName(context) {
      return [...context.moduleParts, context.className].filter(Boolean).join("::");
    }
    const contextStack = [
      {
        moduleParts: fileModule.split("::"),
        importsMap: /* @__PURE__ */ new Map(),
        maybeReferences: []
      }
    ];
    const cursor = tree.walk();
    this.record(packageId, container, file, getFullyQualifiedName(contextStack[0]), cursor, graph, crateProps);
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext5(fileModule, oldContext, cursor, this.subtypeMap);
      switch (cursor.nodeType) {
        case "struct_item":
        case "enum_item":
        case "trait_item":
        case "union_item":
        case "mod_item": {
          this.record(packageId, container, file, getFullyQualifiedName(newContext), cursor, graph, crateProps);
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
  }
  async parseDefinitionNodes(packageId, container, file, tree, resolutionContext, ecosystemSpecificPackageInfo, graph) {
    if (resolutionContext.type !== "RUST")
      return;
    if (ecosystemSpecificPackageInfo.type !== "RUST")
      return;
    const rustResolutionContext = resolutionContext;
    const crate = ecosystemSpecificPackageInfo.crate;
    const fileModule = resolveModule(crate, getFileModule(file));
    const crateProps = { crate, fileModule };
    const contextStack = [
      {
        moduleParts: fileModule.split("::"),
        importsMap: resolutionContext.baseImportMap,
        maybeReferences: []
      }
    ];
    const cursor = tree.walk();
    let done = false;
    while (!done) {
      const oldContext = contextStack[contextStack.length - 1];
      const newContext = getUpdatedContext5(fileModule, oldContext, cursor, this.subtypeMap, resolutionContext.childMap, resolutionContext.crates);
      switch (cursor.nodeType) {
        case "impl_item": {
          const typeIdentifiers = [];
          if (cursorGoToChildOfFieldName(cursor, "type")) {
            collectTypeIdentifiers(cursor, typeIdentifiers);
            cursor.gotoParent();
          }
          if (cursorGoToChildOfType(cursor, "where_clause", this.subtypeMap)) {
            collectTypeIdentifiers(cursor, typeIdentifiers);
            cursor.gotoParent();
          }
          for (const typeIdentifier of typeIdentifiers) {
            const localPath = resolveModule(newContext.moduleParts.join("::"), typeIdentifier);
            if (rustResolutionContext.fqnMap.has(localPath)) {
              const resolvedFqn = resolveModule(newContext.moduleParts.join("::"), typeIdentifier);
              this.record(packageId, container, file, resolvedFqn, cursor, graph, crateProps);
            } else {
              for (const resolvedFqn of resolveImport(typeIdentifier, newContext.importsMap, "::")) {
                if (resolutionContext.fqnMap.has(resolvedFqn)) {
                  this.record(packageId, container, file, resolvedFqn, cursor, graph, crateProps);
                }
              }
            }
          }
          break;
        }
        case "use_declaration": {
          contextStack[contextStack.length - 1] = newContext;
          break;
        }
      }
      if (cursor.gotoFirstChild()) {
        contextStack.push(newContext);
        continue;
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || !contextStack.length) {
          done = true;
          break;
        }
      }
    }
  }
  async parseEdges(requestedNode, tree, resolutionContext, graph) {
    if (resolutionContext.type !== "RUST")
      return;
    for (const nodeId of this.containerToFileToNodeIds.get(requestedNode.container)?.get(requestedNode.file) ?? []) {
      const idx = resolutionContext.nodeIdToIndex.get(nodeId);
      if (idx === void 0 || resolutionContext.visited.has(idx))
        continue;
      resolutionContext.visited.add(idx);
      const resolveNode = resolutionContext.nodes[idx];
      this.getEdgesForNode(tree, resolveNode, resolutionContext, graph);
    }
  }
  getEdgesForNode(tree, fromNode, rustResolutionContext, graph) {
    const fromIdx = rustResolutionContext.nodeIdToIndex.get(fromNode.nodeId);
    if (fromIdx === void 0)
      return;
    function addReference(fromIdx2, toIdx, confidence) {
      graph.addEdge(fromIdx2, toIdx, confidence);
    }
    const moduleName = fromNode.fullyQualifiedName.split("::").slice(0, -1).join("::");
    const packageImportsMap = new Map(rustResolutionContext.baseImportMap);
    for (const child of rustResolutionContext.childMap.get(moduleName) ?? []) {
      packageImportsMap.set(child, [`${moduleName}::${child}`]);
    }
    const fileModule = fromNode.fileModule;
    for (const toIdx of rustResolutionContext.fqnMap.get(fileModule) ?? []) {
      if (fromIdx !== toIdx) {
        addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
      }
    }
    let initialContext = {
      moduleParts: [],
      importsMap: packageImportsMap,
      maybeReferences: []
    };
    const updateInitialContextCB = (cursor2) => {
      initialContext = getUpdatedContext5(fileModule, initialContext, cursor2, this.subtypeMap, rustResolutionContext.childMap, rustResolutionContext.crates);
    };
    const treeIndex = this.nodeIdToTreeIndes.get(fromNode.nodeId);
    if (treeIndex === void 0)
      return void 0;
    const cursor = walkTreeToIndex(tree, treeIndex, updateInitialContextCB);
    if (!cursor)
      return void 0;
    const contextStack = [initialContext];
    let done = false;
    let start2 = true;
    let startedBefore = false;
    while (!done) {
      let addReferencesToName2 = function(fromIdx2, fqnOrSimpleName) {
        function tryAdd(fqn) {
          let added = false;
          for (const toIdx of rustResolutionContext.fqnMap.get(fqn) ?? []) {
            addReference(fromIdx2, toIdx, TYPE_REFERENCE_CONFIDENCE);
            added = true;
          }
          return added;
        }
        if (!fqnOrSimpleName)
          return;
        for (const resolvedFqn of resolveImport(fqnOrSimpleName, currentContext.importsMap, "::")) {
          if (!tryAdd(resolvedFqn)) {
            const fqnParts = resolvedFqn.split("::");
            if (fqnParts.length > 1) {
              const parentFqn = fqnParts.slice(0, -1).join("::");
              tryAdd(parentFqn);
            }
          }
        }
      };
      var addReferencesToName = addReferencesToName2;
      start2 &&= !startedBefore;
      startedBefore = true;
      const currentContext = contextStack[contextStack.length - 1];
      for (const fqn of currentContext.maybeReferences) {
        for (const toIdx of rustResolutionContext.fqnMap.get(fqn) ?? []) {
          addReference(fromIdx, toIdx, TYPE_REFERENCE_CONFIDENCE);
        }
      }
      const newContext = getUpdatedContext5(fileModule, currentContext, cursor, this.subtypeMap, rustResolutionContext.childMap, rustResolutionContext.crates);
      switch (cursor.nodeType) {
        case "type_identifier": {
          addReferencesToName2(fromIdx, sanitizeName5(cursor));
          if (cursor.gotoFirstChild()) {
            contextStack.push(newContext);
            continue;
          }
          break;
        }
        case "scoped_identifier":
        case "scoped_type_identifier": {
          const baseModule = currentContext.moduleParts.join("::");
          const sanitizedName = sanitizeName5(cursor);
          addReferencesToName2(fromIdx, resolveModule(baseModule, sanitizedName, rustResolutionContext.crates));
          if (sanitizedName.startsWith("::")) {
            addReferencesToName2(fromIdx, resolveModule(baseModule, resolveModule("crate", sanitizedName)));
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(newContext);
            continue;
          }
          break;
        }
        case "call_expression": {
          if (cursorGoToChildOfFieldName(cursor, "function")) {
            addReferencesToName2(fromIdx, sanitizeName5(cursor));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(newContext);
            continue;
          }
          break;
        }
        case "field_expression": {
          if (cursorGoToChildOfFieldName(cursor, "value")) {
            addReferencesToName2(fromIdx, sanitizeName5(cursor));
            cursor.gotoParent();
          }
          if (cursor.gotoFirstChild()) {
            contextStack.push(newContext);
            continue;
          }
          break;
        }
        case "struct_item":
        case "enum_item":
        case "trait_item":
        case "union_item":
        case "impl_item":
        case "mod_item": {
          if (start2) {
            if (cursor.gotoFirstChild()) {
              contextStack.push(newContext);
            } else {
              done = true;
            }
            continue;
          }
          break;
        }
        case "use_declaration": {
          contextStack[contextStack.length - 1] = newContext;
          break;
        }
        default: {
          if (cursor.gotoFirstChild()) {
            contextStack.push(getUpdatedContext5(fileModule, currentContext, cursor, this.subtypeMap, rustResolutionContext.childMap, rustResolutionContext.crates));
            continue;
          }
          break;
        }
      }
      while (!cursor.gotoNextSibling()) {
        contextStack.pop();
        if (!cursor.gotoParent() || cursor.currentDescendantIndex === treeIndex || contextStack.length === 0) {
          done = true;
          break;
        }
      }
    }
  }
};
function getUpdatedContext5(fileModule, oldContext, cursor, subtypeMap, childMap, crates) {
  const newContext = { ...oldContext };
  const baseModule = resolveModule(fileModule, newContext.moduleParts.join("::"));
  function processUseClause(cursor2, base, isReexport) {
    newContext.importsMap = copyImportsMap(newContext.importsMap);
    switch (cursor2.nodeType) {
      case "self":
      case "identifier":
      case "scoped_identifier": {
        const path2 = base ? resolveModule(base, cursor2.nodeText) : cursor2.nodeText;
        const resolvedPath = resolveModule(baseModule, path2, crates);
        if (isReexport) {
          newContext.maybeReferences = newContext.maybeReferences.concat(resolvedPath);
        }
        const simpleName = resolvedPath.split("::").pop();
        if (simpleName) {
          if (!newContext.importsMap.has(simpleName)) {
            newContext.importsMap.set(simpleName, []);
          }
          for (const resolvedPath2 of resolveImport(path2, newContext.importsMap, "::")) {
            newContext.importsMap.get(simpleName).push(resolvedPath2);
          }
        }
        break;
      }
      case "use_wildcard": {
        const path2 = base ? resolveModule(base, cursor2.nodeText) : cursor2.nodeText;
        for (const partiallyResolvedPath of resolveImport(path2, newContext.importsMap, "::")) {
          const fullyResolvedPath = resolveModule(baseModule, partiallyResolvedPath, crates);
          childMap?.get(fullyResolvedPath)?.forEach((child) => {
            if (!newContext.importsMap.has(child)) {
              newContext.importsMap.set(child, []);
            }
            newContext.importsMap.get(child).push(`${fullyResolvedPath}.${child}`);
          });
          newContext.maybeReferences = newContext.maybeReferences.concat(fullyResolvedPath);
        }
        break;
      }
      case "use_as_clause": {
        const aliasedPath = cursorChildForFieldNameText(cursor2, "path");
        const alias = cursorChildForFieldNameText(cursor2, "alias");
        const path2 = base && aliasedPath ? resolveModule(base, aliasedPath) : aliasedPath;
        if (path2) {
          for (const partiallyResolvedPath of resolveImport(path2, newContext.importsMap, "::")) {
            const fullyResolvedPath = resolveModule(baseModule, partiallyResolvedPath);
            if (isReexport) {
              newContext.maybeReferences = newContext.maybeReferences.concat(fullyResolvedPath);
            }
            if (alias && alias !== "_") {
              if (!newContext.importsMap.has(alias)) {
                newContext.importsMap.set(alias, []);
              }
              newContext.importsMap.get(alias).push(fullyResolvedPath);
            }
          }
        }
        break;
      }
      case "use_list": {
        if (cursor2.gotoFirstChild()) {
          do {
            if (cursor2.nodeIsNamed) {
              processUseClause(cursor2, base, isReexport);
            }
          } while (cursor2.gotoNextSibling());
          cursor2.gotoParent();
        }
        break;
      }
      case "scoped_use_list": {
        const suffix = cursorChildForFieldNameText(cursor2, "path") ?? "";
        if (cursorGoToChildOfFieldName(cursor2, "list")) {
          const path2 = base ? resolveModule(base, suffix) : suffix;
          if (cursor2.gotoFirstChild()) {
            do {
              if (cursor2.nodeIsNamed) {
                processUseClause(cursor2, path2, isReexport);
              }
            } while (cursor2.gotoNextSibling());
            cursor2.gotoParent();
          }
          cursor2.gotoParent();
        }
        break;
      }
      default:
        break;
    }
  }
  switch (cursor.nodeType) {
    case "struct_item":
    case "enum_item":
    case "trait_item":
    case "union_item": {
      const itemName = cursorChildForFieldNameText(cursor, "name");
      if (itemName) {
        newContext.className = itemName;
      }
      break;
    }
    case "impl_item": {
      const itemName = cursorChildForFieldNameText(cursor, "type");
      if (itemName) {
        newContext.className = itemName;
      }
      break;
    }
    case "mod_item": {
      const modName = cursorChildForFieldNameText(cursor, "name");
      if (modName) {
        newContext.moduleParts = newContext.moduleParts.concat(modName);
      }
      break;
    }
    case "use_declaration": {
      const isReexport = cursorHasChildOfType(cursor, "pub", subtypeMap);
      if (cursorGoToChildOfFieldName(cursor, "argument")) {
        processUseClause(cursor, void 0, isReexport);
        cursor.gotoParent();
      }
      break;
    }
  }
  return newContext;
}
function sanitizeName5(cursor) {
  switch (cursor.nodeType) {
    case "identifier":
    case "type_identifier": {
      return cursor.nodeText;
    }
    case "scoped_identifier":
    case "scoped_type_identifier": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName5(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "bounded_type": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName5(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        return parts2.join("");
      }
      return cursor.nodeText;
    }
    case "generic_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const baseType = sanitizeName5(cursor);
        cursor.gotoParent();
        return baseType;
      }
      return cursor.nodeText;
    }
    case "array_type": {
      if (cursorGoToChildOfFieldName(cursor, "element")) {
        const elementType = sanitizeName5(cursor);
        cursor.gotoParent();
        return elementType;
      }
      return cursor.nodeText;
    }
    case "reference_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const referencedType = sanitizeName5(cursor);
        cursor.gotoParent();
        return referencedType;
      }
      return cursor.nodeText;
    }
    case "pointer_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        const pointedType = sanitizeName5(cursor);
        cursor.gotoParent();
        return pointedType;
      }
      return cursor.nodeText;
    }
    // Handle primitive types as-is
    case "primitive_type":
      return cursor.nodeText;
    default:
      return cursor.nodeText;
  }
}
function collectTypeIdentifiers(cursor, acc = []) {
  switch (cursor.nodeType) {
    case "primitive_type": {
      acc.push(cursor.nodeText);
      break;
    }
    case "type_identifier": {
      acc.push(cursor.nodeText);
      break;
    }
    case "scoped_type_identifier": {
      if (cursor.gotoFirstChild()) {
        const parts2 = [];
        do {
          parts2.push(sanitizeName5(cursor));
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
        acc.push(parts2.join(""));
      }
      break;
    }
    case "generic_type": {
      if (cursorGoToChildOfFieldName(cursor, "type")) {
        collectTypeIdentifiers(cursor, acc);
        cursor.gotoParent();
      }
      break;
    }
    case "macro_invocation":
    case "metavariable":
    case "function_type":
    case "type_parameters": {
      break;
    }
    default: {
      if (cursor.gotoFirstChild()) {
        do {
          collectTypeIdentifiers(cursor, acc);
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
      }
    }
  }
  return acc;
}

// dist/class-graph/rust/constants.js
var STD_AUTO_IMPORTED = [
  "alloc::borrow::ToOwned",
  "alloc::boxed::Box",
  "alloc::string::String",
  "alloc::string::ToString",
  "alloc::vec::Vec",
  "core::clone::Clone",
  "core::cmp::Eq",
  "core::cmp::Ord",
  "core::cmp::PartialEq",
  "core::cmp::PartialOrd",
  "core::convert::AsMut",
  "core::convert::AsRef",
  "core::convert::From",
  "core::convert::Into",
  "core::default::Default",
  "core::fmt::Debug",
  "core::hash::Hash",
  "core::iter::traits::collect::Extend",
  "core::iter::traits::collect::FromIterator",
  "core::iter::traits::collect::IntoIterator",
  "core::iter::traits::double_ended::DoubleEndedIterator",
  "core::iter::traits::exact_size::ExactSizeIterator",
  "core::iter::traits::iterator::Iterator",
  "core::marker::Copy",
  "core::marker::Send",
  "core::marker::Sized",
  "core::marker::Sync",
  "core::marker::Unpin",
  "core::ops::async_function::AsyncFn",
  "core::ops::async_function::AsyncFnMut",
  "core::ops::async_function::AsyncFnOnce",
  "core::ops::drop::Drop",
  "core::ops::function::Fn",
  "core::ops::function::FnMut",
  "core::ops::function::FnOnce",
  "core::option::Option",
  "core::result::Result"
];
var STD_TYPES = [
  "alloc::alloc::Global",
  "alloc::borrow::Cow",
  "alloc::borrow::ToOwned",
  "alloc::boxed::Box",
  "alloc::boxed::Box::AllocBox",
  "alloc::boxed::convert::from::StringError",
  "alloc::boxed::thin::ThinBox",
  "alloc::boxed::thin::drop::DropGuard",
  "alloc::bstr::ByteString",
  "alloc::collections::BTreeMap::BTreeMapAlloc",
  "alloc::collections::BTreeSet::BTreeSetAlloc",
  "alloc::collections::BinaryHeap::BinaryHeapAlloc",
  "alloc::collections::LinkedList::LinkedListAlloc",
  "alloc::collections::TryReserveError",
  "alloc::collections::TryReserveErrorKind",
  "alloc::collections::VecDeque::VecDequeAlloc",
  "alloc::collections::binary_heap::BinaryHeap",
  "alloc::collections::binary_heap::Drain",
  "alloc::collections::binary_heap::DrainSorted",
  "alloc::collections::binary_heap::Hole",
  "alloc::collections::binary_heap::IntoIter",
  "alloc::collections::binary_heap::IntoIterSorted",
  "alloc::collections::binary_heap::Iter",
  "alloc::collections::binary_heap::PeekMut",
  "alloc::collections::binary_heap::RebuildOnDrop",
  "alloc::collections::binary_heap::drop::DropGuard",
  "alloc::collections::btree::append::MergeIter",
  "alloc::collections::btree::borrow::DormantMutRef",
  "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter",
  "alloc::collections::btree::map::BTreeMap",
  "alloc::collections::btree::map::Cursor",
  "alloc::collections::btree::map::CursorMut",
  "alloc::collections::btree::map::CursorMutKey",
  "alloc::collections::btree::map::ExtractIf",
  "alloc::collections::btree::map::IntoIter",
  "alloc::collections::btree::map::IntoKeys",
  "alloc::collections::btree::map::IntoValues",
  "alloc::collections::btree::map::Iter",
  "alloc::collections::btree::map::IterMut",
  "alloc::collections::btree::map::Keys",
  "alloc::collections::btree::map::Range",
  "alloc::collections::btree::map::RangeMut",
  "alloc::collections::btree::map::UnorderedKeyError",
  "alloc::collections::btree::map::Values",
  "alloc::collections::btree::map::ValuesMut",
  "alloc::collections::btree::map::drop::DropGuard",
  "alloc::collections::btree::map::entry::Entry",
  "alloc::collections::btree::map::entry::OccupiedEntry",
  "alloc::collections::btree::map::entry::OccupiedError",
  "alloc::collections::btree::map::entry::VacantEntry",
  "alloc::collections::btree::mem::replace::PanicGuard",
  "alloc::collections::btree::merge_iter::MergeIterInner",
  "alloc::collections::btree::merge_iter::Peeked",
  "alloc::collections::btree::navigate::LazyLeafHandle",
  "alloc::collections::btree::navigate::LazyLeafRange",
  "alloc::collections::btree::navigate::LeafRange",
  "alloc::collections::btree::node::Handle",
  "alloc::collections::btree::node::NodeRef",
  "alloc::collections::btree::node::drop_key_val::Dropper",
  "alloc::collections::btree::node::marker::Dying",
  "alloc::collections::btree::node::marker::Immut",
  "alloc::collections::btree::node::marker::LeafOrInternal",
  "alloc::collections::btree::node::marker::Mut",
  "alloc::collections::btree::node::marker::Owned",
  "alloc::collections::btree::node::marker::ValMut",
  "alloc::collections::btree::set::BTreeSet",
  "alloc::collections::btree::set::Cursor",
  "alloc::collections::btree::set::CursorMut",
  "alloc::collections::btree::set::CursorMutKey",
  "alloc::collections::btree::set::Difference",
  "alloc::collections::btree::set::DifferenceInner",
  "alloc::collections::btree::set::ExtractIf",
  "alloc::collections::btree::set::Intersection",
  "alloc::collections::btree::set::IntersectionInner",
  "alloc::collections::btree::set::IntoIter",
  "alloc::collections::btree::set::Iter",
  "alloc::collections::btree::set::Range",
  "alloc::collections::btree::set::SymmetricDifference",
  "alloc::collections::btree::set::Union",
  "alloc::collections::btree::set::entry::Entry",
  "alloc::collections::btree::set::entry::OccupiedEntry",
  "alloc::collections::btree::set::entry::VacantEntry",
  "alloc::collections::btree::set_val::SetValZST",
  "alloc::collections::linked_list::Cursor",
  "alloc::collections::linked_list::CursorMut",
  "alloc::collections::linked_list::ExtractIf",
  "alloc::collections::linked_list::IntoIter",
  "alloc::collections::linked_list::Iter",
  "alloc::collections::linked_list::IterMut",
  "alloc::collections::linked_list::LinkedList",
  "alloc::collections::linked_list::Node",
  "alloc::collections::linked_list::drop::DropGuard",
  "alloc::collections::vec_deque::VecDeque",
  "alloc::collections::vec_deque::drain::Drain",
  "alloc::collections::vec_deque::drain::drop::DropGuard",
  "alloc::collections::vec_deque::drop::Dropper",
  "alloc::collections::vec_deque::into_iter::IntoIter",
  "alloc::collections::vec_deque::into_iter::try_fold::Guard",
  "alloc::collections::vec_deque::into_iter::try_rfold::Guard",
  "alloc::collections::vec_deque::iter::Iter",
  "alloc::collections::vec_deque::iter_mut::IterMut",
  "alloc::collections::vec_deque::shrink_to::Guard",
  "alloc::collections::vec_deque::truncate::Dropper",
  "alloc::collections::vec_deque::truncate_front::Dropper",
  "alloc::collections::vec_deque::write_iter_wrapping::Guard",
  "alloc::ffi::c_str::CString",
  "alloc::ffi::c_str::FromBytesWithNulErrorKind",
  "alloc::ffi::c_str::FromVecWithNulError",
  "alloc::ffi::c_str::IntoStringError",
  "alloc::ffi::c_str::NulError",
  "alloc::raw_vec::RawVec",
  "alloc::rc::Rc",
  "alloc::rc::Rc::RcAlloc",
  "alloc::rc::RcInner",
  "alloc::rc::UniqueRc",
  "alloc::rc::UniqueRcUninit",
  "alloc::rc::Weak",
  "alloc::rc::from_iter_exact::Guard",
  "alloc::slice::Concat",
  "alloc::slice::Join",
  "alloc::slice::to_vec_in::to_vec::DropGuard",
  "alloc::string::Drain",
  "alloc::string::FromUtf16Error",
  "alloc::string::FromUtf8Error",
  "alloc::string::IntoChars",
  "alloc::string::String",
  "alloc::string::String::AllocString",
  "alloc::string::ToString",
  "alloc::string::retain::SetLenOnDrop",
  "alloc::sync::Arc",
  "alloc::sync::Arc::ArcAlloc",
  "alloc::sync::ArcInner",
  "alloc::sync::UniqueArc",
  "alloc::sync::UniqueArcUninit",
  "alloc::sync::Weak",
  "alloc::sync::from_iter_exact::Guard",
  "alloc::task::LocalWake",
  "alloc::task::Wake",
  "alloc::vec::Vec",
  "alloc::vec::Vec::AllocVec",
  "alloc::vec::dedup_by::FillGapOnDrop",
  "alloc::vec::drain::Drain",
  "alloc::vec::drain::drop::DropGuard",
  "alloc::vec::extract_if::ExtractIf",
  "alloc::vec::in_place_drop::InPlaceDrop",
  "alloc::vec::in_place_drop::InPlaceDstDataSrcBufDrop",
  "alloc::vec::into_iter::IntoIter",
  "alloc::vec::into_iter::drop::DropGuard",
  "alloc::vec::peek_mut::PeekMut",
  "alloc::vec::retain_mut::BackshiftOnDrop",
  "alloc::vec::set_len_on_drop::SetLenOnDrop",
  "alloc::vec::splice::Splice",
  "core::alloc::AllocError",
  "core::alloc::Allocator",
  "core::alloc::global::GlobalAlloc",
  "core::alloc::layout::Layout",
  "core::alloc::layout::LayoutError",
  "core::any::Any",
  "core::any::TypeId",
  "core::array::Guard",
  "core::array::TryFromSliceError",
  "core::array::drain::Drain",
  "core::array::iter::IntoIter",
  "core::array::iter::iter_inner::PolymorphicIter",
  "core::ascii::EscapeDefault",
  "core::ascii::ascii_char::AsciiChar",
  "core::asserting::Capture",
  "core::asserting::TryCaptureWithDebug",
  "core::asserting::TryCaptureWithoutDebug",
  "core::async_iter::async_iter::AsyncIterator",
  "core::async_iter::async_iter::IntoAsyncIterator",
  "core::async_iter::from_iter::FromIter",
  "core::borrow::Borrow",
  "core::borrow::BorrowMut",
  "core::bstr::ByteStr",
  "core::cell::BorrowError",
  "core::cell::BorrowMutError",
  "core::cell::BorrowRef",
  "core::cell::BorrowRefMut",
  "core::cell::Cell",
  "core::cell::Ref",
  "core::cell::RefCell",
  "core::cell::RefMut",
  "core::cell::SyncUnsafeCell",
  "core::cell::UnsafeCell",
  "core::cell::lazy::LazyCell",
  "core::cell::lazy::force_mut::really_init_mut::PoisonOnPanic",
  "core::cell::once::OnceCell",
  "core::char::CaseMappingIter",
  "core::char::EscapeDebug",
  "core::char::EscapeDefault",
  "core::char::EscapeUnicode",
  "core::char::ToLowercase",
  "core::char::ToUppercase",
  "core::char::TryFromCharError",
  "core::char::convert::CharErrorKind",
  "core::char::convert::CharTryFromError",
  "core::char::convert::ParseCharError",
  "core::char::decode::DecodeUtf16",
  "core::char::decode::DecodeUtf16Error",
  "core::clone::Clone",
  "core::clone::CloneToUninit",
  "core::clone::UseCloned",
  "core::clone::uninit::InitializingSlice",
  "core::cmp::Eq",
  "core::cmp::Ord",
  "core::cmp::Ordering",
  "core::cmp::PartialEq",
  "core::cmp::PartialOrd",
  "core::cmp::Reverse",
  "core::convert::AsMut",
  "core::convert::AsRef",
  "core::convert::From",
  "core::convert::Infallible",
  "core::convert::Into",
  "core::convert::TryFrom",
  "core::convert::TryInto",
  "core::convert::num::FloatToInt",
  "core::convert::num::private::Sealed",
  "core::core_arch::aarch64::neon::float64x1_t",
  "core::core_arch::aarch64::neon::float64x1x2_t",
  "core::core_arch::aarch64::neon::float64x1x3_t",
  "core::core_arch::aarch64::neon::float64x1x4_t",
  "core::core_arch::aarch64::neon::float64x2_t",
  "core::core_arch::aarch64::neon::float64x2x2_t",
  "core::core_arch::aarch64::neon::float64x2x3_t",
  "core::core_arch::aarch64::neon::float64x2x4_t",
  "core::core_arch::aarch64::neon::splat::JustOne",
  "core::core_arch::arm_shared::neon::float16x4_t",
  "core::core_arch::arm_shared::neon::float16x4x2_t",
  "core::core_arch::arm_shared::neon::float16x4x3_t",
  "core::core_arch::arm_shared::neon::float16x4x4_t",
  "core::core_arch::arm_shared::neon::float16x8_t",
  "core::core_arch::arm_shared::neon::float16x8x2_t",
  "core::core_arch::arm_shared::neon::float16x8x3_t",
  "core::core_arch::arm_shared::neon::float16x8x4_t",
  "core::core_arch::arm_shared::neon::float32x2_t",
  "core::core_arch::arm_shared::neon::float32x2x2_t",
  "core::core_arch::arm_shared::neon::float32x2x3_t",
  "core::core_arch::arm_shared::neon::float32x2x4_t",
  "core::core_arch::arm_shared::neon::float32x4_t",
  "core::core_arch::arm_shared::neon::float32x4x2_t",
  "core::core_arch::arm_shared::neon::float32x4x3_t",
  "core::core_arch::arm_shared::neon::float32x4x4_t",
  "core::core_arch::arm_shared::neon::int16x4_t",
  "core::core_arch::arm_shared::neon::int16x4x2_t",
  "core::core_arch::arm_shared::neon::int16x4x3_t",
  "core::core_arch::arm_shared::neon::int16x4x4_t",
  "core::core_arch::arm_shared::neon::int16x8_t",
  "core::core_arch::arm_shared::neon::int16x8x2_t",
  "core::core_arch::arm_shared::neon::int16x8x3_t",
  "core::core_arch::arm_shared::neon::int16x8x4_t",
  "core::core_arch::arm_shared::neon::int32x2_t",
  "core::core_arch::arm_shared::neon::int32x2x2_t",
  "core::core_arch::arm_shared::neon::int32x2x3_t",
  "core::core_arch::arm_shared::neon::int32x2x4_t",
  "core::core_arch::arm_shared::neon::int32x4_t",
  "core::core_arch::arm_shared::neon::int32x4x2_t",
  "core::core_arch::arm_shared::neon::int32x4x3_t",
  "core::core_arch::arm_shared::neon::int32x4x4_t",
  "core::core_arch::arm_shared::neon::int64x1_t",
  "core::core_arch::arm_shared::neon::int64x1x2_t",
  "core::core_arch::arm_shared::neon::int64x1x3_t",
  "core::core_arch::arm_shared::neon::int64x1x4_t",
  "core::core_arch::arm_shared::neon::int64x2_t",
  "core::core_arch::arm_shared::neon::int64x2x2_t",
  "core::core_arch::arm_shared::neon::int64x2x3_t",
  "core::core_arch::arm_shared::neon::int64x2x4_t",
  "core::core_arch::arm_shared::neon::int8x16_t",
  "core::core_arch::arm_shared::neon::int8x16x2_t",
  "core::core_arch::arm_shared::neon::int8x16x3_t",
  "core::core_arch::arm_shared::neon::int8x16x4_t",
  "core::core_arch::arm_shared::neon::int8x8_t",
  "core::core_arch::arm_shared::neon::int8x8x2_t",
  "core::core_arch::arm_shared::neon::int8x8x3_t",
  "core::core_arch::arm_shared::neon::int8x8x4_t",
  "core::core_arch::arm_shared::neon::poly16x4_t",
  "core::core_arch::arm_shared::neon::poly16x4x2_t",
  "core::core_arch::arm_shared::neon::poly16x4x3_t",
  "core::core_arch::arm_shared::neon::poly16x4x4_t",
  "core::core_arch::arm_shared::neon::poly16x8_t",
  "core::core_arch::arm_shared::neon::poly16x8x2_t",
  "core::core_arch::arm_shared::neon::poly16x8x3_t",
  "core::core_arch::arm_shared::neon::poly16x8x4_t",
  "core::core_arch::arm_shared::neon::poly64x1_t",
  "core::core_arch::arm_shared::neon::poly64x1x2_t",
  "core::core_arch::arm_shared::neon::poly64x1x3_t",
  "core::core_arch::arm_shared::neon::poly64x1x4_t",
  "core::core_arch::arm_shared::neon::poly64x2_t",
  "core::core_arch::arm_shared::neon::poly64x2x2_t",
  "core::core_arch::arm_shared::neon::poly64x2x3_t",
  "core::core_arch::arm_shared::neon::poly64x2x4_t",
  "core::core_arch::arm_shared::neon::poly8x16_t",
  "core::core_arch::arm_shared::neon::poly8x16x2_t",
  "core::core_arch::arm_shared::neon::poly8x16x3_t",
  "core::core_arch::arm_shared::neon::poly8x16x4_t",
  "core::core_arch::arm_shared::neon::poly8x8_t",
  "core::core_arch::arm_shared::neon::poly8x8x2_t",
  "core::core_arch::arm_shared::neon::poly8x8x3_t",
  "core::core_arch::arm_shared::neon::poly8x8x4_t",
  "core::core_arch::arm_shared::neon::splat::JustOne",
  "core::core_arch::arm_shared::neon::uint16x4_t",
  "core::core_arch::arm_shared::neon::uint16x4x2_t",
  "core::core_arch::arm_shared::neon::uint16x4x3_t",
  "core::core_arch::arm_shared::neon::uint16x4x4_t",
  "core::core_arch::arm_shared::neon::uint16x8_t",
  "core::core_arch::arm_shared::neon::uint16x8x2_t",
  "core::core_arch::arm_shared::neon::uint16x8x3_t",
  "core::core_arch::arm_shared::neon::uint16x8x4_t",
  "core::core_arch::arm_shared::neon::uint32x2_t",
  "core::core_arch::arm_shared::neon::uint32x2x2_t",
  "core::core_arch::arm_shared::neon::uint32x2x3_t",
  "core::core_arch::arm_shared::neon::uint32x2x4_t",
  "core::core_arch::arm_shared::neon::uint32x4_t",
  "core::core_arch::arm_shared::neon::uint32x4x2_t",
  "core::core_arch::arm_shared::neon::uint32x4x3_t",
  "core::core_arch::arm_shared::neon::uint32x4x4_t",
  "core::core_arch::arm_shared::neon::uint64x1_t",
  "core::core_arch::arm_shared::neon::uint64x1x2_t",
  "core::core_arch::arm_shared::neon::uint64x1x3_t",
  "core::core_arch::arm_shared::neon::uint64x1x4_t",
  "core::core_arch::arm_shared::neon::uint64x2_t",
  "core::core_arch::arm_shared::neon::uint64x2x2_t",
  "core::core_arch::arm_shared::neon::uint64x2x3_t",
  "core::core_arch::arm_shared::neon::uint64x2x4_t",
  "core::core_arch::arm_shared::neon::uint8x16_t",
  "core::core_arch::arm_shared::neon::uint8x16x2_t",
  "core::core_arch::arm_shared::neon::uint8x16x3_t",
  "core::core_arch::arm_shared::neon::uint8x16x4_t",
  "core::core_arch::arm_shared::neon::uint8x8_t",
  "core::core_arch::arm_shared::neon::uint8x8x2_t",
  "core::core_arch::arm_shared::neon::uint8x8x3_t",
  "core::core_arch::arm_shared::neon::uint8x8x4_t",
  "core::core_arch::simd::f16x16",
  "core::core_arch::simd::f16x32",
  "core::core_arch::simd::f16x4",
  "core::core_arch::simd::f16x8",
  "core::core_arch::simd::f32x16",
  "core::core_arch::simd::f32x2",
  "core::core_arch::simd::f32x4",
  "core::core_arch::simd::f32x8",
  "core::core_arch::simd::f64x1",
  "core::core_arch::simd::f64x2",
  "core::core_arch::simd::f64x4",
  "core::core_arch::simd::f64x8",
  "core::core_arch::simd::i16x16",
  "core::core_arch::simd::i16x2",
  "core::core_arch::simd::i16x32",
  "core::core_arch::simd::i16x4",
  "core::core_arch::simd::i16x8",
  "core::core_arch::simd::i32x16",
  "core::core_arch::simd::i32x2",
  "core::core_arch::simd::i32x32",
  "core::core_arch::simd::i32x4",
  "core::core_arch::simd::i32x8",
  "core::core_arch::simd::i64x1",
  "core::core_arch::simd::i64x2",
  "core::core_arch::simd::i64x4",
  "core::core_arch::simd::i64x8",
  "core::core_arch::simd::i8x16",
  "core::core_arch::simd::i8x2",
  "core::core_arch::simd::i8x32",
  "core::core_arch::simd::i8x4",
  "core::core_arch::simd::i8x64",
  "core::core_arch::simd::i8x8",
  "core::core_arch::simd::m16x16",
  "core::core_arch::simd::m16x8",
  "core::core_arch::simd::m32x4",
  "core::core_arch::simd::m32x8",
  "core::core_arch::simd::m64x2",
  "core::core_arch::simd::m8x16",
  "core::core_arch::simd::m8x32",
  "core::core_arch::simd::splat::JustOne",
  "core::core_arch::simd::u16x16",
  "core::core_arch::simd::u16x2",
  "core::core_arch::simd::u16x32",
  "core::core_arch::simd::u16x4",
  "core::core_arch::simd::u16x64",
  "core::core_arch::simd::u16x8",
  "core::core_arch::simd::u32x16",
  "core::core_arch::simd::u32x2",
  "core::core_arch::simd::u32x32",
  "core::core_arch::simd::u32x4",
  "core::core_arch::simd::u32x8",
  "core::core_arch::simd::u64x1",
  "core::core_arch::simd::u64x2",
  "core::core_arch::simd::u64x4",
  "core::core_arch::simd::u64x8",
  "core::core_arch::simd::u8x16",
  "core::core_arch::simd::u8x2",
  "core::core_arch::simd::u8x32",
  "core::core_arch::simd::u8x4",
  "core::core_arch::simd::u8x64",
  "core::core_arch::simd::u8x8",
  "core::core_simd::cast::SimdCast",
  "core::core_simd::cast::sealed::Sealed",
  "core::core_simd::lane_count::LaneCount",
  "core::core_simd::lane_count::SupportedLaneCount",
  "core::core_simd::lane_count::sealed::Sealed",
  "core::core_simd::masks::Mask",
  "core::core_simd::masks::MaskElement",
  "core::core_simd::masks::mask_impl::Mask",
  "core::core_simd::masks::sealed::Sealed",
  "core::core_simd::simd::cmp::eq::SimdPartialEq",
  "core::core_simd::simd::cmp::ord::SimdOrd",
  "core::core_simd::simd::cmp::ord::SimdPartialOrd",
  "core::core_simd::simd::num::float::SimdFloat",
  "core::core_simd::simd::num::int::SimdInt",
  "core::core_simd::simd::num::sealed::Sealed",
  "core::core_simd::simd::num::uint::SimdUint",
  "core::core_simd::simd::ptr::const_ptr::SimdConstPtr",
  "core::core_simd::simd::ptr::mut_ptr::SimdMutPtr",
  "core::core_simd::simd::ptr::sealed::Sealed",
  "core::core_simd::swizzle::deinterleave::Even",
  "core::core_simd::swizzle::deinterleave::Odd",
  "core::core_simd::swizzle::extract::Extract",
  "core::core_simd::swizzle::interleave::Hi",
  "core::core_simd::swizzle::interleave::Lo",
  "core::core_simd::swizzle::resize::Resize",
  "core::core_simd::swizzle::reverse::Reverse",
  "core::core_simd::swizzle::rotate_elements_left::Rotate",
  "core::core_simd::swizzle::rotate_elements_right::Rotate",
  "core::core_simd::swizzle::shift_elements_left::Shift",
  "core::core_simd::swizzle::shift_elements_right::Shift",
  "core::core_simd::to_bytes::ToBytes",
  "core::core_simd::to_bytes::sealed::Sealed",
  "core::core_simd::vector::Simd",
  "core::core_simd::vector::SimdElement",
  "core::core_simd::vector::sealed::Sealed",
  "core::core_simd::vector::splat::splat_rt::Splat",
  "core::default::Default",
  "core::error::Error",
  "core::error::Request",
  "core::error::Source",
  "core::error::private::Internal",
  "core::error::tags::MaybeSizedValue",
  "core::error::tags::Ref",
  "core::error::tags::Value",
  "core::escape::AlwaysEscaped",
  "core::escape::EscapeIterInner",
  "core::escape::MaybeEscaped",
  "core::escape::MaybeEscapedCharacter",
  "core::ffi::c_str::Bytes",
  "core::ffi::c_str::CStr",
  "core::ffi::c_str::FromBytesUntilNulError",
  "core::ffi::c_str::FromBytesWithNulError",
  "core::ffi::c_void",
  "core::ffi::va_list::VaArgSafe",
  "core::ffi::va_list::VaList",
  "core::ffi::va_list::VaListImpl",
  "core::ffi::va_list::sealed::Sealed",
  "core::fmt::Alignment",
  "core::fmt::Arguments",
  "core::fmt::Binary",
  "core::fmt::Debug",
  "core::fmt::DebugAsHex",
  "core::fmt::Display",
  "core::fmt::Error",
  "core::fmt::Formatter",
  "core::fmt::FormattingOptions",
  "core::fmt::LowerExp",
  "core::fmt::LowerHex",
  "core::fmt::Octal",
  "core::fmt::Pointer",
  "core::fmt::Sign",
  "core::fmt::UpperExp",
  "core::fmt::UpperHex",
  "core::fmt::Write",
  "core::fmt::builders::FromFn",
  "core::fmt::builders::PadAdapter",
  "core::fmt::builders::PadAdapterState",
  "core::fmt::num::Binary",
  "core::fmt::num::LowerHex",
  "core::fmt::num::Octal",
  "core::fmt::num::UpperHex",
  "core::fmt::num_buffer::NumBuffer",
  "core::fmt::num_buffer::NumBufferTrait",
  "core::fmt::rt::Argument",
  "core::fmt::rt::ArgumentType",
  "core::fmt::rt::Count",
  "core::fmt::rt::Placeholder",
  "core::future::ResumeTy",
  "core::future::future::Future",
  "core::future::into_future::IntoFuture",
  "core::future::join::MaybeDone",
  "core::future::pending::Pending",
  "core::future::poll_fn::PollFn",
  "core::future::ready::Ready",
  "core::hash::BuildHasher",
  "core::hash::BuildHasherDefault",
  "core::hash::Hash",
  "core::hash::Hasher",
  "core::hash::sip::Hasher",
  "core::hash::sip::Sip13Rounds",
  "core::hash::sip::Sip24Rounds",
  "core::hash::sip::SipHasher",
  "core::hash::sip::SipHasher13",
  "core::hash::sip::SipHasher24",
  "core::hash::sip::State",
  "core::intrinsics::AtomicOrdering",
  "core::intrinsics::fallback::CarryingMulAdd",
  "core::intrinsics::fallback::DisjointBitOr",
  "core::io::borrowed_buf::BorrowedBuf",
  "core::io::borrowed_buf::BorrowedCursor",
  "core::iter::adapters::GenericShunt",
  "core::iter::adapters::array_chunks::ArrayChunks",
  "core::iter::adapters::by_ref_sized::ByRefSized",
  "core::iter::adapters::chain::Chain",
  "core::iter::adapters::cloned::Cloned",
  "core::iter::adapters::copied::Copied",
  "core::iter::adapters::cycle::Cycle",
  "core::iter::adapters::enumerate::Enumerate",
  "core::iter::adapters::filter::Filter",
  "core::iter::adapters::filter_map::FilterMap",
  "core::iter::adapters::filter_map::next_chunk::Guard",
  "core::iter::adapters::flatten::FlatMap",
  "core::iter::adapters::flatten::Flatten",
  "core::iter::adapters::flatten::FlattenCompat",
  "core::iter::adapters::fuse::Fuse",
  "core::iter::adapters::inspect::Inspect",
  "core::iter::adapters::intersperse::Intersperse",
  "core::iter::adapters::intersperse::IntersperseWith",
  "core::iter::adapters::map::Map",
  "core::iter::adapters::map_while::MapWhile",
  "core::iter::adapters::map_windows::Buffer",
  "core::iter::adapters::map_windows::MapWindows",
  "core::iter::adapters::map_windows::MapWindowsInner",
  "core::iter::adapters::peekable::Peekable",
  "core::iter::adapters::rev::Rev",
  "core::iter::adapters::scan::Scan",
  "core::iter::adapters::skip::Skip",
  "core::iter::adapters::skip_while::SkipWhile",
  "core::iter::adapters::step_by::StepBy",
  "core::iter::adapters::take::Take",
  "core::iter::adapters::take_while::TakeWhile",
  "core::iter::adapters::zip::TrustedRandomAccess",
  "core::iter::adapters::zip::TrustedRandomAccessNoCoerce",
  "core::iter::adapters::zip::Zip",
  "core::iter::range::Step",
  "core::iter::sources::empty::Empty",
  "core::iter::sources::from_coroutine::FromCoroutine",
  "core::iter::sources::from_fn::FromFn",
  "core::iter::sources::once::Once",
  "core::iter::sources::once_with::OnceWith",
  "core::iter::sources::repeat::Repeat",
  "core::iter::sources::repeat_n::RepeatN",
  "core::iter::sources::repeat_n::RepeatNInner",
  "core::iter::sources::repeat_with::RepeatWith",
  "core::iter::sources::successors::Successors",
  "core::iter::traits::accum::Product",
  "core::iter::traits::accum::Sum",
  "core::iter::traits::collect::Extend",
  "core::iter::traits::collect::FromIterator",
  "core::iter::traits::collect::IntoIterator",
  "core::iter::traits::double_ended::DoubleEndedIterator",
  "core::iter::traits::exact_size::ExactSizeIterator",
  "core::iter::traits::iterator::Iterator",
  "core::iter::traits::marker::FusedIterator",
  "core::iter::traits::marker::TrustedLen",
  "core::iter::traits::marker::TrustedStep",
  "core::marker::ConstParamTy_",
  "core::marker::Copy",
  "core::marker::FnPtr",
  "core::marker::Freeze",
  "core::marker::MetaSized",
  "core::marker::PhantomData",
  "core::marker::PhantomPinned",
  "core::marker::Send",
  "core::marker::Sized",
  "core::marker::StructuralPartialEq",
  "core::marker::Sync",
  "core::marker::Tuple",
  "core::marker::Unpin",
  "core::marker::Unsize",
  "core::marker::UnsizedConstParamTy",
  "core::marker::variance::PhantomContravariant",
  "core::marker::variance::PhantomContravariantLifetime",
  "core::marker::variance::PhantomCovariant",
  "core::marker::variance::PhantomCovariantLifetime",
  "core::marker::variance::PhantomInvariant",
  "core::marker::variance::PhantomInvariantLifetime",
  "core::marker::variance::Variance",
  "core::marker::variance::sealed::Sealed",
  "core::mem::Discriminant",
  "core::mem::drop_guard::DropGuard",
  "core::mem::manually_drop::ManuallyDrop",
  "core::mem::maybe_uninit::Guard",
  "core::mem::maybe_uninit::MaybeUninit",
  "core::mem::transmutability::Assume",
  "core::net::display_buffer::DisplayBuffer",
  "core::net::ip_addr::IpAddr",
  "core::net::ip_addr::Ipv4Addr",
  "core::net::ip_addr::Ipv6Addr",
  "core::net::ip_addr::Ipv6MulticastScope",
  "core::net::ip_addr::fmt::Span",
  "core::net::parser::AddrKind",
  "core::net::parser::AddrParseError",
  "core::net::socket_addr::SocketAddr",
  "core::net::socket_addr::SocketAddrV4",
  "core::net::socket_addr::SocketAddrV6",
  "core::num::FpCategory",
  "core::num::bignum::Big32x40",
  "core::num::bignum::tests::Big8x3",
  "core::num::dec2flt::FloatErrorKind",
  "core::num::dec2flt::ParseFloatError",
  "core::num::dec2flt::common::BiasedFp",
  "core::num::dec2flt::decimal::Decimal",
  "core::num::dec2flt::decimal_seq::DecimalSeq",
  "core::num::diy_float::Fp",
  "core::num::error::IntErrorKind",
  "core::num::error::ParseIntError",
  "core::num::error::TryFromIntError",
  "core::num::flt2dec::Sign",
  "core::num::flt2dec::decoder::Decoded",
  "core::num::flt2dec::decoder::FullDecoded",
  "core::num::fmt::Formatted",
  "core::num::fmt::Part",
  "core::num::niche_types::I32NotAllOnes",
  "core::num::niche_types::I64NotAllOnes",
  "core::num::niche_types::Nanoseconds",
  "core::num::niche_types::NonZeroCharInner",
  "core::num::niche_types::NonZeroI128Inner",
  "core::num::niche_types::NonZeroI16Inner",
  "core::num::niche_types::NonZeroI32Inner",
  "core::num::niche_types::NonZeroI64Inner",
  "core::num::niche_types::NonZeroI8Inner",
  "core::num::niche_types::NonZeroIsizeInner",
  "core::num::niche_types::NonZeroU128Inner",
  "core::num::niche_types::NonZeroU16Inner",
  "core::num::niche_types::NonZeroU32Inner",
  "core::num::niche_types::NonZeroU64Inner",
  "core::num::niche_types::NonZeroU8Inner",
  "core::num::niche_types::NonZeroUsizeInner",
  "core::num::niche_types::U32NotAllOnes",
  "core::num::niche_types::U64NotAllOnes",
  "core::num::niche_types::UsizeNoHighBit",
  "core::num::nonzero::NonZero",
  "core::num::nonzero::ZeroablePrimitive",
  "core::num::nonzero::private::Sealed",
  "core::num::saturating::Saturating",
  "core::num::wrapping::Wrapping",
  "core::ops::arith::Add",
  "core::ops::arith::AddAssign",
  "core::ops::arith::Div",
  "core::ops::arith::DivAssign",
  "core::ops::arith::Mul",
  "core::ops::arith::MulAssign",
  "core::ops::arith::Neg",
  "core::ops::arith::Rem",
  "core::ops::arith::RemAssign",
  "core::ops::arith::Sub",
  "core::ops::arith::SubAssign",
  "core::ops::async_function::AsyncFn",
  "core::ops::async_function::AsyncFnMut",
  "core::ops::async_function::AsyncFnOnce",
  "core::ops::bit::BitAnd",
  "core::ops::bit::BitAndAssign",
  "core::ops::bit::BitOr",
  "core::ops::bit::BitOrAssign",
  "core::ops::bit::BitXor",
  "core::ops::bit::BitXorAssign",
  "core::ops::bit::Not",
  "core::ops::bit::Shl",
  "core::ops::bit::ShlAssign",
  "core::ops::bit::Shr",
  "core::ops::bit::ShrAssign",
  "core::ops::control_flow::ControlFlow",
  "core::ops::coroutine::Coroutine",
  "core::ops::coroutine::CoroutineState",
  "core::ops::deref::Deref",
  "core::ops::deref::DerefMut",
  "core::ops::deref::DerefPure",
  "core::ops::deref::Receiver",
  "core::ops::drop::Drop",
  "core::ops::function::Fn",
  "core::ops::function::FnMut",
  "core::ops::function::FnOnce",
  "core::ops::index::Index",
  "core::ops::index::IndexMut",
  "core::ops::index_range::IndexRange",
  "core::ops::range::Bound",
  "core::ops::range::IntoBounds",
  "core::ops::range::OneSidedRange",
  "core::ops::range::OneSidedRangeBound",
  "core::ops::range::Range",
  "core::ops::range::RangeBounds",
  "core::ops::range::RangeFrom",
  "core::ops::range::RangeFull",
  "core::ops::range::RangeInclusive",
  "core::ops::range::RangeTo",
  "core::ops::range::RangeToInclusive",
  "core::ops::try_trait::FromResidual",
  "core::ops::try_trait::NeverShortCircuit",
  "core::ops::try_trait::NeverShortCircuitResidual",
  "core::ops::try_trait::Residual",
  "core::ops::try_trait::Try",
  "core::ops::try_trait::Yeet",
  "core::ops::unsize::CoerceUnsized",
  "core::ops::unsize::DispatchFromDyn",
  "core::option::IntoIter",
  "core::option::Item",
  "core::option::Iter",
  "core::option::IterMut",
  "core::option::Option",
  "core::panic::location::Location",
  "core::panic::panic_info::PanicInfo",
  "core::panic::panic_info::PanicMessage",
  "core::panic::unwind_safe::AssertUnwindSafe",
  "core::panic::unwind_safe::RefUnwindSafe",
  "core::panic::unwind_safe::UnwindSafe",
  "core::panicking::AssertKind",
  "core::panicking::assert_matches_failed::Pattern",
  "core::pat::RangePattern",
  "core::pin::Pin",
  "core::pin::PinCoerceUnsized",
  "core::pin::unsafe_pinned::UnsafePinned",
  "core::ptr::alignment::Alignment",
  "core::ptr::alignment::AlignmentEnum",
  "core::ptr::metadata::DynMetadata",
  "core::ptr::metadata::Pointee",
  "core::ptr::non_null::NonNull",
  "core::ptr::unique::Unique",
  "core::random::Distribution",
  "core::random::RandomSource",
  "core::range::Range",
  "core::range::RangeFrom",
  "core::range::RangeInclusive",
  "core::range::iter::IterRange",
  "core::range::iter::IterRangeFrom",
  "core::range::iter::IterRangeInclusive",
  "core::result::IntoIter",
  "core::result::Iter",
  "core::result::IterMut",
  "core::result::Result",
  "core::slice::GetDisjointMutError",
  "core::slice::GetDisjointMutIndex",
  "core::slice::SlicePattern",
  "core::slice::ascii::EscapeAscii",
  "core::slice::ascii::EscapeByte",
  "core::slice::index::SliceIndex",
  "core::slice::index::private_slice_index::Sealed",
  "core::slice::iter::ArrayWindows",
  "core::slice::iter::ChunkBy",
  "core::slice::iter::ChunkByMut",
  "core::slice::iter::Chunks",
  "core::slice::iter::ChunksExact",
  "core::slice::iter::ChunksExactMut",
  "core::slice::iter::ChunksMut",
  "core::slice::iter::GenericSplitN",
  "core::slice::iter::Iter",
  "core::slice::iter::IterMut",
  "core::slice::iter::RChunks",
  "core::slice::iter::RChunksExact",
  "core::slice::iter::RChunksExactMut",
  "core::slice::iter::RChunksMut",
  "core::slice::iter::RSplit",
  "core::slice::iter::RSplitMut",
  "core::slice::iter::RSplitN",
  "core::slice::iter::RSplitNMut",
  "core::slice::iter::Split",
  "core::slice::iter::SplitInclusive",
  "core::slice::iter::SplitInclusiveMut",
  "core::slice::iter::SplitMut",
  "core::slice::iter::SplitN",
  "core::slice::iter::SplitNMut",
  "core::slice::iter::Windows",
  "core::slice::private_get_disjoint_mut_index::Sealed",
  "core::slice::sort::shared::smallsort::CopyOnDrop",
  "core::slice::sort::stable::drift::DriftsortRun",
  "core::slice::sort::stable::merge::MergeState",
  "core::slice::sort::unstable::quicksort::GapGuard",
  "core::slice::sort::unstable::quicksort::GapGuardRaw",
  "core::str::BytesIsNotEmpty",
  "core::str::CharEscapeDebugContinue",
  "core::str::CharEscapeDefault",
  "core::str::CharEscapeUnicode",
  "core::str::IsAsciiWhitespace",
  "core::str::IsNotEmpty",
  "core::str::IsWhitespace",
  "core::str::LinesMap",
  "core::str::UnsafeBytesToStr",
  "core::str::error::ParseBoolError",
  "core::str::error::Utf8Error",
  "core::str::iter::Bytes",
  "core::str::iter::CharIndices",
  "core::str::iter::Chars",
  "core::str::iter::EncodeUtf16",
  "core::str::iter::EscapeDebug",
  "core::str::iter::EscapeDefault",
  "core::str::iter::EscapeUnicode",
  "core::str::iter::Lines",
  "core::str::iter::LinesAny",
  "core::str::iter::MatchIndices",
  "core::str::iter::MatchIndicesInternal",
  "core::str::iter::Matches",
  "core::str::iter::MatchesInternal",
  "core::str::iter::RMatchIndices",
  "core::str::iter::RMatches",
  "core::str::iter::RSplit",
  "core::str::iter::RSplitN",
  "core::str::iter::RSplitTerminator",
  "core::str::iter::Split",
  "core::str::iter::SplitAsciiWhitespace",
  "core::str::iter::SplitInclusive",
  "core::str::iter::SplitInternal",
  "core::str::iter::SplitN",
  "core::str::iter::SplitNInternal",
  "core::str::iter::SplitTerminator",
  "core::str::iter::SplitWhitespace",
  "core::str::lossy::Debug",
  "core::str::lossy::Utf8Chunk",
  "core::str::lossy::Utf8Chunks",
  "core::str::pattern::CharArrayRefSearcher",
  "core::str::pattern::CharArraySearcher",
  "core::str::pattern::CharPredicateSearcher",
  "core::str::pattern::CharSearcher",
  "core::str::pattern::CharSliceSearcher",
  "core::str::pattern::DoubleEndedSearcher",
  "core::str::pattern::EmptyNeedle",
  "core::str::pattern::MultiCharEqPattern",
  "core::str::pattern::MultiCharEqSearcher",
  "core::str::pattern::Pattern",
  "core::str::pattern::ReverseSearcher",
  "core::str::pattern::SearchStep",
  "core::str::pattern::Searcher",
  "core::str::pattern::StrSearcher",
  "core::str::pattern::StrSearcherImpl",
  "core::str::pattern::TwoWaySearcher",
  "core::str::pattern::Utf8Pattern",
  "core::str::traits::FromStr",
  "core::sync::atomic::AtomicBool",
  "core::sync::atomic::AtomicI128",
  "core::sync::atomic::AtomicI16",
  "core::sync::atomic::AtomicI32",
  "core::sync::atomic::AtomicI64",
  "core::sync::atomic::AtomicI8",
  "core::sync::atomic::AtomicIsize",
  "core::sync::atomic::AtomicPrimitive",
  "core::sync::atomic::AtomicPtr",
  "core::sync::atomic::AtomicU128",
  "core::sync::atomic::AtomicU16",
  "core::sync::atomic::AtomicU32",
  "core::sync::atomic::AtomicU64",
  "core::sync::atomic::AtomicU8",
  "core::sync::atomic::AtomicUsize",
  "core::sync::atomic::Ordering",
  "core::sync::atomic::Sealed",
  "core::sync::exclusive::Exclusive",
  "core::task::poll::Poll",
  "core::task::wake::Context",
  "core::task::wake::ContextBuilder",
  "core::task::wake::ExtData",
  "core::task::wake::LocalWaker",
  "core::task::wake::RawWaker",
  "core::task::wake::RawWakerVTable",
  "core::task::wake::Waker",
  "core::time::Duration",
  "core::time::TryFromFloatSecsError",
  "core::time::TryFromFloatSecsErrorKind",
  "std::alloc::System",
  "std::ascii::AsciiExt",
  "std::backtrace::Backtrace",
  "std::backtrace::BacktraceFrame",
  "std::backtrace::BacktraceStatus",
  "std::backtrace::BacktraceSymbol",
  "std::backtrace::BytesOrWide",
  "std::backtrace::RawFrame",
  "std::backtrace_rs::backtrace::Frame",
  "std::backtrace_rs::backtrace::libunwind::Bomb",
  "std::backtrace_rs::backtrace::libunwind::Frame",
  "std::backtrace_rs::print::BacktraceFrameFmt",
  "std::backtrace_rs::print::PrintFmt",
  "std::backtrace_rs::symbolize::Symbol",
  "std::backtrace_rs::symbolize::SymbolName",
  "std::backtrace_rs::symbolize::gimli::Cache",
  "std::backtrace_rs::symbolize::gimli::lru::Lru",
  "std::backtrace_rs::symbolize::gimli::mmap::Mmap",
  "std::backtrace_rs::types::BytesOrWideString",
  "std::borrow::Cow",
  "std::boxed::Box",
  "std::collections::BTreeMap",
  "std::collections::BTreeSet",
  "std::collections::BinaryHeap",
  "std::collections::HashMap",
  "std::collections::HashSet",
  "std::collections::LinkedList",
  "std::collections::VecDeque",
  "std::collections::hash::map::Drain",
  "std::collections::hash::map::Entry",
  "std::collections::hash::map::ExtractIf",
  "std::collections::hash::map::HashMap",
  "std::collections::hash::map::IntoIter",
  "std::collections::hash::map::IntoKeys",
  "std::collections::hash::map::IntoValues",
  "std::collections::hash::map::Iter",
  "std::collections::hash::map::IterMut",
  "std::collections::hash::map::Keys",
  "std::collections::hash::map::OccupiedEntry",
  "std::collections::hash::map::OccupiedError",
  "std::collections::hash::map::VacantEntry",
  "std::collections::hash::map::Values",
  "std::collections::hash::map::ValuesMut",
  "std::collections::hash::set::Difference",
  "std::collections::hash::set::Drain",
  "std::collections::hash::set::Entry",
  "std::collections::hash::set::ExtractIf",
  "std::collections::hash::set::HashSet",
  "std::collections::hash::set::Intersection",
  "std::collections::hash::set::IntoIter",
  "std::collections::hash::set::Iter",
  "std::collections::hash::set::OccupiedEntry",
  "std::collections::hash::set::SymmetricDifference",
  "std::collections::hash::set::Union",
  "std::collections::hash::set::VacantEntry",
  "std::env::Args",
  "std::env::ArgsOs",
  "std::env::JoinPathsError",
  "std::env::SplitPaths",
  "std::env::VarError",
  "std::env::Vars",
  "std::env::VarsOs",
  "std::error::Error",
  "std::error::Indented",
  "std::error::Report",
  "std::ffi::CStr",
  "std::ffi::CString",
  "std::ffi::OsStr",
  "std::ffi::OsString",
  "std::ffi::os_str::Display",
  "std::ffi::os_str::OsStr",
  "std::ffi::os_str::OsString",
  "std::fs::DirBuilder",
  "std::fs::DirEntry",
  "std::fs::File",
  "std::fs::FileTimes",
  "std::fs::FileType",
  "std::fs::Metadata",
  "std::fs::OpenOptions",
  "std::fs::Permissions",
  "std::fs::ReadDir",
  "std::fs::TryLockError",
  "std::hash::random::DefaultHasher",
  "std::hash::random::RandomState",
  "std::io::BufRead",
  "std::io::Bytes",
  "std::io::Chain",
  "std::io::Guard",
  "std::io::IoSlice",
  "std::io::IoSliceMut",
  "std::io::Lines",
  "std::io::Read",
  "std::io::Seek",
  "std::io::SeekFrom",
  "std::io::Split",
  "std::io::Take",
  "std::io::Write",
  "std::io::buffered::IntoInnerError",
  "std::io::buffered::bufreader::BufReader",
  "std::io::buffered::bufwriter::BufWriter",
  "std::io::buffered::bufwriter::WriterPanicked",
  "std::io::buffered::bufwriter::flush_buf::BufGuard",
  "std::io::buffered::linewriter::LineWriter",
  "std::io::buffered::linewritershim::LineWriterShim",
  "std::io::cursor::Cursor",
  "std::io::default_write_fmt::Adapter",
  "std::io::error::Custom",
  "std::io::error::Error",
  "std::io::error::ErrorKind",
  "std::io::error::SimpleMessage",
  "std::io::error::repr_bitpacked::Repr",
  "std::io::pipe::PipeReader",
  "std::io::pipe::PipeWriter",
  "std::io::stdio::IsTerminal",
  "std::io::stdio::Stderr",
  "std::io::stdio::StderrLock",
  "std::io::stdio::StderrRaw",
  "std::io::stdio::Stdin",
  "std::io::stdio::StdinLock",
  "std::io::stdio::StdinRaw",
  "std::io::stdio::Stdout",
  "std::io::stdio::StdoutLock",
  "std::io::stdio::StdoutRaw",
  "std::io::util::Empty",
  "std::io::util::Repeat",
  "std::io::util::Sink",
  "std::net::Shutdown",
  "std::net::socket_addr::ToSocketAddrs",
  "std::net::tcp::Incoming",
  "std::net::tcp::IntoIncoming",
  "std::net::tcp::TcpListener",
  "std::net::tcp::TcpStream",
  "std::net::udp::UdpSocket",
  "std::os::darwin::fs::FileTimesExt",
  "std::os::darwin::fs::MetadataExt",
  "std::os::darwin::raw::stat",
  "std::os::fd::owned::AsFd",
  "std::os::fd::owned::BorrowedFd",
  "std::os::fd::owned::OwnedFd",
  "std::os::fd::raw::AsRawFd",
  "std::os::fd::raw::FromRawFd",
  "std::os::fd::raw::IntoRawFd",
  "std::os::unix::ffi::os_str::OsStrExt",
  "std::os::unix::ffi::os_str::OsStringExt",
  "std::os::unix::fs::DirBuilderExt",
  "std::os::unix::fs::DirEntryExt",
  "std::os::unix::fs::DirEntryExt2",
  "std::os::unix::fs::FileExt",
  "std::os::unix::fs::FileTypeExt",
  "std::os::unix::fs::MetadataExt",
  "std::os::unix::fs::OpenOptionsExt",
  "std::os::unix::fs::PermissionsExt",
  "std::os::unix::net::addr::SocketAddr",
  "std::os::unix::net::datagram::UnixDatagram",
  "std::os::unix::net::listener::Incoming",
  "std::os::unix::net::listener::UnixListener",
  "std::os::unix::net::stream::UnixStream",
  "std::os::unix::net::ucred::UCred",
  "std::os::unix::process::ChildExt",
  "std::os::unix::process::CommandExt",
  "std::os::unix::process::ExitStatusExt",
  "std::os::unix::thread::JoinHandleExt",
  "std::panic::BacktraceStyle",
  "std::panic::PanicHookInfo",
  "std::panicking::Hook",
  "std::panicking::begin_panic::Payload",
  "std::panicking::begin_panic_handler::FormatStringPayload",
  "std::panicking::begin_panic_handler::StaticStrPayload",
  "std::panicking::panic_count::MustAbort",
  "std::panicking::rust_panic_without_hook::RewrapBox",
  "std::path::Ancestors",
  "std::path::Component",
  "std::path::Components",
  "std::path::Display",
  "std::path::Iter",
  "std::path::NormalizeError",
  "std::path::Path",
  "std::path::PathBuf",
  "std::path::Prefix",
  "std::path::PrefixComponent",
  "std::path::State",
  "std::path::StripPrefixError",
  "std::path::fmt::DebugHelper",
  "std::process::Child",
  "std::process::ChildStderr",
  "std::process::ChildStdin",
  "std::process::ChildStdout",
  "std::process::Command",
  "std::process::CommandArgs",
  "std::process::CommandEnvs",
  "std::process::ExitCode",
  "std::process::ExitStatus",
  "std::process::ExitStatusError",
  "std::process::Output",
  "std::process::Stdio",
  "std::process::Termination",
  "std::random::DefaultRandomSource",
  "std::rc::Rc",
  "std::sealed::Sealed",
  "std::std_float::StdFloat",
  "std::string::String",
  "std::sync::Arc",
  "std::sync::Mutex",
  "std::sync::RwLock",
  "std::sync::barrier::Barrier",
  "std::sync::barrier::BarrierWaitResult",
  "std::sync::lazy_lock::LazyLock",
  "std::sync::lazy_lock::force_mut::really_init_mut::PoisonOnPanic",
  "std::sync::mpmc::IntoIter",
  "std::sync::mpmc::Iter",
  "std::sync::mpmc::Receiver",
  "std::sync::mpmc::Sender",
  "std::sync::mpmc::TryIter",
  "std::sync::mpmc::array::ArrayToken",
  "std::sync::mpmc::context::Context",
  "std::sync::mpmc::context::Inner",
  "std::sync::mpmc::counter::Receiver",
  "std::sync::mpmc::counter::Sender",
  "std::sync::mpmc::error::SendTimeoutError",
  "std::sync::mpmc::list::Channel",
  "std::sync::mpmc::list::ListToken",
  "std::sync::mpmc::list::Position",
  "std::sync::mpmc::select::Operation",
  "std::sync::mpmc::select::Selected",
  "std::sync::mpmc::select::Token",
  "std::sync::mpmc::utils::CachePadded",
  "std::sync::mpmc::waker::SyncWaker",
  "std::sync::mpmc::waker::Waker",
  "std::sync::mpmc::zero::ZeroToken",
  "std::sync::mpsc::IntoIter",
  "std::sync::mpsc::Iter",
  "std::sync::mpsc::Receiver",
  "std::sync::mpsc::RecvError",
  "std::sync::mpsc::RecvTimeoutError",
  "std::sync::mpsc::SendError",
  "std::sync::mpsc::Sender",
  "std::sync::mpsc::SyncSender",
  "std::sync::mpsc::TryIter",
  "std::sync::mpsc::TryRecvError",
  "std::sync::mpsc::TrySendError",
  "std::sync::nonpoison::WouldBlock",
  "std::sync::nonpoison::mutex::MappedMutexGuard",
  "std::sync::nonpoison::mutex::Mutex",
  "std::sync::nonpoison::mutex::MutexGuard",
  "std::sync::once_lock::OnceLock",
  "std::sync::poison::Flag",
  "std::sync::poison::Guard",
  "std::sync::poison::PoisonError",
  "std::sync::poison::TryLockError",
  "std::sync::poison::condvar::Condvar",
  "std::sync::poison::condvar::WaitTimeoutResult",
  "std::sync::poison::mutex::MappedMutexGuard",
  "std::sync::poison::mutex::Mutex",
  "std::sync::poison::mutex::MutexGuard",
  "std::sync::poison::once::Once",
  "std::sync::poison::once::OnceState",
  "std::sync::poison::rwlock::MappedRwLockReadGuard",
  "std::sync::poison::rwlock::MappedRwLockWriteGuard",
  "std::sync::poison::rwlock::RwLock",
  "std::sync::poison::rwlock::RwLockReadGuard",
  "std::sync::poison::rwlock::RwLockWriteGuard",
  "std::sync::reentrant_lock::ReentrantLock",
  "std::sync::reentrant_lock::ReentrantLockGuard",
  "std::sys::args::common::Args",
  "std::sys::backtrace::print::DisplayBacktrace",
  "std::sys::env::common::Env",
  "std::sys::env::common::EnvStrDebug",
  "std::sys::fd::unix::FileDesc",
  "std::sys::fs::unix::Dir",
  "std::sys::fs::unix::DirBuilder",
  "std::sys::fs::unix::File",
  "std::sys::fs::unix::FileAttr",
  "std::sys::fs::unix::FilePermissions",
  "std::sys::fs::unix::FileTimes",
  "std::sys::fs::unix::FileType",
  "std::sys::fs::unix::Mode",
  "std::sys::fs::unix::OpenOptions",
  "std::sys::fs::unix::ReadDir",
  "std::sys::fs::unix::cfm::CachedFileMetadata",
  "std::sys::fs::unix::copy::FreeOnDrop",
  "std::sys::io::io_slice::iovec::IoSlice",
  "std::sys::net::connection::socket::LookupHost",
  "std::sys::net::connection::socket::TcpListener",
  "std::sys::net::connection::socket::TcpStream",
  "std::sys::net::connection::socket::UdpSocket",
  "std::sys::net::connection::socket::unix::Socket",
  "std::sys::os_str::bytes::Buf",
  "std::sys::os_str::bytes::Slice",
  "std::sys::pal::unix::os::JoinPathsError",
  "std::sys::pal::unix::os::SplitPaths",
  "std::sys::pal::unix::pipe::AnonPipe",
  "std::sys::pal::unix::stack_overflow::Handler",
  "std::sys::pal::unix::stack_overflow::thread_info::UnlockOnDrop",
  "std::sys::pal::unix::sync::condvar::Condvar",
  "std::sys::pal::unix::sync::mutex::AttrGuard",
  "std::sys::pal::unix::sync::mutex::Mutex",
  "std::sys::pal::unix::thread::Thread",
  "std::sys::pal::unix::time::Instant",
  "std::sys::pal::unix::time::SystemTime",
  "std::sys::pal::unix::time::Timespec",
  "std::sys::personality::dwarf::eh::EHContext",
  "std::sys::process::env::CommandEnv",
  "std::sys::process::env::CommandEnvs",
  "std::sys::process::unix::common::Command",
  "std::sys::process::unix::common::CommandArgs",
  "std::sys::process::unix::common::ExitCode",
  "std::sys::process::unix::common::ProgramKind",
  "std::sys::process::unix::common::Stdio",
  "std::sys::process::unix::common::cstring_array::CStringArray",
  "std::sys::process::unix::common::cstring_array::CStringIter",
  "std::sys::process::unix::unix::ExitStatus",
  "std::sys::process::unix::unix::ExitStatusError",
  "std::sys::process::unix::unix::do_exec::Reset",
  "std::sys::process::unix::unix::posix_spawn::PosixSpawnFileActions",
  "std::sys::process::unix::unix::posix_spawn::PosixSpawnattr",
  "std::sys::stdio::unix::Stderr",
  "std::sys::stdio::unix::Stdin",
  "std::sys::stdio::unix::Stdout",
  "std::sys::sync::mutex::pthread::Mutex",
  "std::sys::sync::once::queue::Once",
  "std::sys::sync::once::queue::WaiterQueue",
  "std::sys::sync::once_box::OnceBox",
  "std::sys::sync::rwlock::queue::PanicGuard",
  "std::sys::sync::rwlock::queue::RwLock",
  "std::sys::sync::thread_parking::darwin::Parker",
  "std::sys::thread_local::abort_on_dtor_unwind::DtorUnwindGuard",
  "std::sys::thread_local::native::eager::State",
  "std::sys::thread_local::native::lazy::State",
  "std::sys_common::wstr::WStrUnits",
  "std::sys_common::wtf8::CodePoint",
  "std::sys_common::wtf8::EncodeWide",
  "std::sys_common::wtf8::Wtf8",
  "std::sys_common::wtf8::Wtf8Buf",
  "std::sys_common::wtf8::Wtf8CodePoints",
  "std::thread::Builder",
  "std::thread::JoinHandle",
  "std::thread::Packet",
  "std::thread::PanicGuard",
  "std::thread::Thread",
  "std::thread::ThreadId",
  "std::thread::local::AccessError",
  "std::thread::local::LocalKey",
  "std::thread::scoped::Scope",
  "std::thread::scoped::ScopedJoinHandle",
  "std::thread::spawn_unchecked_::MaybeDangling",
  "std::thread::spawnhook::ChildSpawnHooks",
  "std::thread::spawnhook::SpawnHooks",
  "std::thread::thread_name_string::ThreadNameString",
  "std::time::Instant",
  "std::time::SystemTime",
  "std::time::SystemTimeError",
  "std::vec::Vec"
];

// dist/class-graph/rust/rust-resolution-context-provider.js
var RustResolutionContextProvider = class {
  getResolutionContext(nodes, visited) {
    const nodeIdToIndex = /* @__PURE__ */ new Map();
    for (let i3 = 0; i3 < nodes.length; ++i3) {
      nodeIdToIndex.set(nodes[i3].nodeId, i3);
    }
    const fqnMap = /* @__PURE__ */ new Map();
    const childMap = /* @__PURE__ */ new Map();
    const baseImportMap = /* @__PURE__ */ new Map();
    const crates = /* @__PURE__ */ new Set();
    for (const fqn of STD_TYPES) {
      fqnMap.set(fqn, []);
      const parts2 = fqn.split("::").filter(Boolean);
      crates.add(parts2[0]);
      for (let i3 = 1; i3 < parts2.length; i3++) {
        const parent = parts2.slice(0, i3).join("::");
        const child = parts2[i3];
        if (!childMap.has(parent)) {
          childMap.set(parent, []);
        }
        childMap.get(parent).push(child);
      }
    }
    for (const fqn of STD_AUTO_IMPORTED) {
      fqnMap.set(fqn, []);
      const simpleName = fqn.split("::").filter(Boolean).pop();
      if (simpleName) {
        baseImportMap.set(simpleName, [fqn]);
      }
    }
    nodes.forEach((node, idx) => {
      const fqn = node.fullyQualifiedName;
      crates.add(node.crate);
      if (node.nodeType === "type") {
        if (!fqnMap.has(fqn)) {
          fqnMap.set(fqn, []);
        }
        fqnMap.get(fqn).push(idx);
        const parts2 = fqn.split("::").filter(Boolean);
        for (let i3 = 1; i3 < parts2.length; i3++) {
          const parent = parts2.slice(0, i3).join("::");
          const child = parts2[i3];
          if (!childMap.has(parent)) {
            childMap.set(parent, []);
          }
          childMap.get(parent).push(child);
        }
      }
    });
    visited ??= /* @__PURE__ */ new Set();
    return {
      type: "RUST",
      nodes,
      visited,
      nodeIdToIndex,
      fqnMap,
      childMap,
      baseImportMap,
      crates
    };
  }
};

// dist/rust-reachability-analyzer.js
async function createRustResolverCallback(resources) {
  await Parser.init();
  const rustSourceResolver = await createTreeSitterResolver(resources.treeSitterRust, "tree-sitter-rust.wasm", RustSourceResolver);
  return (file) => {
    const filext = extname7(file);
    switch (filext) {
      case ".rs":
        return rustSourceResolver;
    }
    return void 0;
  };
}
async function runRustDirectDependencyAnalysis(options, resources = {}) {
  const resolverCb = await createRustResolverCallback(resources);
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new RustResolutionContextProvider()),
    ...options
  });
  return await runner.runDirectDependencyAnalysis();
}
async function runRustReachabilityAnalysis(options, resources = {}) {
  const resolverCb = await createRustResolverCallback(resources);
  const srcExcludeDirs = ["bin"];
  const runner = new ClassGraphRunner({
    srcResolutionManager: new SourceResolutionManager(resolverCb, new RustResolutionContextProvider(), srcExcludeDirs),
    apps: options.apps,
    deps: options.deps,
    timeoutInSeconds: options.timeoutInSeconds
  });
  return await runner.runAnalysis(options.vulnerableClasses);
}

// dist/commands/rust-direct-dependency-analysis.js
var flags6 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  treeSitterRust: { type: "string" }
};
var runRustDirectDependencyAnalysisCmd = {
  description: "Run Rust direct dependency analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runRustDirectDependencyAnalysis [options]

    Options
      --input-file, -i      Input file for data and vulnerabilities (required)
      --output-file, -o     Output file for the results (required)
      --tree-sitter-rust    Path to tree-sitter-rust dir

    Examples
      $ ${parentName} runRustDirectDependencyAnalysis -i input.json -o output.json --tree-sitter-rust ./tree-sitter-rust
    `, {
      importMeta,
      argv,
      flags: flags6
    });
    const { inputFile, outputFile, treeSitterRust } = cli.flags;
    const resources = { treeSitterRust };
    const analysisOptions = JSON.parse(await readFile12(inputFile, "utf-8"));
    const result = await runRustDirectDependencyAnalysis(analysisOptions, resources);
    await writeFile7(outputFile, JSON.stringify({ result }));
  }
};

// dist/commands/rust-reachability-analysis.js
import { readFile as readFile13, writeFile as writeFile8 } from "node:fs/promises";
var flags7 = {
  inputFile: { type: "string", shortFlag: "i", isRequired: true },
  outputFile: { type: "string", shortFlag: "o", isRequired: true },
  treeSitterRust: { type: "string" }
};
var runRustReachabilityAnalysisCmd = {
  description: "Run Rust reachability analysis",
  async run(argv, importMeta, { parentName }) {
    const cli = meow(`
    Usage
      $ ${parentName} runRustReachabilityAnalysis [options]

    Options
      --input-file, -i      Input file for data and vulnerabilities (required)
      --output-file, -o     Output file for the results (required)
      --tree-sitter-rust      Path to tree-sitter-rust dir

    Examples
      $ ${parentName} runRustReachabilityAnalysis -i input.json -o output.json --tree-sitter-rust ./tree-sitter-rust
    `, {
      importMeta,
      argv,
      flags: flags7
    });
    const { inputFile, outputFile, treeSitterRust } = cli.flags;
    const resources = { treeSitterRust };
    const analysisOptions = JSON.parse(await readFile13(inputFile, "utf-8"));
    const result = await runRustReachabilityAnalysis(analysisOptions, resources);
    await writeFile8(outputFile, JSON.stringify({ result }));
  }
};

// dist/class-graph-analysis-cli.js
try {
  await meowWithSubcommands({
    runJvmDirectDependencyAnalysis: runJvmDirectDependencyAnalysisCmd,
    runJvmReachabilityAnalysis: runJvmReachabilityAnalysisCmd,
    runDotnetDirectDependencyAnalysis: runDotnetDirectDependencyAnalysisCmd,
    runDotnetReachabilityAnalysis: runDotnetReachabilityAnalysisCmd,
    runRustDirectDependencyAnalysis: runRustDirectDependencyAnalysisCmd,
    runRustReachabilityAnalysis: runRustReachabilityAnalysisCmd
  }, process.argv.slice(2), "class-graph-analysis");
} catch (error) {
  console.error("Error:", error instanceof Error ? error.message : String(error));
  process.exit(1);
}
//# sourceMappingURL=class-graph-analysis-cli.mjs.map
